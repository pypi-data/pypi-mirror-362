# -*- coding: utf-8 -*-
"""TLKT_20250717_00.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z6z9H97ocV29JUfhCsKK9_SX0TgT4PHu

# ToolKit
高汎用モジュール集


```
2025/04/02 0.1.0 完成
2025/04/03 0.1.5 小規模修正
2025/04/03 0.2.1 executorメソッドにtimeoutオプションを追加
2025/04/04 0.2.2 バグ取り
2025/04/12 0.2.3 バグ取り
2025/04/12 0.2.4 バグ取り
2025/05/13 0.3.0 logging対応
2025/05/14 0.4.4 logging対応強化
2025/07/17 0.4.5 バグ取り
```

# ToolKit

## 1. logging 定義
"""

# @title a. logging 定義
import logging

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    force=True
)

"""## 2. モジュール定義"""

# @title a.ToolKit 定義
# ────────────────────────────────────────────────────────────────
# 各モジュール用logger設定
import logging
logger = logging.getLogger(__name__)
# ────────────────────────────────────────────────────────────────
import os, sys, io, shutil, threading, subprocess, time, contextlib
from pathlib import Path

try:
    import virtualenv
except ImportError:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "virtualenv"])
    import virtualenv

class ToolKit():
    def __init__( self ):
        """
        ツールキット
        """

    def file_remover( self, target ):
        """
        ファイルを消去します
        args:
            target( str ): 消去するファイルのパス
        """
        if os.path.exists( target ):
            logging.info(f"{ target } に既存のファイルが存在します。削除します。", success=None, back = 1 )
            try:
                result = subprocess.run(["rm", "-f", target], capture_output=True, text=True)
                # os.remove( target )
                if result.returncode != 0:
                    raise Exception(f"ファイルの削除に失敗しました: {result.stderr}")
                timeout = 5  # 最大5秒待つ
                interval = 0.1  # 0.1秒毎にチェック
                elapsed = 0
                while os.path.exists(target) and elapsed < timeout:
                    time.sleep(interval)
                    elapsed += interval
                if os.path.exists(target):
                    logging.critical( f"{target} の削除がタイムアウトしました。" )
                    raise Exception(f"タイムアウト: {target} が削除されませんでした。")
                logging.info( "既存のファイルを正常に削除しました。" )
            except Exception as e:
                logging.error( f"既存ファイルの削除に失敗しました: {e}" )
                raise

    def dir_remover( self, target ):
        """
        ディレクトリを消去します
        args:
            target( str ): 消去するディレクトリ
        """
        if os.path.exists( target ):
            logging.info(f"{ target } に既存のディレクトリが存在します。削除します。")
            try:
                shutil.rmtree( target )
                timeout = 5  # 最大5秒待つ
                interval = 0.1  # 0.1秒毎にチェック
                elapsed = 0
                while os.path.exists(target) and elapsed < timeout:
                    time.sleep(interval)
                    elapsed += interval
                if os.path.exists(target):
                    logging.critical(f"{target} の削除がタイムアウトしました。")
                    raise Exception(f"タイムアウト: {target} が削除されませんでした。")
                logging.info("既存のディレクトリを正常に削除しました。")
            except Exception as e:
                logging.error(f"既存ディレクトリの削除に失敗しました: {e}")
                raise

    def executor( self, cmd , shell = False, log = False, timeout = 900 ):
        """
        subprocess.runを用いてコマンドを実行する。
        起動オプションは(1)のとおりに固定。
        状況に適さないならsubprocess.runを使った方が良い。

        (1) check=True, capture_output=True, text=True

        args:
            cmd( str | list [str] ): 実行するコマンド
            shell( bool ) : コマンドの書き方。Trueだと文字列、Falseだと文字配列
            log( bool ) : ログ出力するかどうか
            timeout( int ): タイムアウト時間(秒)
        returns:


        - 参考・subprocess.runのオプション一覧
            - args
            実行するコマンドを指定します。通常は文字列のリスト（例：["ls", "-l"]）ですが、
            shell=True の場合は単一の文字列でも構いません。
            - check
            True にすると、コマンドの終了コードが 0 でない場合に CalledProcessError を
            発生させます。これにより、エラー時に例外処理で捕捉できるようになります。
            - capture_output
            True に設定すると、標準出力（stdout）と標準エラー出力（stderr）がキャプチャ
            され、結果の CompletedProcess オブジェクトの stdout および stderr 属性で
            アクセスできるようになります。
            ※ Python 3.7 以降で使用可能です。
            - text（または universal_newlines）
            True にすると、標準出力および標準エラー出力がバイト列ではなく文字列として返され
            ます。これにより、出力のデコード処理を自前で行う必要がなくなります。
            ※ Python 3.7 以降では text が推奨されます。
            - shell
            True にすると、コマンドがシェル経由で実行されます。これにより、シェルの特殊文字
            やリダイレクト（> など）を使うことができますが、セキュリティ上の注意も必要です。
            - cwd
            コマンド実行時のカレントワーキングディレクトリを指定できます。これを使って、特定
            のディレクトリからコマンドを実行できます。
            - env
            コマンド実行時に使用する環境変数の辞書を指定します。これを設定すると、現在の環境
            とは異なる環境変数を使ってコマンドを実行できます。
            - input
            標準入力に渡すデータを指定します。text=True の場合は文字列、そうでない場合はバ
            イト列を渡します。
            - timeout
            コマンドの実行が指定した秒数を超えた場合に TimeoutExpired エラーを発生させます。
        returns:
            subprocess.CompletedProcess
        """
        logging.info(f"コマンド: { cmd if shell else ' '.join(cmd) }")

        try:
            result = subprocess.run( cmd, shell = shell, check=True, capture_output=True, text=True )
            logging.info(f"成功!!!")
            if log:
                logging.info( f"stdout:\n{ result.stdout }")
                logging.info( f"stderr:\n{ result.stderr }")
            return result
        except subprocess.CalledProcessError as e:
            logging.error(f"失敗しました。エラーコード: {e.returncode}")
            logging.error(f"エラーメッセージ: {e.stderr}")
            raise
        except Exception as e:
            logging.error(f"予期しないエラーが発生しました: {e}")
            raise


    def executor_sync(self, cmd, shell=False ):
        """
        sync仕様executor。
        timeoutオプションには対応していません。
        args:
            cmd( str [] ): 実行するコマンド
            shell( bool ) : コマンドの書き方。Trueだと文字列、Falseだと文字配列
        returns:
            subprocess.CompletedProcess
        """
        logging.info(f"cmd: { cmd }")

        # Popenでプロセスを起動し、stdout, stderr をリアルタイムに取得する
        process = subprocess.Popen(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,  # 行単位でバッファリング
            universal_newlines=True,
        )

        # stdoutをリアルタイムでログ出力するためのスレッド
        def log_stdout(pipe):
            for line in iter(pipe.readline, ''):
                logging.info(line.rstrip())
            pipe.close()

        # stderrも同様にログ出力する（必要に応じて）
        def log_stderr(pipe):
            for line in iter(pipe.readline, ''):
                logging.info(f"ERR: {line.rstrip()}")
            pipe.close()

        stdout_thread = threading.Thread(target=log_stdout, args=(process.stdout,))
        stderr_thread = threading.Thread(target=log_stderr, args=(process.stderr,))
        stdout_thread.start()
        stderr_thread.start()

        # プロセスの終了を待つ
        process.wait()
        stdout_thread.join()
        stderr_thread.join()

        logging.info( f"result: {process.returncode}")

        if process.returncode == 0:
            logging.info(f"成功!!!")
            return process
        else:
            logging.error(f"失敗しました。エラーコード: {process.returncode}")
            raise subprocess.CalledProcessError(returncode=process.returncode, cmd=cmd)


    def create_virtualenv(self, venv_path: Path, python_executable: str = "/usr/bin/python3"):
        """
        virtualenv.cli_run を呼び出して仮想環境を作成し、
        ログを出力します。
        args:
            venv_path( Path ): 仮想環境のパス
            python_executable( str ): pythonのパス(普通は既定の/usr/bin/python3のままで良い)
        """
        cmd = [
            "virtualenv",
            "--python", python_executable,
            str(venv_path)
        ]
        logger.info(f"🔧 Running: {' '.join(cmd)}")
        res = subprocess.run(cmd, capture_output=True, text=True)
        if res.returncode == 0:
            logger.info("✅ virtualenv created successfully")
            if res.stdout:
                logger.debug(res.stdout)
        else:
            logger.error(f"❌ virtualenv failed ({res.returncode}):\n{res.stderr}")
            res.check_returncode()

"""## 3. テスト"""

# @title ToolKit テスト
if __name__ == "__main__":
    toolkit = ToolKit()
    toolkit.executor_sync( cmd = "pip --version", shell = True )