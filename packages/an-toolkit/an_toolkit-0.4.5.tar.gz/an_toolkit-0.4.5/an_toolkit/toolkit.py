# -*- coding: utf-8 -*-
"""TLKT_20250717_00.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z6z9H97ocV29JUfhCsKK9_SX0TgT4PHu

# ToolKit
é«˜æ±ç”¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é›†


```
2025/04/02 0.1.0 å®Œæˆ
2025/04/03 0.1.5 å°è¦æ¨¡ä¿®æ­£
2025/04/03 0.2.1 executorãƒ¡ã‚½ãƒƒãƒ‰ã«timeoutã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
2025/04/04 0.2.2 ãƒã‚°å–ã‚Š
2025/04/12 0.2.3 ãƒã‚°å–ã‚Š
2025/04/12 0.2.4 ãƒã‚°å–ã‚Š
2025/05/13 0.3.0 loggingå¯¾å¿œ
2025/05/14 0.4.4 loggingå¯¾å¿œå¼·åŒ–
2025/07/17 0.4.5 ãƒã‚°å–ã‚Š
```

# ToolKit

## 1. logging å®šç¾©
"""

# @title a. logging å®šç¾©
import logging

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    force=True
)

"""## 2. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©"""

# @title a.ToolKit å®šç¾©
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç”¨loggerè¨­å®š
import logging
logger = logging.getLogger(__name__)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import os, sys, io, shutil, threading, subprocess, time, contextlib
from pathlib import Path

try:
    import virtualenv
except ImportError:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "virtualenv"])
    import virtualenv

class ToolKit():
    def __init__( self ):
        """
        ãƒ„ãƒ¼ãƒ«ã‚­ãƒƒãƒˆ
        """

    def file_remover( self, target ):
        """
        ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¶ˆå»ã—ã¾ã™
        args:
            target( str ): æ¶ˆå»ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
        """
        if os.path.exists( target ):
            logging.info(f"{ target } ã«æ—¢å­˜ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã™ã€‚å‰Šé™¤ã—ã¾ã™ã€‚", success=None, back = 1 )
            try:
                result = subprocess.run(["rm", "-f", target], capture_output=True, text=True)
                # os.remove( target )
                if result.returncode != 0:
                    raise Exception(f"ãƒ•ã‚¡ã‚¤ãƒ«ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ: {result.stderr}")
                timeout = 5  # æœ€å¤§5ç§’å¾…ã¤
                interval = 0.1  # 0.1ç§’æ¯ã«ãƒã‚§ãƒƒã‚¯
                elapsed = 0
                while os.path.exists(target) and elapsed < timeout:
                    time.sleep(interval)
                    elapsed += interval
                if os.path.exists(target):
                    logging.critical( f"{target} ã®å‰Šé™¤ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚" )
                    raise Exception(f"ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {target} ãŒå‰Šé™¤ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚")
                logging.info( "æ—¢å­˜ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ­£å¸¸ã«å‰Šé™¤ã—ã¾ã—ãŸã€‚" )
            except Exception as e:
                logging.error( f"æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}" )
                raise

    def dir_remover( self, target ):
        """
        ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æ¶ˆå»ã—ã¾ã™
        args:
            target( str ): æ¶ˆå»ã™ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        """
        if os.path.exists( target ):
            logging.info(f"{ target } ã«æ—¢å­˜ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ã¾ã™ã€‚å‰Šé™¤ã—ã¾ã™ã€‚")
            try:
                shutil.rmtree( target )
                timeout = 5  # æœ€å¤§5ç§’å¾…ã¤
                interval = 0.1  # 0.1ç§’æ¯ã«ãƒã‚§ãƒƒã‚¯
                elapsed = 0
                while os.path.exists(target) and elapsed < timeout:
                    time.sleep(interval)
                    elapsed += interval
                if os.path.exists(target):
                    logging.critical(f"{target} ã®å‰Šé™¤ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚")
                    raise Exception(f"ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {target} ãŒå‰Šé™¤ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚")
                logging.info("æ—¢å­˜ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æ­£å¸¸ã«å‰Šé™¤ã—ã¾ã—ãŸã€‚")
            except Exception as e:
                logging.error(f"æ—¢å­˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
                raise

    def executor( self, cmd , shell = False, log = False, timeout = 900 ):
        """
        subprocess.runã‚’ç”¨ã„ã¦ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã€‚
        èµ·å‹•ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯(1)ã®ã¨ãŠã‚Šã«å›ºå®šã€‚
        çŠ¶æ³ã«é©ã•ãªã„ãªã‚‰subprocess.runã‚’ä½¿ã£ãŸæ–¹ãŒè‰¯ã„ã€‚

        (1) check=True, capture_output=True, text=True

        args:
            cmd( str | list [str] ): å®Ÿè¡Œã™ã‚‹ã‚³ãƒãƒ³ãƒ‰
            shell( bool ) : ã‚³ãƒãƒ³ãƒ‰ã®æ›¸ãæ–¹ã€‚Trueã ã¨æ–‡å­—åˆ—ã€Falseã ã¨æ–‡å­—é…åˆ—
            log( bool ) : ãƒ­ã‚°å‡ºåŠ›ã™ã‚‹ã‹ã©ã†ã‹
            timeout( int ): ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“(ç§’)
        returns:


        - å‚è€ƒãƒ»subprocess.runã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ä¸€è¦§
            - args
            å®Ÿè¡Œã™ã‚‹ã‚³ãƒãƒ³ãƒ‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚é€šå¸¸ã¯æ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆï¼ˆä¾‹ï¼š["ls", "-l"]ï¼‰ã§ã™ãŒã€
            shell=True ã®å ´åˆã¯å˜ä¸€ã®æ–‡å­—åˆ—ã§ã‚‚æ§‹ã„ã¾ã›ã‚“ã€‚
            - check
            True ã«ã™ã‚‹ã¨ã€ã‚³ãƒãƒ³ãƒ‰ã®çµ‚äº†ã‚³ãƒ¼ãƒ‰ãŒ 0 ã§ãªã„å ´åˆã« CalledProcessError ã‚’
            ç™ºç”Ÿã•ã›ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¨ãƒ©ãƒ¼æ™‚ã«ä¾‹å¤–å‡¦ç†ã§æ•æ‰ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
            - capture_output
            True ã«è¨­å®šã™ã‚‹ã¨ã€æ¨™æº–å‡ºåŠ›ï¼ˆstdoutï¼‰ã¨æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ï¼ˆstderrï¼‰ãŒã‚­ãƒ£ãƒ—ãƒãƒ£
            ã•ã‚Œã€çµæœã® CompletedProcess ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® stdout ãŠã‚ˆã³ stderr å±æ€§ã§
            ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
            â€» Python 3.7 ä»¥é™ã§ä½¿ç”¨å¯èƒ½ã§ã™ã€‚
            - textï¼ˆã¾ãŸã¯ universal_newlinesï¼‰
            True ã«ã™ã‚‹ã¨ã€æ¨™æº–å‡ºåŠ›ãŠã‚ˆã³æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ãŒãƒã‚¤ãƒˆåˆ—ã§ã¯ãªãæ–‡å­—åˆ—ã¨ã—ã¦è¿”ã•ã‚Œ
            ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€å‡ºåŠ›ã®ãƒ‡ã‚³ãƒ¼ãƒ‰å‡¦ç†ã‚’è‡ªå‰ã§è¡Œã†å¿…è¦ãŒãªããªã‚Šã¾ã™ã€‚
            â€» Python 3.7 ä»¥é™ã§ã¯ text ãŒæ¨å¥¨ã•ã‚Œã¾ã™ã€‚
            - shell
            True ã«ã™ã‚‹ã¨ã€ã‚³ãƒãƒ³ãƒ‰ãŒã‚·ã‚§ãƒ«çµŒç”±ã§å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚·ã‚§ãƒ«ã®ç‰¹æ®Šæ–‡å­—
            ã‚„ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆï¼ˆ> ãªã©ï¼‰ã‚’ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ãŒã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®æ³¨æ„ã‚‚å¿…è¦ã§ã™ã€‚
            - cwd
            ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œæ™‚ã®ã‚«ãƒ¬ãƒ³ãƒˆãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æŒ‡å®šã§ãã¾ã™ã€‚ã“ã‚Œã‚’ä½¿ã£ã¦ã€ç‰¹å®š
            ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã§ãã¾ã™ã€‚
            - env
            ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œæ™‚ã«ä½¿ç”¨ã™ã‚‹ç’°å¢ƒå¤‰æ•°ã®è¾æ›¸ã‚’æŒ‡å®šã—ã¾ã™ã€‚ã“ã‚Œã‚’è¨­å®šã™ã‚‹ã¨ã€ç¾åœ¨ã®ç’°å¢ƒ
            ã¨ã¯ç•°ãªã‚‹ç’°å¢ƒå¤‰æ•°ã‚’ä½¿ã£ã¦ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã§ãã¾ã™ã€‚
            - input
            æ¨™æº–å…¥åŠ›ã«æ¸¡ã™ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡å®šã—ã¾ã™ã€‚text=True ã®å ´åˆã¯æ–‡å­—åˆ—ã€ãã†ã§ãªã„å ´åˆã¯ãƒ
            ã‚¤ãƒˆåˆ—ã‚’æ¸¡ã—ã¾ã™ã€‚
            - timeout
            ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡ŒãŒæŒ‡å®šã—ãŸç§’æ•°ã‚’è¶…ãˆãŸå ´åˆã« TimeoutExpired ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚
        returns:
            subprocess.CompletedProcess
        """
        logging.info(f"ã‚³ãƒãƒ³ãƒ‰: { cmd if shell else ' '.join(cmd) }")

        try:
            result = subprocess.run( cmd, shell = shell, check=True, capture_output=True, text=True )
            logging.info(f"æˆåŠŸ!!!")
            if log:
                logging.info( f"stdout:\n{ result.stdout }")
                logging.info( f"stderr:\n{ result.stderr }")
            return result
        except subprocess.CalledProcessError as e:
            logging.error(f"å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰: {e.returncode}")
            logging.error(f"ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: {e.stderr}")
            raise
        except Exception as e:
            logging.error(f"äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
            raise


    def executor_sync(self, cmd, shell=False ):
        """
        syncä»•æ§˜executorã€‚
        timeoutã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«ã¯å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚
        args:
            cmd( str [] ): å®Ÿè¡Œã™ã‚‹ã‚³ãƒãƒ³ãƒ‰
            shell( bool ) : ã‚³ãƒãƒ³ãƒ‰ã®æ›¸ãæ–¹ã€‚Trueã ã¨æ–‡å­—åˆ—ã€Falseã ã¨æ–‡å­—é…åˆ—
        returns:
            subprocess.CompletedProcess
        """
        logging.info(f"cmd: { cmd }")

        # Popenã§ãƒ—ãƒ­ã‚»ã‚¹ã‚’èµ·å‹•ã—ã€stdout, stderr ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«å–å¾—ã™ã‚‹
        process = subprocess.Popen(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,  # è¡Œå˜ä½ã§ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°
            universal_newlines=True,
        )

        # stdoutã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ãƒ­ã‚°å‡ºåŠ›ã™ã‚‹ãŸã‚ã®ã‚¹ãƒ¬ãƒƒãƒ‰
        def log_stdout(pipe):
            for line in iter(pipe.readline, ''):
                logging.info(line.rstrip())
            pipe.close()

        # stderrã‚‚åŒæ§˜ã«ãƒ­ã‚°å‡ºåŠ›ã™ã‚‹ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
        def log_stderr(pipe):
            for line in iter(pipe.readline, ''):
                logging.info(f"ERR: {line.rstrip()}")
            pipe.close()

        stdout_thread = threading.Thread(target=log_stdout, args=(process.stdout,))
        stderr_thread = threading.Thread(target=log_stderr, args=(process.stderr,))
        stdout_thread.start()
        stderr_thread.start()

        # ãƒ—ãƒ­ã‚»ã‚¹ã®çµ‚äº†ã‚’å¾…ã¤
        process.wait()
        stdout_thread.join()
        stderr_thread.join()

        logging.info( f"result: {process.returncode}")

        if process.returncode == 0:
            logging.info(f"æˆåŠŸ!!!")
            return process
        else:
            logging.error(f"å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰: {process.returncode}")
            raise subprocess.CalledProcessError(returncode=process.returncode, cmd=cmd)


    def create_virtualenv(self, venv_path: Path, python_executable: str = "/usr/bin/python3"):
        """
        virtualenv.cli_run ã‚’å‘¼ã³å‡ºã—ã¦ä»®æƒ³ç’°å¢ƒã‚’ä½œæˆã—ã€
        ãƒ­ã‚°ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚
        args:
            venv_path( Path ): ä»®æƒ³ç’°å¢ƒã®ãƒ‘ã‚¹
            python_executable( str ): pythonã®ãƒ‘ã‚¹(æ™®é€šã¯æ—¢å®šã®/usr/bin/python3ã®ã¾ã¾ã§è‰¯ã„)
        """
        cmd = [
            "virtualenv",
            "--python", python_executable,
            str(venv_path)
        ]
        logger.info(f"ğŸ”§ Running: {' '.join(cmd)}")
        res = subprocess.run(cmd, capture_output=True, text=True)
        if res.returncode == 0:
            logger.info("âœ… virtualenv created successfully")
            if res.stdout:
                logger.debug(res.stdout)
        else:
            logger.error(f"âŒ virtualenv failed ({res.returncode}):\n{res.stderr}")
            res.check_returncode()

"""## 3. ãƒ†ã‚¹ãƒˆ"""

# @title ToolKit ãƒ†ã‚¹ãƒˆ
if __name__ == "__main__":
    toolkit = ToolKit()
    toolkit.executor_sync( cmd = "pip --version", shell = True )