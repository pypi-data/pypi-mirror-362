from __future__ import annotations

import json
from dataclasses import dataclass
from dataclasses import field
from typing import Any
from typing import Literal
from typing import Self
from typing import cast


# Primitive type loaders
def load_str(value: object) -> str:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    return value


def load_int(value: object) -> int:
    if not isinstance(value, int):
        raise ValueError(f"Expected an integer, got {type(value).__name__}")
    return value


def load_float(value: object) -> float:
    if not isinstance(value, (int, float)):
        raise ValueError(f"Expected a number, got {type(value).__name__}")
    return float(value)


def load_bool(value: object) -> bool:
    if not isinstance(value, bool):
        raise ValueError(f"Expected a boolean, got {type(value).__name__}")
    return value


def load_any(value: object) -> Any:
    return value


# Collection type loaders
def load_enum_LowerSet_LowerClosure_LowerSet_Unused(value: object) -> Literal["LowerSet_LowerClosure", "LowerSet_Unused"]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = ["LowerSet_LowerClosure", "LowerSet_Unused"]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_enum_ModelRequirement_NodeFunctionality(value: object) -> Literal["ModelRequirement", "NodeFunctionality"]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = ["ModelRequirement", "NodeFunctionality"]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_list_of_MonotoneMap(value: object) -> list[MonotoneMap]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_MonotoneMap(item) for item in value]


def load_list_of_LMap(value: object) -> list[LMap]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_LMap(item) for item in value]


def load_list_of_UMap(value: object) -> list[UMap]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_UMap(item) for item in value]


def load_list_of_Unit(value: object) -> list[Unit]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_Unit(item) for item in value]


def load_enum_Unit_None_Unit_Single_Unit_Vector_Unit_Wrapped(
    value: object,
) -> Literal["Unit_None", "Unit_Single", "Unit_Vector", "Unit_Wrapped"]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = ["Unit_None", "Unit_Single", "Unit_Vector", "Unit_Wrapped"]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_enum_f8_f16_f32_f64_f80_f128(value: object) -> Literal["f8", "f16", "f32", "f64", "f80", "f128"]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = ["f8", "f16", "f32", "f64", "f80", "f128"]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_list_of_U1_Explicit_Option(value: object) -> list[U1_Explicit_Option]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_U1_Explicit_Option(item) for item in value]


def load_enum_UpperSet_Unused_UpperSet_UpperClosure(value: object) -> Literal["UpperSet_Unused", "UpperSet_UpperClosure"]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = ["UpperSet_Unused", "UpperSet_UpperClosure"]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_list_of_SUMap(value: object) -> list[SUMap]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_SUMap(item) for item in value]


def load_list_of_SU1Map(value: object) -> list[SU1Map]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_SU1Map(item) for item in value]


def load_dict_of_str_NDPInterface(value: object) -> dict[str, NDPInterface]:
    if not isinstance(value, dict):
        raise ValueError(f"Expected a dict, got {type(value).__name__}")
    value = cast(dict[str, object], value)
    return {k: load_NDPInterface(v) for k, v in value.items()}


def validate_enum_19fd(
    value: object,
) -> Literal["models", "templates", "values", "posets", "primitivedps", "interfaces", "queries"]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = ["models", "templates", "values", "posets", "primitivedps", "interfaces", "queries"]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_list_of_list_of_str(value: object) -> list[list[str]]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_list_of_str(item) for item in value]


def load_list_of_SUCheck_Data(value: object) -> list[SUCheck_Data]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_SUCheck_Data(item) for item in value]


def load_list_of_U1Check_Data(value: object) -> list[U1Check_Data]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_U1Check_Data(item) for item in value]


def validate_enum_5dfe(
    value: object,
) -> Literal[
    "SU1_C_CodSum",
    "SU1_C_CodSumSmash",
    "SU1_C_ExplicitApprox",
    "SU1_C_Intersection",
    "SU1_C_Parallel",
    "SU1_C_ProdIntersection",
    "SU1_C_Product",
    "SU1_C_RefineDomain",
    "SU1_C_Series",
    "SU1_C_Trace",
    "SU1_C_Union",
    "SU1_C_WrapUnits",
    "SU1_Exact",
    "SU1_Identity",
    "SU1_InvMultiply",
    "SU1_InvSum",
    "SU1_Unknown",
]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = [
        "SU1_C_CodSum",
        "SU1_C_CodSumSmash",
        "SU1_C_ExplicitApprox",
        "SU1_C_Intersection",
        "SU1_C_Parallel",
        "SU1_C_ProdIntersection",
        "SU1_C_Product",
        "SU1_C_RefineDomain",
        "SU1_C_Series",
        "SU1_C_Trace",
        "SU1_C_Union",
        "SU1_C_WrapUnits",
        "SU1_Exact",
        "SU1_Identity",
        "SU1_InvMultiply",
        "SU1_InvSum",
        "SU1_Unknown",
    ]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_enum_ModelFunctionality_NodeRequirement(value: object) -> Literal["ModelFunctionality", "NodeRequirement"]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = ["ModelFunctionality", "NodeRequirement"]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_list_of_Poset(value: object) -> list[Poset]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_Poset(item) for item in value]


def load_enum_i8_i16_i32_i64_i128(value: object) -> Literal["i8", "i16", "i32", "i64", "i128"]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = ["i8", "i16", "i32", "i64", "i128"]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def validate_enum_4f69(
    value: object,
) -> Literal[
    "SU_C_ITransform",
    "SU_C_Intersection",
    "SU_C_Parallel",
    "SU_C_RefineDomain",
    "SU_C_Series",
    "SU_C_Trace",
    "SU_C_Union",
    "SU_C_WrapUnits",
    "SU_Identity",
    "SU_L_Exact",
    "SU_L_Explicit_Approx",
    "SU_L_Lift1_Constant",
    "SU_L_Lift1_Transform",
    "SU_Unknown",
]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = [
        "SU_C_ITransform",
        "SU_C_Intersection",
        "SU_C_Parallel",
        "SU_C_RefineDomain",
        "SU_C_Series",
        "SU_C_Trace",
        "SU_C_Union",
        "SU_C_WrapUnits",
        "SU_Identity",
        "SU_L_Exact",
        "SU_L_Explicit_Approx",
        "SU_L_Lift1_Constant",
        "SU_L_Lift1_Transform",
        "SU_Unknown",
    ]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_list_of_U1Map(value: object) -> list[U1Map]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_U1Map(item) for item in value]


def validate_enum_477e(
    value: object,
) -> Literal[
    "U_C_ITransform",
    "U_C_Intersection",
    "U_C_Parallel",
    "U_C_RefineDomain",
    "U_C_Series",
    "U_C_Trace",
    "U_C_Union",
    "U_C_WrapUnits",
    "U_Catalog",
    "U_Constant",
    "U_Identity",
    "U_L_Lift1_Constant",
    "U_L_Lift1_Transform",
    "U_Unknown",
]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = [
        "U_C_ITransform",
        "U_C_Intersection",
        "U_C_Parallel",
        "U_C_RefineDomain",
        "U_C_Series",
        "U_C_Trace",
        "U_C_Union",
        "U_C_WrapUnits",
        "U_Catalog",
        "U_Constant",
        "U_Identity",
        "U_L_Lift1_Constant",
        "U_L_Lift1_Transform",
        "U_Unknown",
    ]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def validate_enum_4eeb(
    value: object,
) -> Literal[
    "SL_C_ITransform",
    "SL_C_Intersection",
    "SL_C_Parallel",
    "SL_C_RefineDomain",
    "SL_C_Series",
    "SL_C_Trace",
    "SL_C_Union",
    "SL_C_WrapUnits",
    "SL_Identity",
    "SL_L_Exact",
    "SL_L_Explicit_Approx",
    "SL_L_Lift1_Constant",
    "SL_L_Lift1_Transform",
    "SL_Unknown",
]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = [
        "SL_C_ITransform",
        "SL_C_Intersection",
        "SL_C_Parallel",
        "SL_C_RefineDomain",
        "SL_C_Series",
        "SL_C_Trace",
        "SL_C_Union",
        "SL_C_WrapUnits",
        "SL_Identity",
        "SL_L_Exact",
        "SL_L_Explicit_Approx",
        "SL_L_Lift1_Constant",
        "SL_L_Lift1_Transform",
        "SL_Unknown",
    ]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_enum_NDP_Composite_NDP_Simple_NDP_Sum_NDP_TemplateHole(
    value: object,
) -> Literal["NDP_Composite", "NDP_Simple", "NDP_Sum", "NDP_TemplateHole"]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = ["NDP_Composite", "NDP_Simple", "NDP_Sum", "NDP_TemplateHole"]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def validate_enum_a898(
    value: object,
) -> Literal[
    "U1_C_CodSum",
    "U1_C_CodSumSmash",
    "U1_C_DomUnion",
    "U1_C_Intersection",
    "U1_C_Parallel",
    "U1_C_ProdIntersection",
    "U1_C_Product",
    "U1_C_RefineDomain",
    "U1_C_Series",
    "U1_C_Trace",
    "U1_C_Union",
    "U1_C_WrapUnits",
    "U1_Catalog",
    "U1_Constant",
    "U1_Entire",
    "U1_Explicit",
    "U1_FromFilter",
    "U1_Identity",
    "U1_IntersectionOfPrinUpperSets",
    "U1_InvMul_Opt",
    "U1_InvMul_Pes",
    "U1_InvSum_Opt",
    "U1_InvSum_Pes",
    "U1_L_Uinv",
    "U1_Lift",
    "U1_RepresentPrincipalUpperSet",
    "U1_Uinv_Join",
    "U1_Uinv_JoinConstant",
    "U1_UnionOfPrinUpperSets",
    "U1_Unknown",
]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = [
        "U1_C_CodSum",
        "U1_C_CodSumSmash",
        "U1_C_DomUnion",
        "U1_C_Intersection",
        "U1_C_Parallel",
        "U1_C_ProdIntersection",
        "U1_C_Product",
        "U1_C_RefineDomain",
        "U1_C_Series",
        "U1_C_Trace",
        "U1_C_Union",
        "U1_C_WrapUnits",
        "U1_Catalog",
        "U1_Constant",
        "U1_Entire",
        "U1_Explicit",
        "U1_FromFilter",
        "U1_Identity",
        "U1_IntersectionOfPrinUpperSets",
        "U1_InvMul_Opt",
        "U1_InvMul_Pes",
        "U1_InvSum_Opt",
        "U1_InvSum_Pes",
        "U1_L_Uinv",
        "U1_Lift",
        "U1_RepresentPrincipalUpperSet",
        "U1_Uinv_Join",
        "U1_Uinv_JoinConstant",
        "U1_UnionOfPrinUpperSets",
        "U1_Unknown",
    ]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def validate_enum_b0de(
    value: object,
) -> Literal[
    "DP_All_Constants_And_F_Leq_R",
    "DP_All_Constants_Leq_R",
    "DP_All_Fi_Leq_R",
    "DP_AmbientConversion",
    "DP_Any_Constants_Or_F_Leq_R",
    "DP_Any_Fi_Leq_R",
    "DP_C_ExplicitApprox",
    "DP_C_Intersection",
    "DP_C_Parallel",
    "DP_C_Series",
    "DP_C_Trace",
    "DP_C_Union",
    "DP_Catalog",
    "DP_Compiled",
    "DP_F_Leq_All_Constants",
    "DP_F_Leq_All_R_And_Constants",
    "DP_F_Leq_All_Ri",
    "DP_F_Leq_Any_R_And_Constants",
    "DP_F_Leq_Any_Ri",
    "DP_False",
    "DP_FuncNotMoreThan",
    "DP_GenericConstant",
    "DP_Identity",
    "DP_Iso",
    "DP_LiftL",
    "DP_LiftU",
    "DP_ResNotLessThan",
    "DP_True",
    "DP_Unknown",
]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = [
        "DP_All_Constants_And_F_Leq_R",
        "DP_All_Constants_Leq_R",
        "DP_All_Fi_Leq_R",
        "DP_AmbientConversion",
        "DP_Any_Constants_Or_F_Leq_R",
        "DP_Any_Fi_Leq_R",
        "DP_C_ExplicitApprox",
        "DP_C_Intersection",
        "DP_C_Parallel",
        "DP_C_Series",
        "DP_C_Trace",
        "DP_C_Union",
        "DP_Catalog",
        "DP_Compiled",
        "DP_F_Leq_All_Constants",
        "DP_F_Leq_All_R_And_Constants",
        "DP_F_Leq_All_Ri",
        "DP_F_Leq_Any_R_And_Constants",
        "DP_F_Leq_Any_Ri",
        "DP_False",
        "DP_FuncNotMoreThan",
        "DP_GenericConstant",
        "DP_Identity",
        "DP_Iso",
        "DP_LiftL",
        "DP_LiftU",
        "DP_ResNotLessThan",
        "DP_True",
        "DP_Unknown",
    ]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_list_of_L1Check_Data(value: object) -> list[L1Check_Data]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_L1Check_Data(item) for item in value]


def load_list_of_UCheck_Data(value: object) -> list[UCheck_Data]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_UCheck_Data(item) for item in value]


def load_list_of_U1_Catalog_Options(value: object) -> list[U1_Catalog_Options]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_U1_Catalog_Options(item) for item in value]


def load_list_of_Connection(value: object) -> list[Connection]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_Connection(item) for item in value]


def load_enum_QueryFixFunMinReqData_QueryFixReqMaxFunData(
    value: object,
) -> Literal["QueryFixFunMinReqData", "QueryFixReqMaxFunData"]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = ["QueryFixFunMinReqData", "QueryFixReqMaxFunData"]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_dict_of_str_list_of_str(value: object) -> dict[str, list[str]]:
    if not isinstance(value, dict):
        raise ValueError(f"Expected a dict, got {type(value).__name__}")
    value = cast(dict[str, object], value)
    return {k: load_list_of_str(v) for k, v in value.items()}


def load_list_of_Range(value: object) -> list[Range]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_Range(item) for item in value]


def load_list_of_MapCheck_Data(value: object) -> list[MapCheck_Data]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_MapCheck_Data(item) for item in value]


def load_list_of_SL1Map(value: object) -> list[SL1Map]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_SL1Map(item) for item in value]


def load_list_of_M_Explicit_Option(value: object) -> list[M_Explicit_Option]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_M_Explicit_Option(item) for item in value]


def validate_enum_1978(
    value: object,
) -> Literal["L1Check", "LCheck", "MapCheck", "SL1Check", "SLCheck", "SU1Check", "SUCheck", "U1Check", "UCheck"]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = ["L1Check", "LCheck", "MapCheck", "SL1Check", "SLCheck", "SU1Check", "SUCheck", "U1Check", "UCheck"]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_list_of_any(value: object) -> list[Any]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_any(item) for item in value]


def load_list_of_L_Catalog_Options(value: object) -> list[L_Catalog_Options]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_L_Catalog_Options(item) for item in value]


def load_list_of_L1Map(value: object) -> list[L1Map]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_L1Map(item) for item in value]


def load_list_of_DP(value: object) -> list[DP]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_DP(item) for item in value]


def load_list_of_L1_Catalog_Options(value: object) -> list[L1_Catalog_Options]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_L1_Catalog_Options(item) for item in value]


def load_list_of_list_of_any(value: object) -> list[list[Any]]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_list_of_any(item) for item in value]


def validate_enum_29e4(
    value: object,
) -> Literal[
    "Check",
    "DP",
    "L1Map",
    "LMap",
    "MonotoneMap",
    "NDP",
    "NDPInterface",
    "NDPTemplate",
    "Poset",
    "Query",
    "SL1Map",
    "SLMap",
    "SU1Map",
    "SUMap",
    "U1Map",
    "UMap",
    "Value",
]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = [
        "Check",
        "DP",
        "L1Map",
        "LMap",
        "MonotoneMap",
        "NDP",
        "NDPInterface",
        "NDPTemplate",
        "Poset",
        "Query",
        "SL1Map",
        "SLMap",
        "SU1Map",
        "SUMap",
        "U1Map",
        "UMap",
        "Value",
    ]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def validate_enum_5d65(
    value: object,
) -> Literal[
    "SL1_C_CodSum",
    "SL1_C_CodSumSmash",
    "SL1_C_ExplicitApprox",
    "SL1_C_Intersection",
    "SL1_C_Parallel",
    "SL1_C_ProdIntersection",
    "SL1_C_Product",
    "SL1_C_RefineDomain",
    "SL1_C_Series",
    "SL1_C_Trace",
    "SL1_C_Union",
    "SL1_C_WrapUnits",
    "SL1_Exact",
    "SL1_Identity",
    "SL1_InvMultiply",
    "SL1_InvSum",
    "SL1_Unknown",
]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = [
        "SL1_C_CodSum",
        "SL1_C_CodSumSmash",
        "SL1_C_ExplicitApprox",
        "SL1_C_Intersection",
        "SL1_C_Parallel",
        "SL1_C_ProdIntersection",
        "SL1_C_Product",
        "SL1_C_RefineDomain",
        "SL1_C_Series",
        "SL1_C_Trace",
        "SL1_C_Union",
        "SL1_C_WrapUnits",
        "SL1_Exact",
        "SL1_Identity",
        "SL1_InvMultiply",
        "SL1_InvSum",
        "SL1_Unknown",
    ]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_list_of_bool(value: object) -> list[bool]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_bool(item) for item in value]


def load_list_of_SLMap(value: object) -> list[SLMap]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_SLMap(item) for item in value]


def validate_enum_a17d(
    value: object,
) -> Literal[
    "L1_C_CodSum",
    "L1_C_CodSumSmash",
    "L1_C_DomUnion",
    "L1_C_Intersection",
    "L1_C_Parallel",
    "L1_C_ProdIntersection",
    "L1_C_Product",
    "L1_C_RefineDomain",
    "L1_C_Series",
    "L1_C_Trace",
    "L1_C_Union",
    "L1_C_WrapUnits",
    "L1_Catalog",
    "L1_Constant",
    "L1_Entire",
    "L1_Explicit",
    "L1_FromFilter",
    "L1_Identity",
    "L1_IntersectionOfPrinLowerSets",
    "L1_InvMul_Opt",
    "L1_InvMul_Pes",
    "L1_InvSum_Opt",
    "L1_InvSum_Pes",
    "L1_L_Linv",
    "L1_Lift",
    "L1_RepresentPrincipalLowerSet",
    "L1_TopAlternating",
    "L1_UnionOfPrinLowerSets",
    "L1_Unknown",
]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = [
        "L1_C_CodSum",
        "L1_C_CodSumSmash",
        "L1_C_DomUnion",
        "L1_C_Intersection",
        "L1_C_Parallel",
        "L1_C_ProdIntersection",
        "L1_C_Product",
        "L1_C_RefineDomain",
        "L1_C_Series",
        "L1_C_Trace",
        "L1_C_Union",
        "L1_C_WrapUnits",
        "L1_Catalog",
        "L1_Constant",
        "L1_Entire",
        "L1_Explicit",
        "L1_FromFilter",
        "L1_Identity",
        "L1_IntersectionOfPrinLowerSets",
        "L1_InvMul_Opt",
        "L1_InvMul_Pes",
        "L1_InvSum_Opt",
        "L1_InvSum_Pes",
        "L1_L_Linv",
        "L1_Lift",
        "L1_RepresentPrincipalLowerSet",
        "L1_TopAlternating",
        "L1_UnionOfPrinLowerSets",
        "L1_Unknown",
    ]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def validate_enum_8a74(
    value: object,
) -> Literal[
    "P_Bool",
    "P_C_Arrow",
    "P_C_Discretized",
    "P_C_Lexicographic",
    "P_C_LowerSets",
    "P_C_Multisets",
    "P_C_Opposite",
    "P_C_Power",
    "P_C_Product",
    "P_C_ProductDS",
    "P_C_ProductSmash",
    "P_C_Sum",
    "P_C_SumSmash",
    "P_C_Twisted",
    "P_C_Units",
    "P_C_UpperSets",
    "P_Decimal",
    "P_F_Bounded",
    "P_F_C_Intersection",
    "P_F_C_Union",
    "P_F_Interval",
    "P_F_LowerClosure",
    "P_F_Subposet",
    "P_F_UpperClosure",
    "P_Finite",
    "P_Float",
    "P_Fractions",
    "P_Integer",
    "P_Unknown",
]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = [
        "P_Bool",
        "P_C_Arrow",
        "P_C_Discretized",
        "P_C_Lexicographic",
        "P_C_LowerSets",
        "P_C_Multisets",
        "P_C_Opposite",
        "P_C_Power",
        "P_C_Product",
        "P_C_ProductDS",
        "P_C_ProductSmash",
        "P_C_Sum",
        "P_C_SumSmash",
        "P_C_Twisted",
        "P_C_Units",
        "P_C_UpperSets",
        "P_Decimal",
        "P_F_Bounded",
        "P_F_C_Intersection",
        "P_F_C_Union",
        "P_F_Interval",
        "P_F_LowerClosure",
        "P_F_Subposet",
        "P_F_UpperClosure",
        "P_Finite",
        "P_Float",
        "P_Fractions",
        "P_Integer",
        "P_Unknown",
    ]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_list_of_SU1Check_Data(value: object) -> list[SU1Check_Data]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_SU1Check_Data(item) for item in value]


def load_list_of_str(value: object) -> list[str]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_str(item) for item in value]


def load_list_of_SL1Check_Data(value: object) -> list[SL1Check_Data]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_SL1Check_Data(item) for item in value]


def load_list_of_U_Catalog_Options(value: object) -> list[U_Catalog_Options]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_U_Catalog_Options(item) for item in value]


def load_list_of_L1_Explicit_Option(value: object) -> list[L1_Explicit_Option]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_L1_Explicit_Option(item) for item in value]


def load_dict_of_str_Poset(value: object) -> dict[str, Poset]:
    if not isinstance(value, dict):
        raise ValueError(f"Expected a dict, got {type(value).__name__}")
    value = cast(dict[str, object], value)
    return {k: load_Poset(v) for k, v in value.items()}


def validate_enum_17f66(
    value: object,
) -> Literal[
    "M_AddL",
    "M_AddLConstant",
    "M_AddU",
    "M_AddUConstant",
    "M_BottomIfNotTop",
    "M_C_Coproduct",
    "M_C_CoproductSmash",
    "M_C_DomProdCodSmash",
    "M_C_DomSmashCodProd",
    "M_C_DomUnion",
    "M_C_Leq_X",
    "M_C_LiftToSubsets",
    "M_C_Lt_X",
    "M_C_Op",
    "M_C_Parallel",
    "M_C_ParallelSmash",
    "M_C_Product",
    "M_C_ProductSmash",
    "M_C_RefineDomain",
    "M_C_Series",
    "M_C_Sum",
    "M_C_SumSmash",
    "M_C_WrapUnits",
    "M_Ceil0",
    "M_Coerce",
    "M_Constant",
    "M_ContainedInLowerSet",
    "M_ContainedInUpperSet",
    "M_DivideLConstant",
    "M_DivideUConstant",
    "M_Empty",
    "M_Explicit",
    "M_Floor0",
    "M_Id",
    "M_IdentityBelowThreshold",
    "M_Injection",
    "M_Join",
    "M_JoinConstant",
    "M_Leq",
    "M_Lift",
    "M_LiftToLowerSets",
    "M_LiftToUpperSets",
    "M_Meet",
    "M_MeetConstant",
    "M_MultiplyL",
    "M_MultiplyLConstant",
    "M_MultiplyU",
    "M_MultiplyUConstant",
    "M_PowerFracL",
    "M_PowerFracU",
    "M_ReprLowerSet",
    "M_ReprUpperSet",
    "M_RepresentPrincipalLowerSet_TotalOrderBounded",
    "M_RepresentPrincipalUpperSet_TotalOrderBounded",
    "M_RoundDown",
    "M_RoundUp",
    "M_ScaleL",
    "M_ScaleU",
    "M_SmashInjection",
    "M_SubLConstant",
    "M_SubUConstant",
    "M_TakeIndex",
    "M_TakeRange",
    "M_Threshold1",
    "M_Threshold2",
    "M_TopIfNotBottom",
    "M_Undefined",
    "M_Unknown",
    "M_Unlift",
    "M_X_Leq_C",
    "M_X_Lt_C",
]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = [
        "M_AddL",
        "M_AddLConstant",
        "M_AddU",
        "M_AddUConstant",
        "M_BottomIfNotTop",
        "M_C_Coproduct",
        "M_C_CoproductSmash",
        "M_C_DomProdCodSmash",
        "M_C_DomSmashCodProd",
        "M_C_DomUnion",
        "M_C_Leq_X",
        "M_C_LiftToSubsets",
        "M_C_Lt_X",
        "M_C_Op",
        "M_C_Parallel",
        "M_C_ParallelSmash",
        "M_C_Product",
        "M_C_ProductSmash",
        "M_C_RefineDomain",
        "M_C_Series",
        "M_C_Sum",
        "M_C_SumSmash",
        "M_C_WrapUnits",
        "M_Ceil0",
        "M_Coerce",
        "M_Constant",
        "M_ContainedInLowerSet",
        "M_ContainedInUpperSet",
        "M_DivideLConstant",
        "M_DivideUConstant",
        "M_Empty",
        "M_Explicit",
        "M_Floor0",
        "M_Id",
        "M_IdentityBelowThreshold",
        "M_Injection",
        "M_Join",
        "M_JoinConstant",
        "M_Leq",
        "M_Lift",
        "M_LiftToLowerSets",
        "M_LiftToUpperSets",
        "M_Meet",
        "M_MeetConstant",
        "M_MultiplyL",
        "M_MultiplyLConstant",
        "M_MultiplyU",
        "M_MultiplyUConstant",
        "M_PowerFracL",
        "M_PowerFracU",
        "M_ReprLowerSet",
        "M_ReprUpperSet",
        "M_RepresentPrincipalLowerSet_TotalOrderBounded",
        "M_RepresentPrincipalUpperSet_TotalOrderBounded",
        "M_RoundDown",
        "M_RoundUp",
        "M_ScaleL",
        "M_ScaleU",
        "M_SmashInjection",
        "M_SubLConstant",
        "M_SubUConstant",
        "M_TakeIndex",
        "M_TakeRange",
        "M_Threshold1",
        "M_Threshold2",
        "M_TopIfNotBottom",
        "M_Undefined",
        "M_Unknown",
        "M_Unlift",
        "M_X_Leq_C",
        "M_X_Lt_C",
    ]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_list_of_SLCheck_Data(value: object) -> list[SLCheck_Data]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_SLCheck_Data(item) for item in value]


def load_list_of_LCheck_Data(value: object) -> list[LCheck_Data]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_LCheck_Data(item) for item in value]


def validate_enum_4700(
    value: object,
) -> Literal[
    "L_C_ITransform",
    "L_C_Intersection",
    "L_C_Parallel",
    "L_C_RefineDomain",
    "L_C_Series",
    "L_C_Trace",
    "L_C_Union",
    "L_C_WrapUnits",
    "L_Catalog",
    "L_Constant",
    "L_Identity",
    "L_L_Lift1_Constant",
    "L_L_Lift1_Transform",
    "L_Unknown",
]:
    if not isinstance(value, str):
        raise ValueError(f"Expected a string, got {type(value).__name__}")
    allowed_values = [
        "L_C_ITransform",
        "L_C_Intersection",
        "L_C_Parallel",
        "L_C_RefineDomain",
        "L_C_Series",
        "L_C_Trace",
        "L_C_Union",
        "L_C_WrapUnits",
        "L_Catalog",
        "L_Constant",
        "L_Identity",
        "L_L_Lift1_Constant",
        "L_L_Lift1_Transform",
        "L_Unknown",
    ]
    if value not in allowed_values:
        raise ValueError(f"Expected one of {allowed_values}, got {value}")
    return value  # type: ignore


def load_dict_of_str_Value(value: object) -> dict[str, Value]:
    if not isinstance(value, dict):
        raise ValueError(f"Expected a dict, got {type(value).__name__}")
    value = cast(dict[str, object], value)
    return {k: load_Value(v) for k, v in value.items()}


def load_dict_of_str_NDP(value: object) -> dict[str, NDP]:
    if not isinstance(value, dict):
        raise ValueError(f"Expected a dict, got {type(value).__name__}")
    value = cast(dict[str, object], value)
    return {k: load_NDP(v) for k, v in value.items()}


def load_list_of_DP_Catalog_Options(value: object) -> list[DP_Catalog_Options]:
    if not isinstance(value, list):
        raise ValueError(f"Expected a list, got {type(value).__name__}")
    value = cast(list[object], value)
    return [load_DP_Catalog_Options(item) for item in value]


# Schema loaders
def load_Address(data: object) -> "Address":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "library" in data:
        field_library = load_str(data["library"])
    else:
        raise ValueError("Missing required field 'library'")

    if "repo" in data:
        value = data["repo"]
        if value is None:
            field_repo = None
        else:
            field_repo = load_str(value)
    else:
        field_repo = None

    if "spec" in data:
        field_spec = validate_enum_19fd(data["spec"])
    else:
        raise ValueError("Missing required field 'spec'")

    if "thing" in data:
        field_thing = load_str(data["thing"])
    else:
        raise ValueError("Missing required field 'thing'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "Address":
            raise ValueError(f"Expected 'Address', got {field_type_}'")
    else:
        raise ValueError("Missing required field 'type'")

    return Address(
        library=field_library,
        repo=field_repo,
        spec=field_spec,
        thing=field_thing,
        type_=field_type_,
    )


def load_Root(data: object) -> "Root":
    """Load Root from a dictionary based on the 'kind' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("kind")
    mapping = {
        "Check": load_Check,
        "DP": load_DP,
        "L1Map": load_L1Map,
        "LMap": load_LMap,
        "MonotoneMap": load_MonotoneMap,
        "NDP": load_NDP,
        "NDPInterface": load_NDPInterface,
        "NDPTemplate": load_NDPTemplate,
        "Poset": load_Poset,
        "Query": load_Query,
        "SL1Map": load_SL1Map,
        "SLMap": load_SLMap,
        "SU1Map": load_SU1Map,
        "SUMap": load_SUMap,
        "U1Map": load_U1Map,
        "UMap": load_UMap,
        "Value": load_Value,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for Root")


def load_Check(data: object) -> "Check":
    """Load Check from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "L1Check": load_L1Check,
        "LCheck": load_LCheck,
        "MapCheck": load_MapCheck,
        "SL1Check": load_SL1Check,
        "SLCheck": load_SLCheck,
        "SU1Check": load_SU1Check,
        "SUCheck": load_SUCheck,
        "U1Check": load_U1Check,
        "UCheck": load_UCheck,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for Check")


def load_Connection(data: object) -> "Connection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "source" in data:
        field_source = load_ConnectionSource(data["source"])
    else:
        raise ValueError("Missing required field 'source'")

    if "target" in data:
        field_target = load_ConnectionTarget(data["target"])
    else:
        raise ValueError("Missing required field 'target'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "Connection":
            raise ValueError(f"Expected 'Connection', got {field_type_}'")
    else:
        raise ValueError("Missing required field 'type'")

    return Connection(
        source=field_source,
        target=field_target,
        type_=field_type_,
    )


def load_ConnectionSource(data: object) -> "ConnectionSource":
    """Load ConnectionSource from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "ModelFunctionality": load_ModelFunctionality,
        "NodeRequirement": load_NodeRequirement,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for ConnectionSource")


def load_ConnectionTarget(data: object) -> "ConnectionTarget":
    """Load ConnectionTarget from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "ModelRequirement": load_ModelRequirement,
        "NodeFunctionality": load_NodeFunctionality,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for ConnectionTarget")


def load_DP(data: object) -> "DP":
    """Load DP from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "DP_All_Constants_And_F_Leq_R": load_DP_All_Constants_And_F_Leq_R,
        "DP_All_Constants_Leq_R": load_DP_All_Constants_Leq_R,
        "DP_All_Fi_Leq_R": load_DP_All_Fi_Leq_R,
        "DP_AmbientConversion": load_DP_AmbientConversion,
        "DP_Any_Constants_Or_F_Leq_R": load_DP_Any_Constants_Or_F_Leq_R,
        "DP_Any_Fi_Leq_R": load_DP_Any_Fi_Leq_R,
        "DP_C_ExplicitApprox": load_DP_C_ExplicitApprox,
        "DP_C_Intersection": load_DP_C_Intersection,
        "DP_C_Parallel": load_DP_C_Parallel,
        "DP_C_Series": load_DP_C_Series,
        "DP_C_Trace": load_DP_C_Trace,
        "DP_C_Union": load_DP_C_Union,
        "DP_Catalog": load_DP_Catalog,
        "DP_Compiled": load_DP_Compiled,
        "DP_F_Leq_All_Constants": load_DP_F_Leq_All_Constants,
        "DP_F_Leq_All_R_And_Constants": load_DP_F_Leq_All_R_And_Constants,
        "DP_F_Leq_All_Ri": load_DP_F_Leq_All_Ri,
        "DP_F_Leq_Any_R_And_Constants": load_DP_F_Leq_Any_R_And_Constants,
        "DP_F_Leq_Any_Ri": load_DP_F_Leq_Any_Ri,
        "DP_False": load_DP_False,
        "DP_FuncNotMoreThan": load_DP_FuncNotMoreThan,
        "DP_GenericConstant": load_DP_GenericConstant,
        "DP_Identity": load_DP_Identity,
        "DP_Iso": load_DP_Iso,
        "DP_LiftL": load_DP_LiftL,
        "DP_LiftU": load_DP_LiftU,
        "DP_ResNotLessThan": load_DP_ResNotLessThan,
        "DP_True": load_DP_True,
        "DP_Unknown": load_DP_Unknown,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for DP")


def load_DP_All_Constants_And_F_Leq_R(data: object) -> "DP_All_Constants_And_F_Leq_R":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_All_Constants_And_F_Leq_R":
            raise ValueError(f"Expected 'DP_All_Constants_And_F_Leq_R', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_All_Constants_And_F_Leq_R":
            raise ValueError(
                f"Invalid discriminator value for 'type': expected 'DP_All_Constants_And_F_Leq_R', got {field_type_}"
            )
    else:
        field_type_ = json.loads('"DP_All_Constants_And_F_Leq_R"')

    if "constants" in data:
        field_constants = load_list_of_any(data["constants"])
    else:
        raise ValueError("Missing required field 'constants'")

    return DP_All_Constants_And_F_Leq_R(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        constants=field_constants,
    )


def load_DP_All_Constants_Leq_R(data: object) -> "DP_All_Constants_Leq_R":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_All_Constants_Leq_R":
            raise ValueError(f"Expected 'DP_All_Constants_Leq_R', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_All_Constants_Leq_R":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_All_Constants_Leq_R', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_All_Constants_Leq_R"')

    if "constants" in data:
        field_constants = load_list_of_any(data["constants"])
    else:
        raise ValueError("Missing required field 'constants'")

    return DP_All_Constants_Leq_R(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        constants=field_constants,
    )


def load_DP_All_Fi_Leq_R(data: object) -> "DP_All_Fi_Leq_R":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_All_Fi_Leq_R":
            raise ValueError(f"Expected 'DP_All_Fi_Leq_R', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_All_Fi_Leq_R":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_All_Fi_Leq_R', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_All_Fi_Leq_R"')

    return DP_All_Fi_Leq_R(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
    )


def load_DP_AmbientConversion(data: object) -> "DP_AmbientConversion":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_AmbientConversion":
            raise ValueError(f"Expected 'DP_AmbientConversion', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_AmbientConversion":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_AmbientConversion', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_AmbientConversion"')

    if "common" in data:
        field_common = load_Poset(data["common"])
    else:
        raise ValueError("Missing required field 'common'")

    return DP_AmbientConversion(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        common=field_common,
    )


def load_DP_Any_Constants_Or_F_Leq_R(data: object) -> "DP_Any_Constants_Or_F_Leq_R":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_Any_Constants_Or_F_Leq_R":
            raise ValueError(f"Expected 'DP_Any_Constants_Or_F_Leq_R', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_Any_Constants_Or_F_Leq_R":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_Any_Constants_Or_F_Leq_R', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_Any_Constants_Or_F_Leq_R"')

    if "constants" in data:
        field_constants = load_list_of_any(data["constants"])
    else:
        raise ValueError("Missing required field 'constants'")

    return DP_Any_Constants_Or_F_Leq_R(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        constants=field_constants,
    )


def load_DP_Any_Fi_Leq_R(data: object) -> "DP_Any_Fi_Leq_R":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_Any_Fi_Leq_R":
            raise ValueError(f"Expected 'DP_Any_Fi_Leq_R', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_Any_Fi_Leq_R":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_Any_Fi_Leq_R', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_Any_Fi_Leq_R"')

    return DP_Any_Fi_Leq_R(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
    )


def load_DP_C_ExplicitApprox(data: object) -> "DP_C_ExplicitApprox":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_C_ExplicitApprox":
            raise ValueError(f"Expected 'DP_C_ExplicitApprox', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_C_ExplicitApprox":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_C_ExplicitApprox', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_C_ExplicitApprox"')

    if "optimistic" in data:
        field_optimistic = load_list_of_DP(data["optimistic"])
    else:
        raise ValueError("Missing required field 'optimistic'")

    if "optimistic_labels" in data:
        value = data["optimistic_labels"]
        if value is None:
            field_optimistic_labels = None
        else:
            field_optimistic_labels = load_list_of_str(value)
    else:
        field_optimistic_labels = None

    if "pessimistic" in data:
        field_pessimistic = load_list_of_DP(data["pessimistic"])
    else:
        raise ValueError("Missing required field 'pessimistic'")

    if "pessimistic_labels" in data:
        value = data["pessimistic_labels"]
        if value is None:
            field_pessimistic_labels = None
        else:
            field_pessimistic_labels = load_list_of_str(value)
    else:
        field_pessimistic_labels = None

    return DP_C_ExplicitApprox(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        optimistic=field_optimistic,
        optimistic_labels=field_optimistic_labels,
        pessimistic=field_pessimistic,
        pessimistic_labels=field_pessimistic_labels,
    )


def load_DP_C_Intersection(data: object) -> "DP_C_Intersection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_C_Intersection":
            raise ValueError(f"Expected 'DP_C_Intersection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_C_Intersection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_C_Intersection', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_C_Intersection"')

    if "dps" in data:
        field_dps = load_list_of_DP(data["dps"])
    else:
        raise ValueError("Missing required field 'dps'")

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    return DP_C_Intersection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        dps=field_dps,
        labels=field_labels,
    )


def load_DP_C_Parallel(data: object) -> "DP_C_Parallel":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_C_Parallel":
            raise ValueError(f"Expected 'DP_C_Parallel', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_C_Parallel":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_C_Parallel', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_C_Parallel"')

    if "dps" in data:
        field_dps = load_list_of_DP(data["dps"])
    else:
        raise ValueError("Missing required field 'dps'")

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    return DP_C_Parallel(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        dps=field_dps,
        labels=field_labels,
    )


def load_DP_C_Series(data: object) -> "DP_C_Series":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_C_Series":
            raise ValueError(f"Expected 'DP_C_Series', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_C_Series":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_C_Series', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_C_Series"')

    if "dps" in data:
        field_dps = load_list_of_DP(data["dps"])
    else:
        raise ValueError("Missing required field 'dps'")

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    return DP_C_Series(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        dps=field_dps,
        labels=field_labels,
    )


def load_DP_C_Trace(data: object) -> "DP_C_Trace":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_C_Trace":
            raise ValueError(f"Expected 'DP_C_Trace', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_C_Trace":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_C_Trace', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_C_Trace"')

    if "dp" in data:
        field_dp = load_DP(data["dp"])
    else:
        raise ValueError("Missing required field 'dp'")

    return DP_C_Trace(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        dp=field_dp,
    )


def load_DP_C_Union(data: object) -> "DP_C_Union":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_C_Union":
            raise ValueError(f"Expected 'DP_C_Union', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_C_Union":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_C_Union', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_C_Union"')

    if "dps" in data:
        field_dps = load_list_of_DP(data["dps"])
    else:
        raise ValueError("Missing required field 'dps'")

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    return DP_C_Union(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        dps=field_dps,
        labels=field_labels,
    )


def load_DP_Catalog(data: object) -> "DP_Catalog":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_Catalog":
            raise ValueError(f"Expected 'DP_Catalog', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_Catalog":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_Catalog', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_Catalog"')

    if "options" in data:
        field_options = load_list_of_DP_Catalog_Options(data["options"])
    else:
        raise ValueError("Missing required field 'options'")

    return DP_Catalog(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        options=field_options,
    )


def load_DP_Catalog_Options(data: object) -> "DP_Catalog_Options":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "b" in data:
        field_b = load_any(data["b"])
    else:
        raise ValueError("Missing required field 'b'")

    if "f" in data:
        field_f = load_any(data["f"])
    else:
        raise ValueError("Missing required field 'f'")

    if "i" in data:
        field_i = load_any(data["i"])
    else:
        raise ValueError("Missing required field 'i'")

    if "r" in data:
        field_r = load_any(data["r"])
    else:
        raise ValueError("Missing required field 'r'")

    return DP_Catalog_Options(
        b=field_b,
        f=field_f,
        i=field_i,
        r=field_r,
    )


def load_DP_Compiled(data: object) -> "DP_Compiled":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_Compiled":
            raise ValueError(f"Expected 'DP_Compiled', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_Compiled":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_Compiled', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_Compiled"')

    if "f_b_r" in data:
        field_f_b_r = load_SUMap(data["f_b_r"])
    else:
        raise ValueError("Missing required field 'f_b_r'")

    if "f_i_r" in data:
        field_f_i_r = load_SUMap(data["f_i_r"])
    else:
        raise ValueError("Missing required field 'f_i_r'")

    if "f_r" in data:
        field_f_r = load_SU1Map(data["f_r"])
    else:
        raise ValueError("Missing required field 'f_r'")

    if "i_availability" in data:
        field_i_availability = load_MonotoneMap(data["i_availability"])
    else:
        raise ValueError("Missing required field 'i_availability'")

    if "i_b" in data:
        field_i_b = load_MonotoneMap(data["i_b"])
    else:
        raise ValueError("Missing required field 'i_b'")

    if "i_codfeas" in data:
        field_i_codfeas = load_MonotoneMap(data["i_codfeas"])
    else:
        raise ValueError("Missing required field 'i_codfeas'")

    if "prov" in data:
        field_prov = load_MonotoneMap(data["prov"])
    else:
        raise ValueError("Missing required field 'prov'")

    if "r_b_f" in data:
        field_r_b_f = load_SLMap(data["r_b_f"])
    else:
        raise ValueError("Missing required field 'r_b_f'")

    if "r_f" in data:
        field_r_f = load_SL1Map(data["r_f"])
    else:
        raise ValueError("Missing required field 'r_f'")

    if "r_i_f" in data:
        field_r_i_f = load_SLMap(data["r_i_f"])
    else:
        raise ValueError("Missing required field 'r_i_f'")

    if "req" in data:
        field_req = load_MonotoneMap(data["req"])
    else:
        raise ValueError("Missing required field 'req'")

    return DP_Compiled(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        f_b_r=field_f_b_r,
        f_i_r=field_f_i_r,
        f_r=field_f_r,
        i_availability=field_i_availability,
        i_b=field_i_b,
        i_codfeas=field_i_codfeas,
        prov=field_prov,
        r_b_f=field_r_b_f,
        r_f=field_r_f,
        r_i_f=field_r_i_f,
        req=field_req,
    )


def load_DP_F_Leq_All_Constants(data: object) -> "DP_F_Leq_All_Constants":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_F_Leq_All_Constants":
            raise ValueError(f"Expected 'DP_F_Leq_All_Constants', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_F_Leq_All_Constants":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_F_Leq_All_Constants', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_F_Leq_All_Constants"')

    if "constants" in data:
        field_constants = load_list_of_any(data["constants"])
    else:
        raise ValueError("Missing required field 'constants'")

    return DP_F_Leq_All_Constants(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        constants=field_constants,
    )


def load_DP_F_Leq_All_R_And_Constants(data: object) -> "DP_F_Leq_All_R_And_Constants":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_F_Leq_All_R_And_Constants":
            raise ValueError(f"Expected 'DP_F_Leq_All_R_And_Constants', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_F_Leq_All_R_And_Constants":
            raise ValueError(
                f"Invalid discriminator value for 'type': expected 'DP_F_Leq_All_R_And_Constants', got {field_type_}"
            )
    else:
        field_type_ = json.loads('"DP_F_Leq_All_R_And_Constants"')

    if "constants" in data:
        field_constants = load_list_of_any(data["constants"])
    else:
        raise ValueError("Missing required field 'constants'")

    return DP_F_Leq_All_R_And_Constants(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        constants=field_constants,
    )


def load_DP_F_Leq_All_Ri(data: object) -> "DP_F_Leq_All_Ri":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_F_Leq_All_Ri":
            raise ValueError(f"Expected 'DP_F_Leq_All_Ri', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_F_Leq_All_Ri":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_F_Leq_All_Ri', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_F_Leq_All_Ri"')

    return DP_F_Leq_All_Ri(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
    )


def load_DP_F_Leq_Any_R_And_Constants(data: object) -> "DP_F_Leq_Any_R_And_Constants":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_F_Leq_Any_R_And_Constants":
            raise ValueError(f"Expected 'DP_F_Leq_Any_R_And_Constants', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_F_Leq_Any_R_And_Constants":
            raise ValueError(
                f"Invalid discriminator value for 'type': expected 'DP_F_Leq_Any_R_And_Constants', got {field_type_}"
            )
    else:
        field_type_ = json.loads('"DP_F_Leq_Any_R_And_Constants"')

    if "constants" in data:
        field_constants = load_list_of_any(data["constants"])
    else:
        raise ValueError("Missing required field 'constants'")

    return DP_F_Leq_Any_R_And_Constants(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        constants=field_constants,
    )


def load_DP_F_Leq_Any_Ri(data: object) -> "DP_F_Leq_Any_Ri":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_F_Leq_Any_Ri":
            raise ValueError(f"Expected 'DP_F_Leq_Any_Ri', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_F_Leq_Any_Ri":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_F_Leq_Any_Ri', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_F_Leq_Any_Ri"')

    return DP_F_Leq_Any_Ri(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
    )


def load_DP_False(data: object) -> "DP_False":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_False":
            raise ValueError(f"Expected 'DP_False', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_False":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_False', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_False"')

    return DP_False(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
    )


def load_DP_FuncNotMoreThan(data: object) -> "DP_FuncNotMoreThan":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_FuncNotMoreThan":
            raise ValueError(f"Expected 'DP_FuncNotMoreThan', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_FuncNotMoreThan":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_FuncNotMoreThan', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_FuncNotMoreThan"')

    if "limit" in data:
        field_limit = load_any(data["limit"])
    else:
        raise ValueError("Missing required field 'limit'")

    return DP_FuncNotMoreThan(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        limit=field_limit,
    )


def load_DP_GenericConstant(data: object) -> "DP_GenericConstant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_GenericConstant":
            raise ValueError(f"Expected 'DP_GenericConstant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_GenericConstant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_GenericConstant', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_GenericConstant"')

    if "b_value" in data:
        field_b_value = load_any(data["b_value"])
    else:
        raise ValueError("Missing required field 'b_value'")

    if "lower_set" in data:
        field_lower_set = load_LowerSet(data["lower_set"])
    else:
        raise ValueError("Missing required field 'lower_set'")

    if "upper_set" in data:
        field_upper_set = load_UpperSet(data["upper_set"])
    else:
        raise ValueError("Missing required field 'upper_set'")

    return DP_GenericConstant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        b_value=field_b_value,
        lower_set=field_lower_set,
        upper_set=field_upper_set,
    )


def load_DP_Identity(data: object) -> "DP_Identity":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_Identity":
            raise ValueError(f"Expected 'DP_Identity', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_Identity":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_Identity', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_Identity"')

    return DP_Identity(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
    )


def load_DP_Iso(data: object) -> "DP_Iso":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_Iso":
            raise ValueError(f"Expected 'DP_Iso', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_Iso":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_Iso', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_Iso"')

    if "bwd" in data:
        field_bwd = load_MonotoneMap(data["bwd"])
    else:
        raise ValueError("Missing required field 'bwd'")

    if "fwd" in data:
        field_fwd = load_MonotoneMap(data["fwd"])
    else:
        raise ValueError("Missing required field 'fwd'")

    return DP_Iso(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        bwd=field_bwd,
        fwd=field_fwd,
    )


def load_DP_LiftL(data: object) -> "DP_LiftL":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_LiftL":
            raise ValueError(f"Expected 'DP_LiftL', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_LiftL":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_LiftL', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_LiftL"')

    if "m" in data:
        field_m = load_MonotoneMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return DP_LiftL(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        m=field_m,
    )


def load_DP_LiftU(data: object) -> "DP_LiftU":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_LiftU":
            raise ValueError(f"Expected 'DP_LiftU', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_LiftU":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_LiftU', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_LiftU"')

    if "m" in data:
        field_m = load_MonotoneMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return DP_LiftU(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        m=field_m,
    )


def load_DP_ResNotLessThan(data: object) -> "DP_ResNotLessThan":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_ResNotLessThan":
            raise ValueError(f"Expected 'DP_ResNotLessThan', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_ResNotLessThan":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_ResNotLessThan', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_ResNotLessThan"')

    if "limit" in data:
        field_limit = load_any(data["limit"])
    else:
        raise ValueError("Missing required field 'limit'")

    return DP_ResNotLessThan(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        limit=field_limit,
    )


def load_DP_True(data: object) -> "DP_True":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_True":
            raise ValueError(f"Expected 'DP_True', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_True":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_True', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_True"')

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return DP_True(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
        value=field_value,
    )


def load_DP_Unknown(data: object) -> "DP_Unknown":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "DP":
            raise ValueError(f"Expected 'DP', got {field_kind}'")
        if field_kind is not None and field_kind != "DP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'DP', got {field_kind}")
    else:
        field_kind = json.loads('"DP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "B" in data:
        value = data["B"]
        if value is None:
            field_B = None
        else:
            field_B = load_Poset(value)
    else:
        field_B = None

    if "F" in data:
        field_F = load_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "I" in data:
        value = data["I"]
        if value is None:
            field_I = None
        else:
            field_I = load_Poset(value)
    else:
        field_I = None

    if "R" in data:
        field_R = load_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "DP_Unknown":
            raise ValueError(f"Expected 'DP_Unknown', got {field_type_}'")
        if field_type_ is not None and field_type_ != "DP_Unknown":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'DP_Unknown', got {field_type_}")
    else:
        field_type_ = json.loads('"DP_Unknown"')

    return DP_Unknown(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        B=field_B,
        F=field_F,
        I=field_I,
        R=field_R,
        address=field_address,
        type_=field_type_,
    )


def load_L1Check(data: object) -> "L1Check":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Check":
            raise ValueError(f"Expected 'Check', got {field_kind}'")
        if field_kind is not None and field_kind != "Check":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Check', got {field_kind}")
    else:
        field_kind = json.loads('"Check"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1Check":
            raise ValueError(f"Expected 'L1Check', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1Check":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1Check', got {field_type_}")
    else:
        field_type_ = json.loads('"L1Check"')

    if "data" in data:
        field_data = load_list_of_L1Check_Data(data["data"])
    else:
        raise ValueError("Missing required field 'data'")

    if "m" in data:
        field_m = load_L1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return L1Check(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        type_=field_type_,
        data=field_data,
        m=field_m,
    )


def load_L1Check_Data(data: object) -> "L1Check_Data":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "elapsed" in data:
        value = data["elapsed"]
        if value is None:
            field_elapsed = None
        else:
            field_elapsed = load_float(value)
    else:
        field_elapsed = None

    if "x" in data:
        field_x = load_any(data["x"])
    else:
        raise ValueError("Missing required field 'x'")

    if "y" in data:
        field_y = load_LowerSet(data["y"])
    else:
        raise ValueError("Missing required field 'y'")

    return L1Check_Data(
        elapsed=field_elapsed,
        x=field_x,
        y=field_y,
    )


def load_L1Map(data: object) -> "L1Map":
    """Load L1Map from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "L1_C_CodSum": load_L1_C_CodSum,
        "L1_C_CodSumSmash": load_L1_C_CodSumSmash,
        "L1_C_DomUnion": load_L1_C_DomUnion,
        "L1_C_Intersection": load_L1_C_Intersection,
        "L1_C_Parallel": load_L1_C_Parallel,
        "L1_C_ProdIntersection": load_L1_C_ProdIntersection,
        "L1_C_Product": load_L1_C_Product,
        "L1_C_RefineDomain": load_L1_C_RefineDomain,
        "L1_C_Series": load_L1_C_Series,
        "L1_C_Trace": load_L1_C_Trace,
        "L1_C_Union": load_L1_C_Union,
        "L1_C_WrapUnits": load_L1_C_WrapUnits,
        "L1_Catalog": load_L1_Catalog,
        "L1_Constant": load_L1_Constant,
        "L1_Entire": load_L1_Entire,
        "L1_Explicit": load_L1_Explicit,
        "L1_FromFilter": load_L1_FromFilter,
        "L1_Identity": load_L1_Identity,
        "L1_IntersectionOfPrinLowerSets": load_L1_IntersectionOfPrinLowerSets,
        "L1_InvMul_Opt": load_L1_InvMul_Opt,
        "L1_InvMul_Pes": load_L1_InvMul_Pes,
        "L1_InvSum_Opt": load_L1_InvSum_Opt,
        "L1_InvSum_Pes": load_L1_InvSum_Pes,
        "L1_L_Linv": load_L1_L_Linv,
        "L1_Lift": load_L1_Lift,
        "L1_RepresentPrincipalLowerSet": load_L1_RepresentPrincipalLowerSet,
        "L1_TopAlternating": load_L1_TopAlternating,
        "L1_UnionOfPrinLowerSets": load_L1_UnionOfPrinLowerSets,
        "L1_Unknown": load_L1_Unknown,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for L1Map")


def load_L1_C_CodSum(data: object) -> "L1_C_CodSum":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_C_CodSum":
            raise ValueError(f"Expected 'L1_C_CodSum', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_C_CodSum":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_C_CodSum', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_C_CodSum"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_L1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return L1_C_CodSum(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_L1_C_CodSumSmash(data: object) -> "L1_C_CodSumSmash":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_C_CodSumSmash":
            raise ValueError(f"Expected 'L1_C_CodSumSmash', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_C_CodSumSmash":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_C_CodSumSmash', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_C_CodSumSmash"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_L1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return L1_C_CodSumSmash(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_L1_C_DomUnion(data: object) -> "L1_C_DomUnion":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_C_DomUnion":
            raise ValueError(f"Expected 'L1_C_DomUnion', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_C_DomUnion":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_C_DomUnion', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_C_DomUnion"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_L1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return L1_C_DomUnion(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_L1_C_Intersection(data: object) -> "L1_C_Intersection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_C_Intersection":
            raise ValueError(f"Expected 'L1_C_Intersection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_C_Intersection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_C_Intersection', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_C_Intersection"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_L1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return L1_C_Intersection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_L1_C_Parallel(data: object) -> "L1_C_Parallel":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_C_Parallel":
            raise ValueError(f"Expected 'L1_C_Parallel', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_C_Parallel":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_C_Parallel', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_C_Parallel"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_L1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return L1_C_Parallel(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_L1_C_ProdIntersection(data: object) -> "L1_C_ProdIntersection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_C_ProdIntersection":
            raise ValueError(f"Expected 'L1_C_ProdIntersection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_C_ProdIntersection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_C_ProdIntersection', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_C_ProdIntersection"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_L1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return L1_C_ProdIntersection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_L1_C_Product(data: object) -> "L1_C_Product":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_C_Product":
            raise ValueError(f"Expected 'L1_C_Product', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_C_Product":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_C_Product', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_C_Product"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_L1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return L1_C_Product(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_L1_C_RefineDomain(data: object) -> "L1_C_RefineDomain":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_C_RefineDomain":
            raise ValueError(f"Expected 'L1_C_RefineDomain', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_C_RefineDomain":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_C_RefineDomain', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_C_RefineDomain"')

    if "m" in data:
        field_m = load_L1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return L1_C_RefineDomain(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        m=field_m,
    )


def load_L1_C_Series(data: object) -> "L1_C_Series":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_C_Series":
            raise ValueError(f"Expected 'L1_C_Series', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_C_Series":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_C_Series', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_C_Series"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_L1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return L1_C_Series(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_L1_C_Trace(data: object) -> "L1_C_Trace":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_C_Trace":
            raise ValueError(f"Expected 'L1_C_Trace', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_C_Trace":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_C_Trace', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_C_Trace"')

    if "m" in data:
        field_m = load_L1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return L1_C_Trace(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        m=field_m,
    )


def load_L1_C_Union(data: object) -> "L1_C_Union":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_C_Union":
            raise ValueError(f"Expected 'L1_C_Union', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_C_Union":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_C_Union', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_C_Union"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_L1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return L1_C_Union(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_L1_C_WrapUnits(data: object) -> "L1_C_WrapUnits":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_C_WrapUnits":
            raise ValueError(f"Expected 'L1_C_WrapUnits', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_C_WrapUnits":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_C_WrapUnits', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_C_WrapUnits"')

    if "kcod_units" in data:
        field_kcod_units = load_Unit(data["kcod_units"])
    else:
        raise ValueError("Missing required field 'kcod_units'")

    if "kdom_units" in data:
        field_kdom_units = load_Unit(data["kdom_units"])
    else:
        raise ValueError("Missing required field 'kdom_units'")

    if "m" in data:
        field_m = load_L1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return L1_C_WrapUnits(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        kcod_units=field_kcod_units,
        kdom_units=field_kdom_units,
        m=field_m,
    )


def load_L1_Catalog(data: object) -> "L1_Catalog":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_Catalog":
            raise ValueError(f"Expected 'L1_Catalog', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_Catalog":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_Catalog', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_Catalog"')

    if "options" in data:
        field_options = load_list_of_L1_Catalog_Options(data["options"])
    else:
        raise ValueError("Missing required field 'options'")

    return L1_Catalog(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        options=field_options,
    )


def load_L1_Catalog_Options(data: object) -> "L1_Catalog_Options":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "f" in data:
        field_f = load_any(data["f"])
    else:
        raise ValueError("Missing required field 'f'")

    if "r" in data:
        field_r = load_any(data["r"])
    else:
        raise ValueError("Missing required field 'r'")

    return L1_Catalog_Options(
        f=field_f,
        r=field_r,
    )


def load_L1_Constant(data: object) -> "L1_Constant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_Constant":
            raise ValueError(f"Expected 'L1_Constant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_Constant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_Constant', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_Constant"')

    if "value" in data:
        field_value = load_LowerSet(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return L1_Constant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        value=field_value,
    )


def load_L1_Entire(data: object) -> "L1_Entire":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_Entire":
            raise ValueError(f"Expected 'L1_Entire', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_Entire":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_Entire', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_Entire"')

    return L1_Entire(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
    )


def load_L1_Explicit(data: object) -> "L1_Explicit":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_Explicit":
            raise ValueError(f"Expected 'L1_Explicit', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_Explicit":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_Explicit', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_Explicit"')

    if "options" in data:
        field_options = load_list_of_L1_Explicit_Option(data["options"])
    else:
        raise ValueError("Missing required field 'options'")

    return L1_Explicit(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        options=field_options,
    )


def load_L1_Explicit_Option(data: object) -> "L1_Explicit_Option":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "x" in data:
        field_x = load_any(data["x"])
    else:
        raise ValueError("Missing required field 'x'")

    if "y" in data:
        field_y = load_LowerSet(data["y"])
    else:
        raise ValueError("Missing required field 'y'")

    return L1_Explicit_Option(
        x=field_x,
        y=field_y,
    )


def load_L1_FromFilter(data: object) -> "L1_FromFilter":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_FromFilter":
            raise ValueError(f"Expected 'L1_FromFilter', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_FromFilter":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_FromFilter', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_FromFilter"')

    if "m" in data:
        field_m = load_MonotoneMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return L1_FromFilter(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        m=field_m,
    )


def load_L1_Identity(data: object) -> "L1_Identity":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_Identity":
            raise ValueError(f"Expected 'L1_Identity', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_Identity":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_Identity', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_Identity"')

    return L1_Identity(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
    )


def load_L1_IntersectionOfPrinLowerSets(data: object) -> "L1_IntersectionOfPrinLowerSets":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_IntersectionOfPrinLowerSets":
            raise ValueError(f"Expected 'L1_IntersectionOfPrinLowerSets', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_IntersectionOfPrinLowerSets":
            raise ValueError(
                f"Invalid discriminator value for 'type': expected 'L1_IntersectionOfPrinLowerSets', got {field_type_}"
            )
    else:
        field_type_ = json.loads('"L1_IntersectionOfPrinLowerSets"')

    return L1_IntersectionOfPrinLowerSets(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
    )


def load_L1_InvMul_Opt(data: object) -> "L1_InvMul_Opt":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_InvMul_Opt":
            raise ValueError(f"Expected 'L1_InvMul_Opt', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_InvMul_Opt":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_InvMul_Opt', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_InvMul_Opt"')

    if "n" in data:
        field_n = load_int(data["n"])
    else:
        raise ValueError("Missing required field 'n'")

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return L1_InvMul_Opt(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        n=field_n,
        opspace=field_opspace,
    )


def load_L1_InvMul_Pes(data: object) -> "L1_InvMul_Pes":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_InvMul_Pes":
            raise ValueError(f"Expected 'L1_InvMul_Pes', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_InvMul_Pes":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_InvMul_Pes', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_InvMul_Pes"')

    if "n" in data:
        field_n = load_int(data["n"])
    else:
        raise ValueError("Missing required field 'n'")

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return L1_InvMul_Pes(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        n=field_n,
        opspace=field_opspace,
    )


def load_L1_InvSum_Opt(data: object) -> "L1_InvSum_Opt":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_InvSum_Opt":
            raise ValueError(f"Expected 'L1_InvSum_Opt', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_InvSum_Opt":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_InvSum_Opt', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_InvSum_Opt"')

    if "n" in data:
        field_n = load_int(data["n"])
    else:
        raise ValueError("Missing required field 'n'")

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return L1_InvSum_Opt(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        n=field_n,
        opspace=field_opspace,
    )


def load_L1_InvSum_Pes(data: object) -> "L1_InvSum_Pes":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_InvSum_Pes":
            raise ValueError(f"Expected 'L1_InvSum_Pes', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_InvSum_Pes":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_InvSum_Pes', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_InvSum_Pes"')

    if "n" in data:
        field_n = load_int(data["n"])
    else:
        raise ValueError("Missing required field 'n'")

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return L1_InvSum_Pes(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        n=field_n,
        opspace=field_opspace,
    )


def load_L1_L_Linv(data: object) -> "L1_L_Linv":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_L_Linv":
            raise ValueError(f"Expected 'L1_L_Linv', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_L_Linv":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_L_Linv', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_L_Linv"')

    if "m" in data:
        field_m = load_MonotoneMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return L1_L_Linv(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        m=field_m,
    )


def load_L1_Lift(data: object) -> "L1_Lift":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_Lift":
            raise ValueError(f"Expected 'L1_Lift', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_Lift":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_Lift', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_Lift"')

    if "m" in data:
        field_m = load_MonotoneMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return L1_Lift(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        m=field_m,
    )


def load_L1_RepresentPrincipalLowerSet(data: object) -> "L1_RepresentPrincipalLowerSet":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_RepresentPrincipalLowerSet":
            raise ValueError(f"Expected 'L1_RepresentPrincipalLowerSet', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_RepresentPrincipalLowerSet":
            raise ValueError(
                f"Invalid discriminator value for 'type': expected 'L1_RepresentPrincipalLowerSet', got {field_type_}"
            )
    else:
        field_type_ = json.loads('"L1_RepresentPrincipalLowerSet"')

    return L1_RepresentPrincipalLowerSet(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
    )


def load_L1_TopAlternating(data: object) -> "L1_TopAlternating":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_TopAlternating":
            raise ValueError(f"Expected 'L1_TopAlternating', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_TopAlternating":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_TopAlternating', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_TopAlternating"')

    if "upper_bounds" in data:
        field_upper_bounds = load_list_of_list_of_any(data["upper_bounds"])
    else:
        raise ValueError("Missing required field 'upper_bounds'")

    return L1_TopAlternating(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        upper_bounds=field_upper_bounds,
    )


def load_L1_UnionOfPrinLowerSets(data: object) -> "L1_UnionOfPrinLowerSets":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_UnionOfPrinLowerSets":
            raise ValueError(f"Expected 'L1_UnionOfPrinLowerSets', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_UnionOfPrinLowerSets":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_UnionOfPrinLowerSets', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_UnionOfPrinLowerSets"')

    return L1_UnionOfPrinLowerSets(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
    )


def load_L1_Unknown(data: object) -> "L1_Unknown":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "L1Map":
            raise ValueError(f"Expected 'L1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "L1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'L1Map', got {field_kind}")
    else:
        field_kind = json.loads('"L1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L1_Unknown":
            raise ValueError(f"Expected 'L1_Unknown', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L1_Unknown":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L1_Unknown', got {field_type_}")
    else:
        field_type_ = json.loads('"L1_Unknown"')

    return L1_Unknown(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
    )


def load_LCheck(data: object) -> "LCheck":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Check":
            raise ValueError(f"Expected 'Check', got {field_kind}'")
        if field_kind is not None and field_kind != "Check":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Check', got {field_kind}")
    else:
        field_kind = json.loads('"Check"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "LCheck":
            raise ValueError(f"Expected 'LCheck', got {field_type_}'")
        if field_type_ is not None and field_type_ != "LCheck":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'LCheck', got {field_type_}")
    else:
        field_type_ = json.loads('"LCheck"')

    if "data" in data:
        field_data = load_list_of_LCheck_Data(data["data"])
    else:
        raise ValueError("Missing required field 'data'")

    if "m" in data:
        field_m = load_LMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return LCheck(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        type_=field_type_,
        data=field_data,
        m=field_m,
    )


def load_LCheck_Data(data: object) -> "LCheck_Data":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "elapsed" in data:
        value = data["elapsed"]
        if value is None:
            field_elapsed = None
        else:
            field_elapsed = load_float(value)
    else:
        field_elapsed = None

    if "x" in data:
        field_x = load_any(data["x"])
    else:
        raise ValueError("Missing required field 'x'")

    if "y" in data:
        field_y = load_LowerSet(data["y"])
    else:
        raise ValueError("Missing required field 'y'")

    return LCheck_Data(
        elapsed=field_elapsed,
        x=field_x,
        y=field_y,
    )


def load_LMap(data: object) -> "LMap":
    """Load LMap from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "L_C_ITransform": load_L_C_ITransform,
        "L_C_Intersection": load_L_C_Intersection,
        "L_C_Parallel": load_L_C_Parallel,
        "L_C_RefineDomain": load_L_C_RefineDomain,
        "L_C_Series": load_L_C_Series,
        "L_C_Trace": load_L_C_Trace,
        "L_C_Union": load_L_C_Union,
        "L_C_WrapUnits": load_L_C_WrapUnits,
        "L_Catalog": load_L_Catalog,
        "L_Constant": load_L_Constant,
        "L_Identity": load_L_Identity,
        "L_L_Lift1_Constant": load_L_L_Lift1_Constant,
        "L_L_Lift1_Transform": load_L_L_Lift1_Transform,
        "L_Unknown": load_L_Unknown,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for LMap")


def load_L_C_ITransform(data: object) -> "L_C_ITransform":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LMap":
            raise ValueError(f"Expected 'LMap', got {field_kind}'")
        if field_kind is not None and field_kind != "LMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'LMap', got {field_kind}")
    else:
        field_kind = json.loads('"LMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L_C_ITransform":
            raise ValueError(f"Expected 'L_C_ITransform', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L_C_ITransform":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L_C_ITransform', got {field_type_}")
    else:
        field_type_ = json.loads('"L_C_ITransform"')

    if "m" in data:
        field_m = load_LMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "transform" in data:
        field_transform = load_MonotoneMap(data["transform"])
    else:
        raise ValueError("Missing required field 'transform'")

    return L_C_ITransform(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        m=field_m,
        transform=field_transform,
    )


def load_L_C_Intersection(data: object) -> "L_C_Intersection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LMap":
            raise ValueError(f"Expected 'LMap', got {field_kind}'")
        if field_kind is not None and field_kind != "LMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'LMap', got {field_kind}")
    else:
        field_kind = json.loads('"LMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L_C_Intersection":
            raise ValueError(f"Expected 'L_C_Intersection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L_C_Intersection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L_C_Intersection', got {field_type_}")
    else:
        field_type_ = json.loads('"L_C_Intersection"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_LMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return L_C_Intersection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_L_C_Parallel(data: object) -> "L_C_Parallel":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LMap":
            raise ValueError(f"Expected 'LMap', got {field_kind}'")
        if field_kind is not None and field_kind != "LMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'LMap', got {field_kind}")
    else:
        field_kind = json.loads('"LMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L_C_Parallel":
            raise ValueError(f"Expected 'L_C_Parallel', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L_C_Parallel":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L_C_Parallel', got {field_type_}")
    else:
        field_type_ = json.loads('"L_C_Parallel"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_LMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return L_C_Parallel(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_L_C_RefineDomain(data: object) -> "L_C_RefineDomain":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LMap":
            raise ValueError(f"Expected 'LMap', got {field_kind}'")
        if field_kind is not None and field_kind != "LMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'LMap', got {field_kind}")
    else:
        field_kind = json.loads('"LMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L_C_RefineDomain":
            raise ValueError(f"Expected 'L_C_RefineDomain', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L_C_RefineDomain":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L_C_RefineDomain', got {field_type_}")
    else:
        field_type_ = json.loads('"L_C_RefineDomain"')

    if "m" in data:
        field_m = load_LMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return L_C_RefineDomain(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        m=field_m,
    )


def load_L_C_Series(data: object) -> "L_C_Series":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LMap":
            raise ValueError(f"Expected 'LMap', got {field_kind}'")
        if field_kind is not None and field_kind != "LMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'LMap', got {field_kind}")
    else:
        field_kind = json.loads('"LMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L_C_Series":
            raise ValueError(f"Expected 'L_C_Series', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L_C_Series":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L_C_Series', got {field_type_}")
    else:
        field_type_ = json.loads('"L_C_Series"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_LMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return L_C_Series(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_L_C_Trace(data: object) -> "L_C_Trace":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LMap":
            raise ValueError(f"Expected 'LMap', got {field_kind}'")
        if field_kind is not None and field_kind != "LMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'LMap', got {field_kind}")
    else:
        field_kind = json.loads('"LMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L_C_Trace":
            raise ValueError(f"Expected 'L_C_Trace', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L_C_Trace":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L_C_Trace', got {field_type_}")
    else:
        field_type_ = json.loads('"L_C_Trace"')

    if "m" in data:
        field_m = load_LMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "m_proj" in data:
        field_m_proj = load_L1Map(data["m_proj"])
    else:
        raise ValueError("Missing required field 'm_proj'")

    return L_C_Trace(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        m=field_m,
        m_proj=field_m_proj,
    )


def load_L_C_Union(data: object) -> "L_C_Union":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LMap":
            raise ValueError(f"Expected 'LMap', got {field_kind}'")
        if field_kind is not None and field_kind != "LMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'LMap', got {field_kind}")
    else:
        field_kind = json.loads('"LMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L_C_Union":
            raise ValueError(f"Expected 'L_C_Union', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L_C_Union":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L_C_Union', got {field_type_}")
    else:
        field_type_ = json.loads('"L_C_Union"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_LMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return L_C_Union(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_L_C_WrapUnits(data: object) -> "L_C_WrapUnits":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LMap":
            raise ValueError(f"Expected 'LMap', got {field_kind}'")
        if field_kind is not None and field_kind != "LMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'LMap', got {field_kind}")
    else:
        field_kind = json.loads('"LMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L_C_WrapUnits":
            raise ValueError(f"Expected 'L_C_WrapUnits', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L_C_WrapUnits":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L_C_WrapUnits', got {field_type_}")
    else:
        field_type_ = json.loads('"L_C_WrapUnits"')

    if "kcod_units" in data:
        field_kcod_units = load_Unit(data["kcod_units"])
    else:
        raise ValueError("Missing required field 'kcod_units'")

    if "kdom_units" in data:
        field_kdom_units = load_Unit(data["kdom_units"])
    else:
        raise ValueError("Missing required field 'kdom_units'")

    if "kimp_units" in data:
        field_kimp_units = load_Unit(data["kimp_units"])
    else:
        raise ValueError("Missing required field 'kimp_units'")

    if "m" in data:
        field_m = load_LMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return L_C_WrapUnits(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        kcod_units=field_kcod_units,
        kdom_units=field_kdom_units,
        kimp_units=field_kimp_units,
        m=field_m,
    )


def load_L_Catalog(data: object) -> "L_Catalog":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LMap":
            raise ValueError(f"Expected 'LMap', got {field_kind}'")
        if field_kind is not None and field_kind != "LMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'LMap', got {field_kind}")
    else:
        field_kind = json.loads('"LMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L_Catalog":
            raise ValueError(f"Expected 'L_Catalog', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L_Catalog":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L_Catalog', got {field_type_}")
    else:
        field_type_ = json.loads('"L_Catalog"')

    if "options" in data:
        field_options = load_list_of_L_Catalog_Options(data["options"])
    else:
        raise ValueError("Missing required field 'options'")

    return L_Catalog(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        options=field_options,
    )


def load_L_Catalog_Options(data: object) -> "L_Catalog_Options":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "f" in data:
        field_f = load_any(data["f"])
    else:
        raise ValueError("Missing required field 'f'")

    if "i" in data:
        field_i = load_any(data["i"])
    else:
        raise ValueError("Missing required field 'i'")

    if "r" in data:
        field_r = load_any(data["r"])
    else:
        raise ValueError("Missing required field 'r'")

    return L_Catalog_Options(
        f=field_f,
        i=field_i,
        r=field_r,
    )


def load_L_Constant(data: object) -> "L_Constant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LMap":
            raise ValueError(f"Expected 'LMap', got {field_kind}'")
        if field_kind is not None and field_kind != "LMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'LMap', got {field_kind}")
    else:
        field_kind = json.loads('"LMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L_Constant":
            raise ValueError(f"Expected 'L_Constant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L_Constant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L_Constant', got {field_type_}")
    else:
        field_type_ = json.loads('"L_Constant"')

    if "value" in data:
        field_value = load_LowerSet(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return L_Constant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        value=field_value,
    )


def load_L_Identity(data: object) -> "L_Identity":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LMap":
            raise ValueError(f"Expected 'LMap', got {field_kind}'")
        if field_kind is not None and field_kind != "LMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'LMap', got {field_kind}")
    else:
        field_kind = json.loads('"LMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L_Identity":
            raise ValueError(f"Expected 'L_Identity', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L_Identity":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L_Identity', got {field_type_}")
    else:
        field_type_ = json.loads('"L_Identity"')

    return L_Identity(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
    )


def load_L_L_Lift1_Constant(data: object) -> "L_L_Lift1_Constant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LMap":
            raise ValueError(f"Expected 'LMap', got {field_kind}'")
        if field_kind is not None and field_kind != "LMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'LMap', got {field_kind}")
    else:
        field_kind = json.loads('"LMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L_L_Lift1_Constant":
            raise ValueError(f"Expected 'L_L_Lift1_Constant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L_L_Lift1_Constant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L_L_Lift1_Constant', got {field_type_}")
    else:
        field_type_ = json.loads('"L_L_Lift1_Constant"')

    if "m" in data:
        field_m = load_L1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "value" in data:
        field_value = load_any(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return L_L_Lift1_Constant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        m=field_m,
        value=field_value,
    )


def load_L_L_Lift1_Transform(data: object) -> "L_L_Lift1_Transform":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LMap":
            raise ValueError(f"Expected 'LMap', got {field_kind}'")
        if field_kind is not None and field_kind != "LMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'LMap', got {field_kind}")
    else:
        field_kind = json.loads('"LMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L_L_Lift1_Transform":
            raise ValueError(f"Expected 'L_L_Lift1_Transform', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L_L_Lift1_Transform":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L_L_Lift1_Transform', got {field_type_}")
    else:
        field_type_ = json.loads('"L_L_Lift1_Transform"')

    if "m" in data:
        field_m = load_L1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "transform" in data:
        field_transform = load_MonotoneMap(data["transform"])
    else:
        raise ValueError("Missing required field 'transform'")

    return L_L_Lift1_Transform(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        m=field_m,
        transform=field_transform,
    )


def load_L_Unknown(data: object) -> "L_Unknown":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LMap":
            raise ValueError(f"Expected 'LMap', got {field_kind}'")
        if field_kind is not None and field_kind != "LMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'LMap', got {field_kind}")
    else:
        field_kind = json.loads('"LMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "L_Unknown":
            raise ValueError(f"Expected 'L_Unknown', got {field_type_}'")
        if field_type_ is not None and field_type_ != "L_Unknown":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'L_Unknown', got {field_type_}")
    else:
        field_type_ = json.loads('"L_Unknown"')

    return L_Unknown(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
    )


def load_LowerSet(data: object) -> "LowerSet":
    """Load LowerSet from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "LowerSet_LowerClosure": load_LowerSet_LowerClosure,
        "LowerSet_Unused": load_LowerSet_Unused,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for LowerSet")


def load_LowerSet_LowerClosure(data: object) -> "LowerSet_LowerClosure":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LowerSet":
            raise ValueError(f"Expected 'LowerSet', got {field_kind}'")
    else:
        raise ValueError("Missing required field 'kind'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "LowerSet_LowerClosure":
            raise ValueError(f"Expected 'LowerSet_LowerClosure', got {field_type_}'")
        if field_type_ is not None and field_type_ != "LowerSet_LowerClosure":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'LowerSet_LowerClosure', got {field_type_}")
    else:
        field_type_ = json.loads('"LowerSet_LowerClosure"')

    if "points" in data:
        field_points = load_list_of_any(data["points"])
    else:
        raise ValueError("Missing required field 'points'")

    return LowerSet_LowerClosure(
        kind=field_kind,
        type_=field_type_,
        points=field_points,
    )


def load_LowerSet_Unused(data: object) -> "LowerSet_Unused":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "LowerSet":
            raise ValueError(f"Expected 'LowerSet', got {field_kind}'")
    else:
        raise ValueError("Missing required field 'kind'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "LowerSet_Unused":
            raise ValueError(f"Expected 'LowerSet_Unused', got {field_type_}'")
        if field_type_ is not None and field_type_ != "LowerSet_Unused":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'LowerSet_Unused', got {field_type_}")
    else:
        field_type_ = json.loads('"LowerSet_Unused"')

    return LowerSet_Unused(
        kind=field_kind,
        type_=field_type_,
    )


def load_MonotoneMap(data: object) -> "MonotoneMap":
    """Load MonotoneMap from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "M_AddL": load_M_AddL,
        "M_AddLConstant": load_M_AddLConstant,
        "M_AddU": load_M_AddU,
        "M_AddUConstant": load_M_AddUConstant,
        "M_BottomIfNotTop": load_M_BottomIfNotTop,
        "M_C_Coproduct": load_M_C_Coproduct,
        "M_C_CoproductSmash": load_M_C_CoproductSmash,
        "M_C_DomProdCodSmash": load_M_C_DomProdCodSmash,
        "M_C_DomSmashCodProd": load_M_C_DomSmashCodProd,
        "M_C_DomUnion": load_M_C_DomUnion,
        "M_C_Leq_X": load_M_C_Leq_X,
        "M_C_LiftToSubsets": load_M_C_LiftToSubsets,
        "M_C_Lt_X": load_M_C_Lt_X,
        "M_C_Op": load_M_C_Op,
        "M_C_Parallel": load_M_C_Parallel,
        "M_C_ParallelSmash": load_M_C_ParallelSmash,
        "M_C_Product": load_M_C_Product,
        "M_C_ProductSmash": load_M_C_ProductSmash,
        "M_C_RefineDomain": load_M_C_RefineDomain,
        "M_C_Series": load_M_C_Series,
        "M_C_Sum": load_M_C_Sum,
        "M_C_SumSmash": load_M_C_SumSmash,
        "M_C_WrapUnits": load_M_C_WrapUnits,
        "M_Ceil0": load_M_Ceil0,
        "M_Coerce": load_M_Coerce,
        "M_Constant": load_M_Constant,
        "M_ContainedInLowerSet": load_M_ContainedInLowerSet,
        "M_ContainedInUpperSet": load_M_ContainedInUpperSet,
        "M_DivideLConstant": load_M_DivideLConstant,
        "M_DivideUConstant": load_M_DivideUConstant,
        "M_Empty": load_M_Empty,
        "M_Explicit": load_M_Explicit,
        "M_Floor0": load_M_Floor0,
        "M_Id": load_M_Id,
        "M_IdentityBelowThreshold": load_M_IdentityBelowThreshold,
        "M_Injection": load_M_Injection,
        "M_Join": load_M_Join,
        "M_JoinConstant": load_M_JoinConstant,
        "M_Leq": load_M_Leq,
        "M_Lift": load_M_Lift,
        "M_LiftToLowerSets": load_M_LiftToLowerSets,
        "M_LiftToUpperSets": load_M_LiftToUpperSets,
        "M_Meet": load_M_Meet,
        "M_MeetConstant": load_M_MeetConstant,
        "M_MultiplyL": load_M_MultiplyL,
        "M_MultiplyLConstant": load_M_MultiplyLConstant,
        "M_MultiplyU": load_M_MultiplyU,
        "M_MultiplyUConstant": load_M_MultiplyUConstant,
        "M_PowerFracL": load_M_PowerFracL,
        "M_PowerFracU": load_M_PowerFracU,
        "M_ReprLowerSet": load_M_ReprLowerSet,
        "M_ReprUpperSet": load_M_ReprUpperSet,
        "M_RepresentPrincipalLowerSet_TotalOrderBounded": load_M_RepresentPrincipalLowerSet_TotalOrderBounded,
        "M_RepresentPrincipalUpperSet_TotalOrderBounded": load_M_RepresentPrincipalUpperSet_TotalOrderBounded,
        "M_RoundDown": load_M_RoundDown,
        "M_RoundUp": load_M_RoundUp,
        "M_ScaleL": load_M_ScaleL,
        "M_ScaleU": load_M_ScaleU,
        "M_SmashInjection": load_M_SmashInjection,
        "M_SubLConstant": load_M_SubLConstant,
        "M_SubUConstant": load_M_SubUConstant,
        "M_TakeIndex": load_M_TakeIndex,
        "M_TakeRange": load_M_TakeRange,
        "M_Threshold1": load_M_Threshold1,
        "M_Threshold2": load_M_Threshold2,
        "M_TopIfNotBottom": load_M_TopIfNotBottom,
        "M_Undefined": load_M_Undefined,
        "M_Unknown": load_M_Unknown,
        "M_Unlift": load_M_Unlift,
        "M_X_Leq_C": load_M_X_Leq_C,
        "M_X_Lt_C": load_M_X_Lt_C,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for MonotoneMap")


def load_M_AddL(data: object) -> "M_AddL":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_AddL":
            raise ValueError(f"Expected 'M_AddL', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_AddL":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_AddL', got {field_type_}")
    else:
        field_type_ = json.loads('"M_AddL"')

    if "opspaces" in data:
        field_opspaces = load_list_of_Poset(data["opspaces"])
    else:
        raise ValueError("Missing required field 'opspaces'")

    return M_AddL(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspaces=field_opspaces,
    )


def load_M_AddLConstant(data: object) -> "M_AddLConstant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_AddLConstant":
            raise ValueError(f"Expected 'M_AddLConstant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_AddLConstant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_AddLConstant', got {field_type_}")
    else:
        field_type_ = json.loads('"M_AddLConstant"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_AddLConstant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
        value=field_value,
    )


def load_M_AddU(data: object) -> "M_AddU":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_AddU":
            raise ValueError(f"Expected 'M_AddU', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_AddU":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_AddU', got {field_type_}")
    else:
        field_type_ = json.loads('"M_AddU"')

    if "opspaces" in data:
        field_opspaces = load_list_of_Poset(data["opspaces"])
    else:
        raise ValueError("Missing required field 'opspaces'")

    return M_AddU(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspaces=field_opspaces,
    )


def load_M_AddUConstant(data: object) -> "M_AddUConstant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_AddUConstant":
            raise ValueError(f"Expected 'M_AddUConstant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_AddUConstant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_AddUConstant', got {field_type_}")
    else:
        field_type_ = json.loads('"M_AddUConstant"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_AddUConstant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
        value=field_value,
    )


def load_M_BottomIfNotTop(data: object) -> "M_BottomIfNotTop":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_BottomIfNotTop":
            raise ValueError(f"Expected 'M_BottomIfNotTop', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_BottomIfNotTop":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_BottomIfNotTop', got {field_type_}")
    else:
        field_type_ = json.loads('"M_BottomIfNotTop"')

    return M_BottomIfNotTop(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
    )


def load_M_C_Coproduct(data: object) -> "M_C_Coproduct":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_Coproduct":
            raise ValueError(f"Expected 'M_C_Coproduct', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_Coproduct":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_Coproduct', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_Coproduct"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "maps" in data:
        field_maps = load_list_of_MonotoneMap(data["maps"])
    else:
        raise ValueError("Missing required field 'maps'")

    return M_C_Coproduct(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        labels=field_labels,
        maps=field_maps,
    )


def load_M_C_CoproductSmash(data: object) -> "M_C_CoproductSmash":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_CoproductSmash":
            raise ValueError(f"Expected 'M_C_CoproductSmash', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_CoproductSmash":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_CoproductSmash', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_CoproductSmash"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "maps" in data:
        field_maps = load_list_of_MonotoneMap(data["maps"])
    else:
        raise ValueError("Missing required field 'maps'")

    return M_C_CoproductSmash(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        labels=field_labels,
        maps=field_maps,
    )


def load_M_C_DomProdCodSmash(data: object) -> "M_C_DomProdCodSmash":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_DomProdCodSmash":
            raise ValueError(f"Expected 'M_C_DomProdCodSmash', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_DomProdCodSmash":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_DomProdCodSmash', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_DomProdCodSmash"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "maps" in data:
        field_maps = load_list_of_MonotoneMap(data["maps"])
    else:
        raise ValueError("Missing required field 'maps'")

    return M_C_DomProdCodSmash(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        labels=field_labels,
        maps=field_maps,
    )


def load_M_C_DomSmashCodProd(data: object) -> "M_C_DomSmashCodProd":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_DomSmashCodProd":
            raise ValueError(f"Expected 'M_C_DomSmashCodProd', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_DomSmashCodProd":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_DomSmashCodProd', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_DomSmashCodProd"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "maps" in data:
        field_maps = load_list_of_MonotoneMap(data["maps"])
    else:
        raise ValueError("Missing required field 'maps'")

    return M_C_DomSmashCodProd(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        labels=field_labels,
        maps=field_maps,
    )


def load_M_C_DomUnion(data: object) -> "M_C_DomUnion":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_DomUnion":
            raise ValueError(f"Expected 'M_C_DomUnion', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_DomUnion":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_DomUnion', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_DomUnion"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "maps" in data:
        field_maps = load_list_of_MonotoneMap(data["maps"])
    else:
        raise ValueError("Missing required field 'maps'")

    return M_C_DomUnion(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        labels=field_labels,
        maps=field_maps,
    )


def load_M_C_Leq_X(data: object) -> "M_C_Leq_X":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_Leq_X":
            raise ValueError(f"Expected 'M_C_Leq_X', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_Leq_X":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_Leq_X', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_Leq_X"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_C_Leq_X(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
        value=field_value,
    )


def load_M_C_LiftToSubsets(data: object) -> "M_C_LiftToSubsets":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_LiftToSubsets":
            raise ValueError(f"Expected 'M_C_LiftToSubsets', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_LiftToSubsets":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_LiftToSubsets', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_LiftToSubsets"')

    if "m" in data:
        field_m = load_MonotoneMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return M_C_LiftToSubsets(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        m=field_m,
    )


def load_M_C_Lt_X(data: object) -> "M_C_Lt_X":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_Lt_X":
            raise ValueError(f"Expected 'M_C_Lt_X', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_Lt_X":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_Lt_X', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_Lt_X"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_C_Lt_X(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
        value=field_value,
    )


def load_M_C_Op(data: object) -> "M_C_Op":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_Op":
            raise ValueError(f"Expected 'M_C_Op', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_Op":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_Op', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_Op"')

    if "m" in data:
        field_m = load_MonotoneMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return M_C_Op(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        m=field_m,
    )


def load_M_C_Parallel(data: object) -> "M_C_Parallel":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_Parallel":
            raise ValueError(f"Expected 'M_C_Parallel', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_Parallel":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_Parallel', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_Parallel"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "maps" in data:
        field_maps = load_list_of_MonotoneMap(data["maps"])
    else:
        raise ValueError("Missing required field 'maps'")

    return M_C_Parallel(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        labels=field_labels,
        maps=field_maps,
    )


def load_M_C_ParallelSmash(data: object) -> "M_C_ParallelSmash":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_ParallelSmash":
            raise ValueError(f"Expected 'M_C_ParallelSmash', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_ParallelSmash":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_ParallelSmash', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_ParallelSmash"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "maps" in data:
        field_maps = load_list_of_MonotoneMap(data["maps"])
    else:
        raise ValueError("Missing required field 'maps'")

    return M_C_ParallelSmash(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        labels=field_labels,
        maps=field_maps,
    )


def load_M_C_Product(data: object) -> "M_C_Product":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_Product":
            raise ValueError(f"Expected 'M_C_Product', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_Product":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_Product', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_Product"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "maps" in data:
        field_maps = load_list_of_MonotoneMap(data["maps"])
    else:
        raise ValueError("Missing required field 'maps'")

    return M_C_Product(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        labels=field_labels,
        maps=field_maps,
    )


def load_M_C_ProductSmash(data: object) -> "M_C_ProductSmash":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_ProductSmash":
            raise ValueError(f"Expected 'M_C_ProductSmash', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_ProductSmash":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_ProductSmash', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_ProductSmash"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "maps" in data:
        field_maps = load_list_of_MonotoneMap(data["maps"])
    else:
        raise ValueError("Missing required field 'maps'")

    return M_C_ProductSmash(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        labels=field_labels,
        maps=field_maps,
    )


def load_M_C_RefineDomain(data: object) -> "M_C_RefineDomain":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_RefineDomain":
            raise ValueError(f"Expected 'M_C_RefineDomain', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_RefineDomain":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_RefineDomain', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_RefineDomain"')

    if "m" in data:
        field_m = load_MonotoneMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return M_C_RefineDomain(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        m=field_m,
    )


def load_M_C_Series(data: object) -> "M_C_Series":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_Series":
            raise ValueError(f"Expected 'M_C_Series', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_Series":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_Series', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_Series"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "maps" in data:
        field_maps = load_list_of_MonotoneMap(data["maps"])
    else:
        raise ValueError("Missing required field 'maps'")

    return M_C_Series(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        labels=field_labels,
        maps=field_maps,
    )


def load_M_C_Sum(data: object) -> "M_C_Sum":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_Sum":
            raise ValueError(f"Expected 'M_C_Sum', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_Sum":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_Sum', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_Sum"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "maps" in data:
        field_maps = load_list_of_MonotoneMap(data["maps"])
    else:
        raise ValueError("Missing required field 'maps'")

    return M_C_Sum(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        labels=field_labels,
        maps=field_maps,
    )


def load_M_C_SumSmash(data: object) -> "M_C_SumSmash":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_SumSmash":
            raise ValueError(f"Expected 'M_C_SumSmash', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_SumSmash":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_SumSmash', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_SumSmash"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "maps" in data:
        field_maps = load_list_of_MonotoneMap(data["maps"])
    else:
        raise ValueError("Missing required field 'maps'")

    return M_C_SumSmash(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        labels=field_labels,
        maps=field_maps,
    )


def load_M_C_WrapUnits(data: object) -> "M_C_WrapUnits":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_C_WrapUnits":
            raise ValueError(f"Expected 'M_C_WrapUnits', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_C_WrapUnits":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_C_WrapUnits', got {field_type_}")
    else:
        field_type_ = json.loads('"M_C_WrapUnits"')

    if "cod_units" in data:
        field_cod_units = load_Unit(data["cod_units"])
    else:
        raise ValueError("Missing required field 'cod_units'")

    if "dom_units" in data:
        field_dom_units = load_Unit(data["dom_units"])
    else:
        raise ValueError("Missing required field 'dom_units'")

    if "m" in data:
        field_m = load_MonotoneMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return M_C_WrapUnits(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        cod_units=field_cod_units,
        dom_units=field_dom_units,
        m=field_m,
    )


def load_M_Ceil0(data: object) -> "M_Ceil0":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Ceil0":
            raise ValueError(f"Expected 'M_Ceil0', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Ceil0":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Ceil0', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Ceil0"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return M_Ceil0(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
    )


def load_M_Coerce(data: object) -> "M_Coerce":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Coerce":
            raise ValueError(f"Expected 'M_Coerce', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Coerce":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Coerce', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Coerce"')

    return M_Coerce(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
    )


def load_M_Constant(data: object) -> "M_Constant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Constant":
            raise ValueError(f"Expected 'M_Constant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Constant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Constant', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Constant"')

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_Constant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        value=field_value,
    )


def load_M_ContainedInLowerSet(data: object) -> "M_ContainedInLowerSet":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_ContainedInLowerSet":
            raise ValueError(f"Expected 'M_ContainedInLowerSet', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_ContainedInLowerSet":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_ContainedInLowerSet', got {field_type_}")
    else:
        field_type_ = json.loads('"M_ContainedInLowerSet"')

    if "lower_set" in data:
        field_lower_set = load_LowerSet(data["lower_set"])
    else:
        raise ValueError("Missing required field 'lower_set'")

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return M_ContainedInLowerSet(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        lower_set=field_lower_set,
        opspace=field_opspace,
    )


def load_M_ContainedInUpperSet(data: object) -> "M_ContainedInUpperSet":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_ContainedInUpperSet":
            raise ValueError(f"Expected 'M_ContainedInUpperSet', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_ContainedInUpperSet":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_ContainedInUpperSet', got {field_type_}")
    else:
        field_type_ = json.loads('"M_ContainedInUpperSet"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "upper_set" in data:
        field_upper_set = load_UpperSet(data["upper_set"])
    else:
        raise ValueError("Missing required field 'upper_set'")

    return M_ContainedInUpperSet(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
        upper_set=field_upper_set,
    )


def load_M_DivideLConstant(data: object) -> "M_DivideLConstant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_DivideLConstant":
            raise ValueError(f"Expected 'M_DivideLConstant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_DivideLConstant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_DivideLConstant', got {field_type_}")
    else:
        field_type_ = json.loads('"M_DivideLConstant"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_DivideLConstant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
        value=field_value,
    )


def load_M_DivideUConstant(data: object) -> "M_DivideUConstant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_DivideUConstant":
            raise ValueError(f"Expected 'M_DivideUConstant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_DivideUConstant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_DivideUConstant', got {field_type_}")
    else:
        field_type_ = json.loads('"M_DivideUConstant"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_DivideUConstant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
        value=field_value,
    )


def load_M_Empty(data: object) -> "M_Empty":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Empty":
            raise ValueError(f"Expected 'M_Empty', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Empty":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Empty', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Empty"')

    return M_Empty(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
    )


def load_M_Explicit(data: object) -> "M_Explicit":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Explicit":
            raise ValueError(f"Expected 'M_Explicit', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Explicit":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Explicit', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Explicit"')

    if "options" in data:
        field_options = load_list_of_M_Explicit_Option(data["options"])
    else:
        raise ValueError("Missing required field 'options'")

    return M_Explicit(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        options=field_options,
    )


def load_M_Explicit_Option(data: object) -> "M_Explicit_Option":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "x" in data:
        field_x = load_any(data["x"])
    else:
        raise ValueError("Missing required field 'x'")

    if "y" in data:
        field_y = load_any(data["y"])
    else:
        raise ValueError("Missing required field 'y'")

    return M_Explicit_Option(
        x=field_x,
        y=field_y,
    )


def load_M_Floor0(data: object) -> "M_Floor0":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Floor0":
            raise ValueError(f"Expected 'M_Floor0', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Floor0":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Floor0', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Floor0"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return M_Floor0(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
    )


def load_M_Id(data: object) -> "M_Id":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Id":
            raise ValueError(f"Expected 'M_Id', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Id":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Id', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Id"')

    return M_Id(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
    )


def load_M_IdentityBelowThreshold(data: object) -> "M_IdentityBelowThreshold":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_IdentityBelowThreshold":
            raise ValueError(f"Expected 'M_IdentityBelowThreshold', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_IdentityBelowThreshold":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_IdentityBelowThreshold', got {field_type_}")
    else:
        field_type_ = json.loads('"M_IdentityBelowThreshold"')

    if "threshold" in data:
        field_threshold = load_Value(data["threshold"])
    else:
        raise ValueError("Missing required field 'threshold'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_IdentityBelowThreshold(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        threshold=field_threshold,
        value=field_value,
    )


def load_M_Injection(data: object) -> "M_Injection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Injection":
            raise ValueError(f"Expected 'M_Injection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Injection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Injection', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Injection"')

    if "index" in data:
        field_index = load_int(data["index"])
    else:
        raise ValueError("Missing required field 'index'")

    return M_Injection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        index=field_index,
    )


def load_M_Join(data: object) -> "M_Join":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Join":
            raise ValueError(f"Expected 'M_Join', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Join":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Join', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Join"')

    if "opspaces" in data:
        field_opspaces = load_list_of_Poset(data["opspaces"])
    else:
        raise ValueError("Missing required field 'opspaces'")

    return M_Join(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspaces=field_opspaces,
    )


def load_M_JoinConstant(data: object) -> "M_JoinConstant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_JoinConstant":
            raise ValueError(f"Expected 'M_JoinConstant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_JoinConstant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_JoinConstant', got {field_type_}")
    else:
        field_type_ = json.loads('"M_JoinConstant"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_JoinConstant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
        value=field_value,
    )


def load_M_Leq(data: object) -> "M_Leq":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Leq":
            raise ValueError(f"Expected 'M_Leq', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Leq":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Leq', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Leq"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return M_Leq(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
    )


def load_M_Lift(data: object) -> "M_Lift":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Lift":
            raise ValueError(f"Expected 'M_Lift', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Lift":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Lift', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Lift"')

    return M_Lift(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
    )


def load_M_LiftToLowerSets(data: object) -> "M_LiftToLowerSets":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_LiftToLowerSets":
            raise ValueError(f"Expected 'M_LiftToLowerSets', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_LiftToLowerSets":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_LiftToLowerSets', got {field_type_}")
    else:
        field_type_ = json.loads('"M_LiftToLowerSets"')

    if "m" in data:
        field_m = load_MonotoneMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return M_LiftToLowerSets(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        m=field_m,
    )


def load_M_LiftToUpperSets(data: object) -> "M_LiftToUpperSets":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_LiftToUpperSets":
            raise ValueError(f"Expected 'M_LiftToUpperSets', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_LiftToUpperSets":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_LiftToUpperSets', got {field_type_}")
    else:
        field_type_ = json.loads('"M_LiftToUpperSets"')

    if "m" in data:
        field_m = load_MonotoneMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return M_LiftToUpperSets(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        m=field_m,
    )


def load_M_Meet(data: object) -> "M_Meet":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Meet":
            raise ValueError(f"Expected 'M_Meet', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Meet":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Meet', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Meet"')

    if "opspaces" in data:
        field_opspaces = load_list_of_Poset(data["opspaces"])
    else:
        raise ValueError("Missing required field 'opspaces'")

    return M_Meet(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspaces=field_opspaces,
    )


def load_M_MeetConstant(data: object) -> "M_MeetConstant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_MeetConstant":
            raise ValueError(f"Expected 'M_MeetConstant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_MeetConstant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_MeetConstant', got {field_type_}")
    else:
        field_type_ = json.loads('"M_MeetConstant"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_MeetConstant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
        value=field_value,
    )


def load_M_MultiplyL(data: object) -> "M_MultiplyL":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_MultiplyL":
            raise ValueError(f"Expected 'M_MultiplyL', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_MultiplyL":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_MultiplyL', got {field_type_}")
    else:
        field_type_ = json.loads('"M_MultiplyL"')

    if "opspaces" in data:
        field_opspaces = load_list_of_Poset(data["opspaces"])
    else:
        raise ValueError("Missing required field 'opspaces'")

    return M_MultiplyL(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspaces=field_opspaces,
    )


def load_M_MultiplyLConstant(data: object) -> "M_MultiplyLConstant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_MultiplyLConstant":
            raise ValueError(f"Expected 'M_MultiplyLConstant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_MultiplyLConstant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_MultiplyLConstant', got {field_type_}")
    else:
        field_type_ = json.loads('"M_MultiplyLConstant"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_MultiplyLConstant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
        value=field_value,
    )


def load_M_MultiplyU(data: object) -> "M_MultiplyU":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_MultiplyU":
            raise ValueError(f"Expected 'M_MultiplyU', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_MultiplyU":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_MultiplyU', got {field_type_}")
    else:
        field_type_ = json.loads('"M_MultiplyU"')

    if "opspaces" in data:
        field_opspaces = load_list_of_Poset(data["opspaces"])
    else:
        raise ValueError("Missing required field 'opspaces'")

    return M_MultiplyU(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspaces=field_opspaces,
    )


def load_M_MultiplyUConstant(data: object) -> "M_MultiplyUConstant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_MultiplyUConstant":
            raise ValueError(f"Expected 'M_MultiplyUConstant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_MultiplyUConstant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_MultiplyUConstant', got {field_type_}")
    else:
        field_type_ = json.loads('"M_MultiplyUConstant"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_MultiplyUConstant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
        value=field_value,
    )


def load_M_PowerFracL(data: object) -> "M_PowerFracL":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_PowerFracL":
            raise ValueError(f"Expected 'M_PowerFracL', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_PowerFracL":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_PowerFracL', got {field_type_}")
    else:
        field_type_ = json.loads('"M_PowerFracL"')

    if "den" in data:
        field_den = load_str(data["den"])
    else:
        raise ValueError("Missing required field 'den'")

    if "num" in data:
        field_num = load_str(data["num"])
    else:
        raise ValueError("Missing required field 'num'")

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return M_PowerFracL(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        den=field_den,
        num=field_num,
        opspace=field_opspace,
    )


def load_M_PowerFracU(data: object) -> "M_PowerFracU":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_PowerFracU":
            raise ValueError(f"Expected 'M_PowerFracU', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_PowerFracU":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_PowerFracU', got {field_type_}")
    else:
        field_type_ = json.loads('"M_PowerFracU"')

    if "den" in data:
        field_den = load_str(data["den"])
    else:
        raise ValueError("Missing required field 'den'")

    if "num" in data:
        field_num = load_str(data["num"])
    else:
        raise ValueError("Missing required field 'num'")

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return M_PowerFracU(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        den=field_den,
        num=field_num,
        opspace=field_opspace,
    )


def load_M_ReprLowerSet(data: object) -> "M_ReprLowerSet":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_ReprLowerSet":
            raise ValueError(f"Expected 'M_ReprLowerSet', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_ReprLowerSet":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_ReprLowerSet', got {field_type_}")
    else:
        field_type_ = json.loads('"M_ReprLowerSet"')

    return M_ReprLowerSet(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
    )


def load_M_ReprUpperSet(data: object) -> "M_ReprUpperSet":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_ReprUpperSet":
            raise ValueError(f"Expected 'M_ReprUpperSet', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_ReprUpperSet":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_ReprUpperSet', got {field_type_}")
    else:
        field_type_ = json.loads('"M_ReprUpperSet"')

    return M_ReprUpperSet(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
    )


def load_M_RepresentPrincipalLowerSet_TotalOrderBounded(data: object) -> "M_RepresentPrincipalLowerSet_TotalOrderBounded":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_RepresentPrincipalLowerSet_TotalOrderBounded":
            raise ValueError(f"Expected 'M_RepresentPrincipalLowerSet_TotalOrderBounded', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_RepresentPrincipalLowerSet_TotalOrderBounded":
            raise ValueError(
                f"Invalid discriminator value for 'type': expected 'M_RepresentPrincipalLowerSet_TotalOrderBounded', "
                f"got {field_type_}"
            )
    else:
        field_type_ = json.loads('"M_RepresentPrincipalLowerSet_TotalOrderBounded"')

    return M_RepresentPrincipalLowerSet_TotalOrderBounded(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
    )


def load_M_RepresentPrincipalUpperSet_TotalOrderBounded(data: object) -> "M_RepresentPrincipalUpperSet_TotalOrderBounded":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_RepresentPrincipalUpperSet_TotalOrderBounded":
            raise ValueError(f"Expected 'M_RepresentPrincipalUpperSet_TotalOrderBounded', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_RepresentPrincipalUpperSet_TotalOrderBounded":
            raise ValueError(
                f"Invalid discriminator value for 'type': expected 'M_RepresentPrincipalUpperSet_TotalOrderBounded', "
                f"got {field_type_}"
            )
    else:
        field_type_ = json.loads('"M_RepresentPrincipalUpperSet_TotalOrderBounded"')

    return M_RepresentPrincipalUpperSet_TotalOrderBounded(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
    )


def load_M_RoundDown(data: object) -> "M_RoundDown":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_RoundDown":
            raise ValueError(f"Expected 'M_RoundDown', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_RoundDown":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_RoundDown', got {field_type_}")
    else:
        field_type_ = json.loads('"M_RoundDown"')

    if "offset" in data:
        field_offset = load_any(data["offset"])
    else:
        raise ValueError("Missing required field 'offset'")

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "step" in data:
        field_step = load_str(data["step"])
    else:
        raise ValueError("Missing required field 'step'")

    return M_RoundDown(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        offset=field_offset,
        opspace=field_opspace,
        step=field_step,
    )


def load_M_RoundUp(data: object) -> "M_RoundUp":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_RoundUp":
            raise ValueError(f"Expected 'M_RoundUp', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_RoundUp":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_RoundUp', got {field_type_}")
    else:
        field_type_ = json.loads('"M_RoundUp"')

    if "offset" in data:
        field_offset = load_any(data["offset"])
    else:
        raise ValueError("Missing required field 'offset'")

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "step" in data:
        field_step = load_str(data["step"])
    else:
        raise ValueError("Missing required field 'step'")

    return M_RoundUp(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        offset=field_offset,
        opspace=field_opspace,
        step=field_step,
    )


def load_M_ScaleL(data: object) -> "M_ScaleL":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_ScaleL":
            raise ValueError(f"Expected 'M_ScaleL', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_ScaleL":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_ScaleL', got {field_type_}")
    else:
        field_type_ = json.loads('"M_ScaleL"')

    if "den" in data:
        field_den = load_str(data["den"])
    else:
        raise ValueError("Missing required field 'den'")

    if "num" in data:
        field_num = load_str(data["num"])
    else:
        raise ValueError("Missing required field 'num'")

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return M_ScaleL(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        den=field_den,
        num=field_num,
        opspace=field_opspace,
    )


def load_M_ScaleU(data: object) -> "M_ScaleU":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_ScaleU":
            raise ValueError(f"Expected 'M_ScaleU', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_ScaleU":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_ScaleU', got {field_type_}")
    else:
        field_type_ = json.loads('"M_ScaleU"')

    if "den" in data:
        field_den = load_str(data["den"])
    else:
        raise ValueError("Missing required field 'den'")

    if "num" in data:
        field_num = load_str(data["num"])
    else:
        raise ValueError("Missing required field 'num'")

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return M_ScaleU(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        den=field_den,
        num=field_num,
        opspace=field_opspace,
    )


def load_M_SmashInjection(data: object) -> "M_SmashInjection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_SmashInjection":
            raise ValueError(f"Expected 'M_SmashInjection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_SmashInjection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_SmashInjection', got {field_type_}")
    else:
        field_type_ = json.loads('"M_SmashInjection"')

    if "index" in data:
        field_index = load_int(data["index"])
    else:
        raise ValueError("Missing required field 'index'")

    return M_SmashInjection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        index=field_index,
    )


def load_M_SubLConstant(data: object) -> "M_SubLConstant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_SubLConstant":
            raise ValueError(f"Expected 'M_SubLConstant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_SubLConstant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_SubLConstant', got {field_type_}")
    else:
        field_type_ = json.loads('"M_SubLConstant"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_SubLConstant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
        value=field_value,
    )


def load_M_SubUConstant(data: object) -> "M_SubUConstant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_SubUConstant":
            raise ValueError(f"Expected 'M_SubUConstant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_SubUConstant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_SubUConstant', got {field_type_}")
    else:
        field_type_ = json.loads('"M_SubUConstant"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_SubUConstant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
        value=field_value,
    )


def load_M_TakeIndex(data: object) -> "M_TakeIndex":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_TakeIndex":
            raise ValueError(f"Expected 'M_TakeIndex', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_TakeIndex":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_TakeIndex', got {field_type_}")
    else:
        field_type_ = json.loads('"M_TakeIndex"')

    if "projection" in data:
        field_projection = load_Projection(data["projection"])
    else:
        raise ValueError("Missing required field 'projection'")

    return M_TakeIndex(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        projection=field_projection,
    )


def load_M_TakeRange(data: object) -> "M_TakeRange":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_TakeRange":
            raise ValueError(f"Expected 'M_TakeRange', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_TakeRange":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_TakeRange', got {field_type_}")
    else:
        field_type_ = json.loads('"M_TakeRange"')

    if "range" in data:
        field_range = load_Range(data["range"])
    else:
        raise ValueError("Missing required field 'range'")

    return M_TakeRange(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        range=field_range,
    )


def load_M_Threshold1(data: object) -> "M_Threshold1":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Threshold1":
            raise ValueError(f"Expected 'M_Threshold1', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Threshold1":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Threshold1', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Threshold1"')

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_Threshold1(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        value=field_value,
    )


def load_M_Threshold2(data: object) -> "M_Threshold2":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Threshold2":
            raise ValueError(f"Expected 'M_Threshold2', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Threshold2":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Threshold2', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Threshold2"')

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_Threshold2(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        value=field_value,
    )


def load_M_TopIfNotBottom(data: object) -> "M_TopIfNotBottom":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_TopIfNotBottom":
            raise ValueError(f"Expected 'M_TopIfNotBottom', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_TopIfNotBottom":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_TopIfNotBottom', got {field_type_}")
    else:
        field_type_ = json.loads('"M_TopIfNotBottom"')

    return M_TopIfNotBottom(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
    )


def load_M_Undefined(data: object) -> "M_Undefined":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Undefined":
            raise ValueError(f"Expected 'M_Undefined', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Undefined":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Undefined', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Undefined"')

    return M_Undefined(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
    )


def load_M_Unknown(data: object) -> "M_Unknown":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Unknown":
            raise ValueError(f"Expected 'M_Unknown', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Unknown":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Unknown', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Unknown"')

    return M_Unknown(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
    )


def load_M_Unlift(data: object) -> "M_Unlift":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_Unlift":
            raise ValueError(f"Expected 'M_Unlift', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_Unlift":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_Unlift', got {field_type_}")
    else:
        field_type_ = json.loads('"M_Unlift"')

    return M_Unlift(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
    )


def load_M_X_Leq_C(data: object) -> "M_X_Leq_C":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_X_Leq_C":
            raise ValueError(f"Expected 'M_X_Leq_C', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_X_Leq_C":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_X_Leq_C', got {field_type_}")
    else:
        field_type_ = json.loads('"M_X_Leq_C"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_X_Leq_C(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
        value=field_value,
    )


def load_M_X_Lt_C(data: object) -> "M_X_Lt_C":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "MonotoneMap":
            raise ValueError(f"Expected 'MonotoneMap', got {field_kind}'")
        if field_kind is not None and field_kind != "MonotoneMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'MonotoneMap', got {field_kind}")
    else:
        field_kind = json.loads('"MonotoneMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "cod" in data:
        field_cod = load_Poset(data["cod"])
    else:
        raise ValueError("Missing required field 'cod'")

    if "dom" in data:
        field_dom = load_Poset(data["dom"])
    else:
        raise ValueError("Missing required field 'dom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "M_X_Lt_C":
            raise ValueError(f"Expected 'M_X_Lt_C', got {field_type_}'")
        if field_type_ is not None and field_type_ != "M_X_Lt_C":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'M_X_Lt_C', got {field_type_}")
    else:
        field_type_ = json.loads('"M_X_Lt_C"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return M_X_Lt_C(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        cod=field_cod,
        dom=field_dom,
        type_=field_type_,
        opspace=field_opspace,
        value=field_value,
    )


def load_MapCheck(data: object) -> "MapCheck":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Check":
            raise ValueError(f"Expected 'Check', got {field_kind}'")
        if field_kind is not None and field_kind != "Check":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Check', got {field_kind}")
    else:
        field_kind = json.loads('"Check"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "MapCheck":
            raise ValueError(f"Expected 'MapCheck', got {field_type_}'")
        if field_type_ is not None and field_type_ != "MapCheck":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'MapCheck', got {field_type_}")
    else:
        field_type_ = json.loads('"MapCheck"')

    if "data" in data:
        field_data = load_list_of_MapCheck_Data(data["data"])
    else:
        raise ValueError("Missing required field 'data'")

    if "m" in data:
        field_m = load_MonotoneMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return MapCheck(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        type_=field_type_,
        data=field_data,
        m=field_m,
    )


def load_MapCheck_Data(data: object) -> "MapCheck_Data":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "elapsed" in data:
        value = data["elapsed"]
        if value is None:
            field_elapsed = None
        else:
            field_elapsed = load_float(value)
    else:
        field_elapsed = None

    if "x" in data:
        field_x = load_any(data["x"])
    else:
        raise ValueError("Missing required field 'x'")

    if "y" in data:
        field_y = load_any(data["y"])
    else:
        raise ValueError("Missing required field 'y'")

    return MapCheck_Data(
        elapsed=field_elapsed,
        x=field_x,
        y=field_y,
    )


def load_ModelFunctionality(data: object) -> "ModelFunctionality":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "ModelFunctionality":
            raise ValueError(f"Expected 'ModelFunctionality', got {field_type_}'")
        if field_type_ is not None and field_type_ != "ModelFunctionality":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'ModelFunctionality', got {field_type_}")
    else:
        field_type_ = json.loads('"ModelFunctionality"')

    if "functionality" in data:
        field_functionality = load_str(data["functionality"])
    else:
        raise ValueError("Missing required field 'functionality'")

    return ModelFunctionality(
        type_=field_type_,
        functionality=field_functionality,
    )


def load_ModelRequirement(data: object) -> "ModelRequirement":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "ModelRequirement":
            raise ValueError(f"Expected 'ModelRequirement', got {field_type_}'")
        if field_type_ is not None and field_type_ != "ModelRequirement":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'ModelRequirement', got {field_type_}")
    else:
        field_type_ = json.loads('"ModelRequirement"')

    if "requirement" in data:
        field_requirement = load_str(data["requirement"])
    else:
        raise ValueError("Missing required field 'requirement'")

    return ModelRequirement(
        type_=field_type_,
        requirement=field_requirement,
    )


def load_NDP(data: object) -> "NDP":
    """Load NDP from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "NDP_Composite": load_NDP_Composite,
        "NDP_Simple": load_NDP_Simple,
        "NDP_Sum": load_NDP_Sum,
        "NDP_TemplateHole": load_NDP_TemplateHole,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for NDP")


def load_NDPInterface(data: object) -> "NDPInterface":
    """Load NDPInterface from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "NDPInterface_Explicit": load_NDPInterface_Explicit,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for NDPInterface")


def load_NDPInterface_Explicit(data: object) -> "NDPInterface_Explicit":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "NDPInterface":
            raise ValueError(f"Expected 'NDPInterface', got {field_kind}'")
        if field_kind is not None and field_kind != "NDPInterface":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'NDPInterface', got {field_kind}")
    else:
        field_kind = json.loads('"NDPInterface"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "NDPInterface_Explicit":
            raise ValueError(f"Expected 'NDPInterface_Explicit', got {field_type_}'")
        if field_type_ is not None and field_type_ != "NDPInterface_Explicit":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'NDPInterface_Explicit', got {field_type_}")
    else:
        field_type_ = json.loads('"NDPInterface_Explicit"')

    if "fs" in data:
        field_fs = load_dict_of_str_Poset(data["fs"])
    else:
        raise ValueError("Missing required field 'fs'")

    if "rs" in data:
        field_rs = load_dict_of_str_Poset(data["rs"])
    else:
        raise ValueError("Missing required field 'rs'")

    return NDPInterface_Explicit(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        fs=field_fs,
        rs=field_rs,
    )


def load_NDPTemplate(data: object) -> "NDPTemplate":
    """Load NDPTemplate from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "NDPTemplate_Simple": load_NDPTemplate_Simple,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for NDPTemplate")


def load_NDPTemplate_Simple(data: object) -> "NDPTemplate_Simple":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "NDPTemplate":
            raise ValueError(f"Expected 'NDPTemplate', got {field_kind}'")
        if field_kind is not None and field_kind != "NDPTemplate":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'NDPTemplate', got {field_kind}")
    else:
        field_kind = json.loads('"NDPTemplate"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "NDPTemplate_Simple":
            raise ValueError(f"Expected 'NDPTemplate_Simple', got {field_type_}'")
        if field_type_ is not None and field_type_ != "NDPTemplate_Simple":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'NDPTemplate_Simple', got {field_type_}")
    else:
        field_type_ = json.loads('"NDPTemplate_Simple"')

    if "ndp" in data:
        field_ndp = load_NDP(data["ndp"])
    else:
        raise ValueError("Missing required field 'ndp'")

    if "parameters" in data:
        field_parameters = load_dict_of_str_NDPInterface(data["parameters"])
    else:
        raise ValueError("Missing required field 'parameters'")

    return NDPTemplate_Simple(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        ndp=field_ndp,
        parameters=field_parameters,
    )


def load_NDP_Composite(data: object) -> "NDP_Composite":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "NDP":
            raise ValueError(f"Expected 'NDP', got {field_kind}'")
        if field_kind is not None and field_kind != "NDP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'NDP', got {field_kind}")
    else:
        field_kind = json.loads('"NDP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "C" in data:
        field_C = load_Poset(data["C"])
    else:
        raise ValueError("Missing required field 'C'")

    if "F" in data:
        field_F = load_dict_of_str_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "J" in data:
        field_J = load_Poset(data["J"])
    else:
        raise ValueError("Missing required field 'J'")

    if "R" in data:
        field_R = load_dict_of_str_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "NDP_Composite":
            raise ValueError(f"Expected 'NDP_Composite', got {field_type_}'")
        if field_type_ is not None and field_type_ != "NDP_Composite":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'NDP_Composite', got {field_type_}")
    else:
        field_type_ = json.loads('"NDP_Composite"')

    if "connections" in data:
        field_connections = load_list_of_Connection(data["connections"])
    else:
        raise ValueError("Missing required field 'connections'")

    if "nodes" in data:
        field_nodes = load_dict_of_str_NDP(data["nodes"])
    else:
        raise ValueError("Missing required field 'nodes'")

    return NDP_Composite(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        C=field_C,
        F=field_F,
        J=field_J,
        R=field_R,
        address=field_address,
        type_=field_type_,
        connections=field_connections,
        nodes=field_nodes,
    )


def load_NDP_Simple(data: object) -> "NDP_Simple":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "NDP":
            raise ValueError(f"Expected 'NDP', got {field_kind}'")
        if field_kind is not None and field_kind != "NDP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'NDP', got {field_kind}")
    else:
        field_kind = json.loads('"NDP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "C" in data:
        field_C = load_Poset(data["C"])
    else:
        raise ValueError("Missing required field 'C'")

    if "F" in data:
        field_F = load_dict_of_str_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "J" in data:
        field_J = load_Poset(data["J"])
    else:
        raise ValueError("Missing required field 'J'")

    if "R" in data:
        field_R = load_dict_of_str_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "NDP_Simple":
            raise ValueError(f"Expected 'NDP_Simple', got {field_type_}'")
        if field_type_ is not None and field_type_ != "NDP_Simple":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'NDP_Simple', got {field_type_}")
    else:
        field_type_ = json.loads('"NDP_Simple"')

    if "dp" in data:
        field_dp = load_DP(data["dp"])
    else:
        raise ValueError("Missing required field 'dp'")

    return NDP_Simple(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        C=field_C,
        F=field_F,
        J=field_J,
        R=field_R,
        address=field_address,
        type_=field_type_,
        dp=field_dp,
    )


def load_NDP_Sum(data: object) -> "NDP_Sum":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "NDP":
            raise ValueError(f"Expected 'NDP', got {field_kind}'")
        if field_kind is not None and field_kind != "NDP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'NDP', got {field_kind}")
    else:
        field_kind = json.loads('"NDP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "C" in data:
        field_C = load_Poset(data["C"])
    else:
        raise ValueError("Missing required field 'C'")

    if "F" in data:
        field_F = load_dict_of_str_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "J" in data:
        field_J = load_Poset(data["J"])
    else:
        raise ValueError("Missing required field 'J'")

    if "R" in data:
        field_R = load_dict_of_str_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "NDP_Sum":
            raise ValueError(f"Expected 'NDP_Sum', got {field_type_}'")
        if field_type_ is not None and field_type_ != "NDP_Sum":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'NDP_Sum', got {field_type_}")
    else:
        field_type_ = json.loads('"NDP_Sum"')

    if "dps" in data:
        field_dps = load_dict_of_str_NDP(data["dps"])
    else:
        raise ValueError("Missing required field 'dps'")

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    return NDP_Sum(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        C=field_C,
        F=field_F,
        J=field_J,
        R=field_R,
        address=field_address,
        type_=field_type_,
        dps=field_dps,
        labels=field_labels,
    )


def load_NDP_TemplateHole(data: object) -> "NDP_TemplateHole":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "NDP":
            raise ValueError(f"Expected 'NDP', got {field_kind}'")
        if field_kind is not None and field_kind != "NDP":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'NDP', got {field_kind}")
    else:
        field_kind = json.loads('"NDP"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "C" in data:
        field_C = load_Poset(data["C"])
    else:
        raise ValueError("Missing required field 'C'")

    if "F" in data:
        field_F = load_dict_of_str_Poset(data["F"])
    else:
        raise ValueError("Missing required field 'F'")

    if "J" in data:
        field_J = load_Poset(data["J"])
    else:
        raise ValueError("Missing required field 'J'")

    if "R" in data:
        field_R = load_dict_of_str_Poset(data["R"])
    else:
        raise ValueError("Missing required field 'R'")

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "NDP_TemplateHole":
            raise ValueError(f"Expected 'NDP_TemplateHole', got {field_type_}'")
        if field_type_ is not None and field_type_ != "NDP_TemplateHole":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'NDP_TemplateHole', got {field_type_}")
    else:
        field_type_ = json.loads('"NDP_TemplateHole"')

    if "parameter_name" in data:
        field_parameter_name = load_str(data["parameter_name"])
    else:
        raise ValueError("Missing required field 'parameter_name'")

    return NDP_TemplateHole(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        C=field_C,
        F=field_F,
        J=field_J,
        R=field_R,
        address=field_address,
        type_=field_type_,
        parameter_name=field_parameter_name,
    )


def load_NodeFunctionality(data: object) -> "NodeFunctionality":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "NodeFunctionality":
            raise ValueError(f"Expected 'NodeFunctionality', got {field_type_}'")
        if field_type_ is not None and field_type_ != "NodeFunctionality":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'NodeFunctionality', got {field_type_}")
    else:
        field_type_ = json.loads('"NodeFunctionality"')

    if "node" in data:
        field_node = load_str(data["node"])
    else:
        raise ValueError("Missing required field 'node'")

    if "node_functionality" in data:
        field_node_functionality = load_str(data["node_functionality"])
    else:
        raise ValueError("Missing required field 'node_functionality'")

    return NodeFunctionality(
        type_=field_type_,
        node=field_node,
        node_functionality=field_node_functionality,
    )


def load_NodeRequirement(data: object) -> "NodeRequirement":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "NodeRequirement":
            raise ValueError(f"Expected 'NodeRequirement', got {field_type_}'")
        if field_type_ is not None and field_type_ != "NodeRequirement":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'NodeRequirement', got {field_type_}")
    else:
        field_type_ = json.loads('"NodeRequirement"')

    if "node" in data:
        field_node = load_str(data["node"])
    else:
        raise ValueError("Missing required field 'node'")

    if "node_requirement" in data:
        field_node_requirement = load_str(data["node_requirement"])
    else:
        raise ValueError("Missing required field 'node_requirement'")

    return NodeRequirement(
        type_=field_type_,
        node=field_node,
        node_requirement=field_node_requirement,
    )


def load_Poset(data: object) -> "Poset":
    """Load Poset from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "P_Bool": load_P_Bool,
        "P_C_Arrow": load_P_C_Arrow,
        "P_C_Discretized": load_P_C_Discretized,
        "P_C_Lexicographic": load_P_C_Lexicographic,
        "P_C_LowerSets": load_P_C_LowerSets,
        "P_C_Multisets": load_P_C_Multisets,
        "P_C_Opposite": load_P_C_Opposite,
        "P_C_Power": load_P_C_Power,
        "P_C_Product": load_P_C_Product,
        "P_C_ProductDS": load_P_C_ProductDS,
        "P_C_ProductSmash": load_P_C_ProductSmash,
        "P_C_Sum": load_P_C_Sum,
        "P_C_SumSmash": load_P_C_SumSmash,
        "P_C_Twisted": load_P_C_Twisted,
        "P_C_Units": load_P_C_Units,
        "P_C_UpperSets": load_P_C_UpperSets,
        "P_Decimal": load_P_Decimal,
        "P_F_Bounded": load_P_F_Bounded,
        "P_F_C_Intersection": load_P_F_C_Intersection,
        "P_F_C_Union": load_P_F_C_Union,
        "P_F_Interval": load_P_F_Interval,
        "P_F_LowerClosure": load_P_F_LowerClosure,
        "P_F_Subposet": load_P_F_Subposet,
        "P_F_UpperClosure": load_P_F_UpperClosure,
        "P_Finite": load_P_Finite,
        "P_Float": load_P_Float,
        "P_Fractions": load_P_Fractions,
        "P_Integer": load_P_Integer,
        "P_Unknown": load_P_Unknown,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for Poset")


def load_P_Bool(data: object) -> "P_Bool":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_Bool":
            raise ValueError(f"Expected 'P_Bool', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_Bool":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_Bool', got {field_type_}")
    else:
        field_type_ = json.loads('"P_Bool"')

    return P_Bool(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
    )


def load_P_C_Arrow(data: object) -> "P_C_Arrow":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_C_Arrow":
            raise ValueError(f"Expected 'P_C_Arrow', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_C_Arrow":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_C_Arrow', got {field_type_}")
    else:
        field_type_ = json.loads('"P_C_Arrow"')

    if "poset" in data:
        field_poset = load_Poset(data["poset"])
    else:
        raise ValueError("Missing required field 'poset'")

    return P_C_Arrow(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        poset=field_poset,
    )


def load_P_C_Discretized(data: object) -> "P_C_Discretized":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_C_Discretized":
            raise ValueError(f"Expected 'P_C_Discretized', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_C_Discretized":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_C_Discretized', got {field_type_}")
    else:
        field_type_ = json.loads('"P_C_Discretized"')

    if "poset" in data:
        field_poset = load_Poset(data["poset"])
    else:
        raise ValueError("Missing required field 'poset'")

    return P_C_Discretized(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        poset=field_poset,
    )


def load_P_C_Lexicographic(data: object) -> "P_C_Lexicographic":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_C_Lexicographic":
            raise ValueError(f"Expected 'P_C_Lexicographic', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_C_Lexicographic":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_C_Lexicographic', got {field_type_}")
    else:
        field_type_ = json.loads('"P_C_Lexicographic"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "subs" in data:
        field_subs = load_list_of_Poset(data["subs"])
    else:
        raise ValueError("Missing required field 'subs'")

    return P_C_Lexicographic(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        labels=field_labels,
        subs=field_subs,
    )


def load_P_C_LowerSets(data: object) -> "P_C_LowerSets":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_C_LowerSets":
            raise ValueError(f"Expected 'P_C_LowerSets', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_C_LowerSets":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_C_LowerSets', got {field_type_}")
    else:
        field_type_ = json.loads('"P_C_LowerSets"')

    if "poset" in data:
        field_poset = load_Poset(data["poset"])
    else:
        raise ValueError("Missing required field 'poset'")

    return P_C_LowerSets(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        poset=field_poset,
    )


def load_P_C_Multisets(data: object) -> "P_C_Multisets":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_C_Multisets":
            raise ValueError(f"Expected 'P_C_Multisets', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_C_Multisets":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_C_Multisets', got {field_type_}")
    else:
        field_type_ = json.loads('"P_C_Multisets"')

    if "counts" in data:
        field_counts = load_Poset(data["counts"])
    else:
        raise ValueError("Missing required field 'counts'")

    if "values" in data:
        field_values = load_Poset(data["values"])
    else:
        raise ValueError("Missing required field 'values'")

    return P_C_Multisets(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        counts=field_counts,
        values=field_values,
    )


def load_P_C_Opposite(data: object) -> "P_C_Opposite":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_C_Opposite":
            raise ValueError(f"Expected 'P_C_Opposite', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_C_Opposite":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_C_Opposite', got {field_type_}")
    else:
        field_type_ = json.loads('"P_C_Opposite"')

    if "poset" in data:
        field_poset = load_Poset(data["poset"])
    else:
        raise ValueError("Missing required field 'poset'")

    return P_C_Opposite(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        poset=field_poset,
    )


def load_P_C_Power(data: object) -> "P_C_Power":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_C_Power":
            raise ValueError(f"Expected 'P_C_Power', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_C_Power":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_C_Power', got {field_type_}")
    else:
        field_type_ = json.loads('"P_C_Power"')

    if "poset" in data:
        field_poset = load_Poset(data["poset"])
    else:
        raise ValueError("Missing required field 'poset'")

    return P_C_Power(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        poset=field_poset,
    )


def load_P_C_Product(data: object) -> "P_C_Product":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_C_Product":
            raise ValueError(f"Expected 'P_C_Product', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_C_Product":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_C_Product', got {field_type_}")
    else:
        field_type_ = json.loads('"P_C_Product"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "subs" in data:
        field_subs = load_list_of_Poset(data["subs"])
    else:
        raise ValueError("Missing required field 'subs'")

    return P_C_Product(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        labels=field_labels,
        subs=field_subs,
    )


def load_P_C_ProductDS(data: object) -> "P_C_ProductDS":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_C_ProductDS":
            raise ValueError(f"Expected 'P_C_ProductDS', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_C_ProductDS":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_C_ProductDS', got {field_type_}")
    else:
        field_type_ = json.loads('"P_C_ProductDS"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "subs" in data:
        field_subs = load_list_of_Poset(data["subs"])
    else:
        raise ValueError("Missing required field 'subs'")

    return P_C_ProductDS(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        labels=field_labels,
        subs=field_subs,
    )


def load_P_C_ProductSmash(data: object) -> "P_C_ProductSmash":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_C_ProductSmash":
            raise ValueError(f"Expected 'P_C_ProductSmash', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_C_ProductSmash":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_C_ProductSmash', got {field_type_}")
    else:
        field_type_ = json.loads('"P_C_ProductSmash"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "naked" in data:
        field_naked = load_list_of_bool(data["naked"])
    else:
        raise ValueError("Missing required field 'naked'")

    if "ranges" in data:
        field_ranges = load_list_of_Range(data["ranges"])
    else:
        raise ValueError("Missing required field 'ranges'")

    if "subs" in data:
        field_subs = load_list_of_Poset(data["subs"])
    else:
        raise ValueError("Missing required field 'subs'")

    return P_C_ProductSmash(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        labels=field_labels,
        naked=field_naked,
        ranges=field_ranges,
        subs=field_subs,
    )


def load_P_C_Sum(data: object) -> "P_C_Sum":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_C_Sum":
            raise ValueError(f"Expected 'P_C_Sum', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_C_Sum":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_C_Sum', got {field_type_}")
    else:
        field_type_ = json.loads('"P_C_Sum"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "subs" in data:
        field_subs = load_list_of_Poset(data["subs"])
    else:
        raise ValueError("Missing required field 'subs'")

    return P_C_Sum(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        labels=field_labels,
        subs=field_subs,
    )


def load_P_C_SumSmash(data: object) -> "P_C_SumSmash":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_C_SumSmash":
            raise ValueError(f"Expected 'P_C_SumSmash', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_C_SumSmash":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_C_SumSmash', got {field_type_}")
    else:
        field_type_ = json.loads('"P_C_SumSmash"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "naked" in data:
        field_naked = load_list_of_bool(data["naked"])
    else:
        raise ValueError("Missing required field 'naked'")

    if "ranges" in data:
        field_ranges = load_list_of_Range(data["ranges"])
    else:
        raise ValueError("Missing required field 'ranges'")

    if "subs" in data:
        field_subs = load_list_of_Poset(data["subs"])
    else:
        raise ValueError("Missing required field 'subs'")

    if "trivial" in data:
        field_trivial = load_bool(data["trivial"])
    else:
        raise ValueError("Missing required field 'trivial'")

    return P_C_SumSmash(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        labels=field_labels,
        naked=field_naked,
        ranges=field_ranges,
        subs=field_subs,
        trivial=field_trivial,
    )


def load_P_C_Twisted(data: object) -> "P_C_Twisted":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_C_Twisted":
            raise ValueError(f"Expected 'P_C_Twisted', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_C_Twisted":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_C_Twisted', got {field_type_}")
    else:
        field_type_ = json.loads('"P_C_Twisted"')

    if "poset" in data:
        field_poset = load_Poset(data["poset"])
    else:
        raise ValueError("Missing required field 'poset'")

    return P_C_Twisted(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        poset=field_poset,
    )


def load_P_C_Units(data: object) -> "P_C_Units":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_C_Units":
            raise ValueError(f"Expected 'P_C_Units', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_C_Units":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_C_Units', got {field_type_}")
    else:
        field_type_ = json.loads('"P_C_Units"')

    if "poset" in data:
        field_poset = load_Poset(data["poset"])
    else:
        raise ValueError("Missing required field 'poset'")

    if "units" in data:
        field_units = load_Unit(data["units"])
    else:
        raise ValueError("Missing required field 'units'")

    return P_C_Units(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        poset=field_poset,
        units=field_units,
    )


def load_P_C_UpperSets(data: object) -> "P_C_UpperSets":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_C_UpperSets":
            raise ValueError(f"Expected 'P_C_UpperSets', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_C_UpperSets":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_C_UpperSets', got {field_type_}")
    else:
        field_type_ = json.loads('"P_C_UpperSets"')

    if "poset" in data:
        field_poset = load_Poset(data["poset"])
    else:
        raise ValueError("Missing required field 'poset'")

    return P_C_UpperSets(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        poset=field_poset,
    )


def load_P_Decimal(data: object) -> "P_Decimal":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_Decimal":
            raise ValueError(f"Expected 'P_Decimal', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_Decimal":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_Decimal', got {field_type_}")
    else:
        field_type_ = json.loads('"P_Decimal"')

    if "precision" in data:
        field_precision = load_int(data["precision"])
    else:
        field_precision = json.loads("9")

    return P_Decimal(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        precision=field_precision,
    )


def load_P_F_Bounded(data: object) -> "P_F_Bounded":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_F_Bounded":
            raise ValueError(f"Expected 'P_F_Bounded', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_F_Bounded":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_F_Bounded', got {field_type_}")
    else:
        field_type_ = json.loads('"P_F_Bounded"')

    if "bottom" in data:
        field_bottom = load_any(data["bottom"])
    else:
        raise ValueError("Missing required field 'bottom'")

    if "bound_high" in data:
        field_bound_high = load_any(data["bound_high"])
    else:
        raise ValueError("Missing required field 'bound_high'")

    if "bound_low" in data:
        field_bound_low = load_any(data["bound_low"])
    else:
        raise ValueError("Missing required field 'bound_low'")

    if "offset" in data:
        field_offset = load_any(data["offset"])
    else:
        raise ValueError("Missing required field 'offset'")

    if "poset" in data:
        field_poset = load_Poset(data["poset"])
    else:
        raise ValueError("Missing required field 'poset'")

    if "step" in data:
        field_step = load_str(data["step"])
    else:
        raise ValueError("Missing required field 'step'")

    if "top" in data:
        field_top = load_any(data["top"])
    else:
        raise ValueError("Missing required field 'top'")

    return P_F_Bounded(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        bottom=field_bottom,
        bound_high=field_bound_high,
        bound_low=field_bound_low,
        offset=field_offset,
        poset=field_poset,
        step=field_step,
        top=field_top,
    )


def load_P_F_C_Intersection(data: object) -> "P_F_C_Intersection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_F_C_Intersection":
            raise ValueError(f"Expected 'P_F_C_Intersection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_F_C_Intersection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_F_C_Intersection', got {field_type_}")
    else:
        field_type_ = json.loads('"P_F_C_Intersection"')

    if "ambient" in data:
        field_ambient = load_Poset(data["ambient"])
    else:
        raise ValueError("Missing required field 'ambient'")

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "subs" in data:
        field_subs = load_list_of_Poset(data["subs"])
    else:
        raise ValueError("Missing required field 'subs'")

    return P_F_C_Intersection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        ambient=field_ambient,
        labels=field_labels,
        subs=field_subs,
    )


def load_P_F_C_Union(data: object) -> "P_F_C_Union":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_F_C_Union":
            raise ValueError(f"Expected 'P_F_C_Union', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_F_C_Union":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_F_C_Union', got {field_type_}")
    else:
        field_type_ = json.loads('"P_F_C_Union"')

    if "ambient" in data:
        field_ambient = load_Poset(data["ambient"])
    else:
        raise ValueError("Missing required field 'ambient'")

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "subs" in data:
        field_subs = load_list_of_Poset(data["subs"])
    else:
        raise ValueError("Missing required field 'subs'")

    return P_F_C_Union(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        ambient=field_ambient,
        labels=field_labels,
        subs=field_subs,
    )


def load_P_F_Interval(data: object) -> "P_F_Interval":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_F_Interval":
            raise ValueError(f"Expected 'P_F_Interval', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_F_Interval":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_F_Interval', got {field_type_}")
    else:
        field_type_ = json.loads('"P_F_Interval"')

    if "high" in data:
        field_high = load_any(data["high"])
    else:
        raise ValueError("Missing required field 'high'")

    if "low" in data:
        field_low = load_any(data["low"])
    else:
        raise ValueError("Missing required field 'low'")

    if "poset" in data:
        field_poset = load_Poset(data["poset"])
    else:
        raise ValueError("Missing required field 'poset'")

    return P_F_Interval(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        high=field_high,
        low=field_low,
        poset=field_poset,
    )


def load_P_F_LowerClosure(data: object) -> "P_F_LowerClosure":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_F_LowerClosure":
            raise ValueError(f"Expected 'P_F_LowerClosure', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_F_LowerClosure":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_F_LowerClosure', got {field_type_}")
    else:
        field_type_ = json.loads('"P_F_LowerClosure"')

    if "ls" in data:
        field_ls = load_LowerSet(data["ls"])
    else:
        raise ValueError("Missing required field 'ls'")

    if "poset" in data:
        field_poset = load_Poset(data["poset"])
    else:
        raise ValueError("Missing required field 'poset'")

    return P_F_LowerClosure(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        ls=field_ls,
        poset=field_poset,
    )


def load_P_F_Subposet(data: object) -> "P_F_Subposet":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_F_Subposet":
            raise ValueError(f"Expected 'P_F_Subposet', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_F_Subposet":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_F_Subposet', got {field_type_}")
    else:
        field_type_ = json.loads('"P_F_Subposet"')

    if "elements" in data:
        field_elements = load_list_of_any(data["elements"])
    else:
        raise ValueError("Missing required field 'elements'")

    if "poset" in data:
        field_poset = load_Poset(data["poset"])
    else:
        raise ValueError("Missing required field 'poset'")

    return P_F_Subposet(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        elements=field_elements,
        poset=field_poset,
    )


def load_P_F_UpperClosure(data: object) -> "P_F_UpperClosure":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_F_UpperClosure":
            raise ValueError(f"Expected 'P_F_UpperClosure', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_F_UpperClosure":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_F_UpperClosure', got {field_type_}")
    else:
        field_type_ = json.loads('"P_F_UpperClosure"')

    if "poset" in data:
        field_poset = load_Poset(data["poset"])
    else:
        raise ValueError("Missing required field 'poset'")

    if "us" in data:
        field_us = load_UpperSet(data["us"])
    else:
        raise ValueError("Missing required field 'us'")

    return P_F_UpperClosure(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        poset=field_poset,
        us=field_us,
    )


def load_P_Finite(data: object) -> "P_Finite":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_Finite":
            raise ValueError(f"Expected 'P_Finite', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_Finite":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_Finite', got {field_type_}")
    else:
        field_type_ = json.loads('"P_Finite"')

    if "aliases" in data:
        value = data["aliases"]
        if value is None:
            field_aliases = None
        else:
            field_aliases = load_dict_of_str_list_of_str(value)
    else:
        field_aliases = None

    if "elements" in data:
        field_elements = load_list_of_str(data["elements"])
    else:
        raise ValueError("Missing required field 'elements'")

    if "relations" in data:
        field_relations = load_list_of_list_of_str(data["relations"])
    else:
        raise ValueError("Missing required field 'relations'")

    return P_Finite(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        aliases=field_aliases,
        elements=field_elements,
        relations=field_relations,
    )


def load_P_Float(data: object) -> "P_Float":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_Float":
            raise ValueError(f"Expected 'P_Float', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_Float":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_Float', got {field_type_}")
    else:
        field_type_ = json.loads('"P_Float"')

    if "size" in data:
        field_size = load_enum_f8_f16_f32_f64_f80_f128(data["size"])
    else:
        raise ValueError("Missing required field 'size'")

    return P_Float(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        size=field_size,
    )


def load_P_Fractions(data: object) -> "P_Fractions":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_Fractions":
            raise ValueError(f"Expected 'P_Fractions', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_Fractions":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_Fractions', got {field_type_}")
    else:
        field_type_ = json.loads('"P_Fractions"')

    if "max_abs_denominator" in data:
        field_max_abs_denominator = load_int(data["max_abs_denominator"])
    else:
        raise ValueError("Missing required field 'max_abs_denominator'")

    if "max_abs_numerator" in data:
        field_max_abs_numerator = load_int(data["max_abs_numerator"])
    else:
        raise ValueError("Missing required field 'max_abs_numerator'")

    if "size" in data:
        field_size = load_enum_i8_i16_i32_i64_i128(data["size"])
    else:
        raise ValueError("Missing required field 'size'")

    return P_Fractions(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        max_abs_denominator=field_max_abs_denominator,
        max_abs_numerator=field_max_abs_numerator,
        size=field_size,
    )


def load_P_Integer(data: object) -> "P_Integer":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_Integer":
            raise ValueError(f"Expected 'P_Integer', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_Integer":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_Integer', got {field_type_}")
    else:
        field_type_ = json.loads('"P_Integer"')

    if "size" in data:
        field_size = load_enum_i8_i16_i32_i64_i128(data["size"])
    else:
        raise ValueError("Missing required field 'size'")

    return P_Integer(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        size=field_size,
    )


def load_P_Unknown(data: object) -> "P_Unknown":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Poset":
            raise ValueError(f"Expected 'Poset', got {field_kind}'")
        if field_kind is not None and field_kind != "Poset":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Poset', got {field_kind}")
    else:
        field_kind = json.loads('"Poset"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "P_Unknown":
            raise ValueError(f"Expected 'P_Unknown', got {field_type_}'")
        if field_type_ is not None and field_type_ != "P_Unknown":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'P_Unknown', got {field_type_}")
    else:
        field_type_ = json.loads('"P_Unknown"')

    return P_Unknown(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
    )


def load_Projection(data: object) -> "Projection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "index" in data:
        field_index = load_int(data["index"])
    else:
        raise ValueError("Missing required field 'index'")

    if "ntot" in data:
        field_ntot = load_int(data["ntot"])
    else:
        raise ValueError("Missing required field 'ntot'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "Projection":
            raise ValueError(f"Expected 'Projection', got {field_type_}'")
    else:
        raise ValueError("Missing required field 'type'")

    return Projection(
        index=field_index,
        ntot=field_ntot,
        type_=field_type_,
    )


def load_Query(data: object) -> "Query":
    """Load Query from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "Query_Single": load_Query_Single,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for Query")


def load_QueryData(data: object) -> "QueryData":
    """Load QueryData from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "QueryFixFunMinReqData": load_QueryFixFunMinReqData,
        "QueryFixReqMaxFunData": load_QueryFixReqMaxFunData,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for QueryData")


def load_QueryFixFunMinReqData(data: object) -> "QueryFixFunMinReqData":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "QueryFixFunMinReqData":
            raise ValueError(f"Expected 'QueryFixFunMinReqData', got {field_type_}'")
        if field_type_ is not None and field_type_ != "QueryFixFunMinReqData":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'QueryFixFunMinReqData', got {field_type_}")
    else:
        field_type_ = json.loads('"QueryFixFunMinReqData"')

    if "f" in data:
        value = data["f"]
        if value is None:
            field_f = None
        else:
            field_f = load_dict_of_str_Value(value)
    else:
        field_f = None

    if "optimize_for" in data:
        value = data["optimize_for"]
        if value is None:
            field_optimize_for = None
        else:
            field_optimize_for = load_list_of_str(value)
    else:
        field_optimize_for = None

    if "r" in data:
        value = data["r"]
        if value is None:
            field_r = None
        else:
            field_r = load_dict_of_str_Value(value)
    else:
        field_r = None

    return QueryFixFunMinReqData(
        type_=field_type_,
        f=field_f,
        optimize_for=field_optimize_for,
        r=field_r,
    )


def load_QueryFixReqMaxFunData(data: object) -> "QueryFixReqMaxFunData":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "QueryFixReqMaxFunData":
            raise ValueError(f"Expected 'QueryFixReqMaxFunData', got {field_type_}'")
        if field_type_ is not None and field_type_ != "QueryFixReqMaxFunData":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'QueryFixReqMaxFunData', got {field_type_}")
    else:
        field_type_ = json.loads('"QueryFixReqMaxFunData"')

    if "f" in data:
        value = data["f"]
        if value is None:
            field_f = None
        else:
            field_f = load_dict_of_str_Value(value)
    else:
        field_f = None

    if "optimize_for" in data:
        value = data["optimize_for"]
        if value is None:
            field_optimize_for = None
        else:
            field_optimize_for = load_list_of_str(value)
    else:
        field_optimize_for = None

    if "r" in data:
        value = data["r"]
        if value is None:
            field_r = None
        else:
            field_r = load_dict_of_str_Value(value)
    else:
        field_r = None

    return QueryFixReqMaxFunData(
        type_=field_type_,
        f=field_f,
        optimize_for=field_optimize_for,
        r=field_r,
    )


def load_Query_Single(data: object) -> "Query_Single":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Query":
            raise ValueError(f"Expected 'Query', got {field_kind}'")
        if field_kind is not None and field_kind != "Query":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Query', got {field_kind}")
    else:
        field_kind = json.loads('"Query"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "Query_Single":
            raise ValueError(f"Expected 'Query_Single', got {field_type_}'")
        if field_type_ is not None and field_type_ != "Query_Single":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'Query_Single', got {field_type_}")
    else:
        field_type_ = json.loads('"Query_Single"')

    if "model" in data:
        field_model = load_NDP(data["model"])
    else:
        raise ValueError("Missing required field 'model'")

    if "query_data" in data:
        field_query_data = load_QueryData(data["query_data"])
    else:
        raise ValueError("Missing required field 'query_data'")

    return Query_Single(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        model=field_model,
        query_data=field_query_data,
    )


def load_Range(data: object) -> "Range":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "ntot" in data:
        field_ntot = load_int(data["ntot"])
    else:
        raise ValueError("Missing required field 'ntot'")

    if "start" in data:
        field_start = load_int(data["start"])
    else:
        raise ValueError("Missing required field 'start'")

    if "stop" in data:
        field_stop = load_int(data["stop"])
    else:
        raise ValueError("Missing required field 'stop'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "Range":
            raise ValueError(f"Expected 'Range', got {field_type_}'")
    else:
        raise ValueError("Missing required field 'type'")

    return Range(
        ntot=field_ntot,
        start=field_start,
        stop=field_stop,
        type_=field_type_,
    )


def load_SL1Check(data: object) -> "SL1Check":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Check":
            raise ValueError(f"Expected 'Check', got {field_kind}'")
        if field_kind is not None and field_kind != "Check":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Check', got {field_kind}")
    else:
        field_kind = json.loads('"Check"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1Check":
            raise ValueError(f"Expected 'SL1Check', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1Check":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1Check', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1Check"')

    if "data" in data:
        field_data = load_list_of_SL1Check_Data(data["data"])
    else:
        raise ValueError("Missing required field 'data'")

    if "m" in data:
        field_m = load_SL1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SL1Check(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        type_=field_type_,
        data=field_data,
        m=field_m,
    )


def load_SL1Check_Data(data: object) -> "SL1Check_Data":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "opt" in data:
        field_opt = load_any(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "opt_elapsed" in data:
        value = data["opt_elapsed"]
        if value is None:
            field_opt_elapsed = None
        else:
            field_opt_elapsed = load_float(value)
    else:
        field_opt_elapsed = None

    if "opt_y" in data:
        field_opt_y = load_LowerSet(data["opt_y"])
    else:
        raise ValueError("Missing required field 'opt_y'")

    if "pess" in data:
        field_pess = load_any(data["pess"])
    else:
        raise ValueError("Missing required field 'pess'")

    if "pess_elapsed" in data:
        value = data["pess_elapsed"]
        if value is None:
            field_pess_elapsed = None
        else:
            field_pess_elapsed = load_float(value)
    else:
        field_pess_elapsed = None

    if "pess_y" in data:
        field_pess_y = load_LowerSet(data["pess_y"])
    else:
        raise ValueError("Missing required field 'pess_y'")

    if "x" in data:
        field_x = load_any(data["x"])
    else:
        raise ValueError("Missing required field 'x'")

    return SL1Check_Data(
        opt=field_opt,
        opt_elapsed=field_opt_elapsed,
        opt_y=field_opt_y,
        pess=field_pess,
        pess_elapsed=field_pess_elapsed,
        pess_y=field_pess_y,
        x=field_x,
    )


def load_SL1Map(data: object) -> "SL1Map":
    """Load SL1Map from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "SL1_C_CodSum": load_SL1_C_CodSum,
        "SL1_C_CodSumSmash": load_SL1_C_CodSumSmash,
        "SL1_C_ExplicitApprox": load_SL1_C_ExplicitApprox,
        "SL1_C_Intersection": load_SL1_C_Intersection,
        "SL1_C_Parallel": load_SL1_C_Parallel,
        "SL1_C_ProdIntersection": load_SL1_C_ProdIntersection,
        "SL1_C_Product": load_SL1_C_Product,
        "SL1_C_RefineDomain": load_SL1_C_RefineDomain,
        "SL1_C_Series": load_SL1_C_Series,
        "SL1_C_Trace": load_SL1_C_Trace,
        "SL1_C_Union": load_SL1_C_Union,
        "SL1_C_WrapUnits": load_SL1_C_WrapUnits,
        "SL1_Exact": load_SL1_Exact,
        "SL1_Identity": load_SL1_Identity,
        "SL1_InvMultiply": load_SL1_InvMultiply,
        "SL1_InvSum": load_SL1_InvSum,
        "SL1_Unknown": load_SL1_Unknown,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for SL1Map")


def load_SL1_C_CodSum(data: object) -> "SL1_C_CodSum":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_C_CodSum":
            raise ValueError(f"Expected 'SL1_C_CodSum', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_C_CodSum":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_C_CodSum', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_C_CodSum"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SL1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SL1_C_CodSum(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SL1_C_CodSumSmash(data: object) -> "SL1_C_CodSumSmash":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_C_CodSumSmash":
            raise ValueError(f"Expected 'SL1_C_CodSumSmash', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_C_CodSumSmash":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_C_CodSumSmash', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_C_CodSumSmash"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SL1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SL1_C_CodSumSmash(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SL1_C_ExplicitApprox(data: object) -> "SL1_C_ExplicitApprox":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_C_ExplicitApprox":
            raise ValueError(f"Expected 'SL1_C_ExplicitApprox', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_C_ExplicitApprox":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_C_ExplicitApprox', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_C_ExplicitApprox"')

    if "optimistic" in data:
        field_optimistic = load_list_of_L1Map(data["optimistic"])
    else:
        raise ValueError("Missing required field 'optimistic'")

    if "optimistic_labels" in data:
        value = data["optimistic_labels"]
        if value is None:
            field_optimistic_labels = None
        else:
            field_optimistic_labels = load_list_of_str(value)
    else:
        field_optimistic_labels = None

    if "pessimistic" in data:
        field_pessimistic = load_list_of_L1Map(data["pessimistic"])
    else:
        raise ValueError("Missing required field 'pessimistic'")

    if "pessimistic_labels" in data:
        value = data["pessimistic_labels"]
        if value is None:
            field_pessimistic_labels = None
        else:
            field_pessimistic_labels = load_list_of_str(value)
    else:
        field_pessimistic_labels = None

    return SL1_C_ExplicitApprox(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        optimistic=field_optimistic,
        optimistic_labels=field_optimistic_labels,
        pessimistic=field_pessimistic,
        pessimistic_labels=field_pessimistic_labels,
    )


def load_SL1_C_Intersection(data: object) -> "SL1_C_Intersection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_C_Intersection":
            raise ValueError(f"Expected 'SL1_C_Intersection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_C_Intersection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_C_Intersection', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_C_Intersection"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SL1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SL1_C_Intersection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SL1_C_Parallel(data: object) -> "SL1_C_Parallel":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_C_Parallel":
            raise ValueError(f"Expected 'SL1_C_Parallel', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_C_Parallel":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_C_Parallel', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_C_Parallel"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SL1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SL1_C_Parallel(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SL1_C_ProdIntersection(data: object) -> "SL1_C_ProdIntersection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_C_ProdIntersection":
            raise ValueError(f"Expected 'SL1_C_ProdIntersection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_C_ProdIntersection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_C_ProdIntersection', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_C_ProdIntersection"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SL1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SL1_C_ProdIntersection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SL1_C_Product(data: object) -> "SL1_C_Product":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_C_Product":
            raise ValueError(f"Expected 'SL1_C_Product', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_C_Product":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_C_Product', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_C_Product"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SL1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SL1_C_Product(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SL1_C_RefineDomain(data: object) -> "SL1_C_RefineDomain":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_C_RefineDomain":
            raise ValueError(f"Expected 'SL1_C_RefineDomain', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_C_RefineDomain":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_C_RefineDomain', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_C_RefineDomain"')

    if "m" in data:
        field_m = load_SL1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SL1_C_RefineDomain(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
    )


def load_SL1_C_Series(data: object) -> "SL1_C_Series":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_C_Series":
            raise ValueError(f"Expected 'SL1_C_Series', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_C_Series":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_C_Series', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_C_Series"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SL1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SL1_C_Series(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SL1_C_Trace(data: object) -> "SL1_C_Trace":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_C_Trace":
            raise ValueError(f"Expected 'SL1_C_Trace', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_C_Trace":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_C_Trace', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_C_Trace"')

    if "m" in data:
        field_m = load_SL1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SL1_C_Trace(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
    )


def load_SL1_C_Union(data: object) -> "SL1_C_Union":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_C_Union":
            raise ValueError(f"Expected 'SL1_C_Union', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_C_Union":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_C_Union', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_C_Union"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SL1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SL1_C_Union(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SL1_C_WrapUnits(data: object) -> "SL1_C_WrapUnits":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_C_WrapUnits":
            raise ValueError(f"Expected 'SL1_C_WrapUnits', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_C_WrapUnits":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_C_WrapUnits', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_C_WrapUnits"')

    if "kcod_units" in data:
        field_kcod_units = load_Unit(data["kcod_units"])
    else:
        raise ValueError("Missing required field 'kcod_units'")

    if "kdom_units" in data:
        field_kdom_units = load_Unit(data["kdom_units"])
    else:
        raise ValueError("Missing required field 'kdom_units'")

    if "m" in data:
        field_m = load_SL1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SL1_C_WrapUnits(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        kcod_units=field_kcod_units,
        kdom_units=field_kdom_units,
        m=field_m,
    )


def load_SL1_Exact(data: object) -> "SL1_Exact":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_Exact":
            raise ValueError(f"Expected 'SL1_Exact', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_Exact":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_Exact', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_Exact"')

    if "m" in data:
        field_m = load_L1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SL1_Exact(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
    )


def load_SL1_Identity(data: object) -> "SL1_Identity":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_Identity":
            raise ValueError(f"Expected 'SL1_Identity', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_Identity":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_Identity', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_Identity"')

    return SL1_Identity(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
    )


def load_SL1_InvMultiply(data: object) -> "SL1_InvMultiply":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_InvMultiply":
            raise ValueError(f"Expected 'SL1_InvMultiply', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_InvMultiply":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_InvMultiply', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_InvMultiply"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return SL1_InvMultiply(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        opspace=field_opspace,
    )


def load_SL1_InvSum(data: object) -> "SL1_InvSum":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_InvSum":
            raise ValueError(f"Expected 'SL1_InvSum', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_InvSum":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_InvSum', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_InvSum"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return SL1_InvSum(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        opspace=field_opspace,
    )


def load_SL1_Unknown(data: object) -> "SL1_Unknown":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SL1Map":
            raise ValueError(f"Expected 'SL1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SL1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SL1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SL1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL1_Unknown":
            raise ValueError(f"Expected 'SL1_Unknown', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL1_Unknown":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL1_Unknown', got {field_type_}")
    else:
        field_type_ = json.loads('"SL1_Unknown"')

    return SL1_Unknown(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
    )


def load_SLCheck(data: object) -> "SLCheck":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Check":
            raise ValueError(f"Expected 'Check', got {field_kind}'")
        if field_kind is not None and field_kind != "Check":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Check', got {field_kind}")
    else:
        field_kind = json.loads('"Check"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SLCheck":
            raise ValueError(f"Expected 'SLCheck', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SLCheck":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SLCheck', got {field_type_}")
    else:
        field_type_ = json.loads('"SLCheck"')

    if "data" in data:
        field_data = load_list_of_SLCheck_Data(data["data"])
    else:
        raise ValueError("Missing required field 'data'")

    if "m" in data:
        field_m = load_SLMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SLCheck(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        type_=field_type_,
        data=field_data,
        m=field_m,
    )


def load_SLCheck_Data(data: object) -> "SLCheck_Data":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "opt" in data:
        field_opt = load_any(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "opt_elapsed" in data:
        value = data["opt_elapsed"]
        if value is None:
            field_opt_elapsed = None
        else:
            field_opt_elapsed = load_float(value)
    else:
        field_opt_elapsed = None

    if "opt_y" in data:
        field_opt_y = load_LowerSet(data["opt_y"])
    else:
        raise ValueError("Missing required field 'opt_y'")

    if "pess" in data:
        field_pess = load_any(data["pess"])
    else:
        raise ValueError("Missing required field 'pess'")

    if "pess_elapsed" in data:
        value = data["pess_elapsed"]
        if value is None:
            field_pess_elapsed = None
        else:
            field_pess_elapsed = load_float(value)
    else:
        field_pess_elapsed = None

    if "pess_y" in data:
        field_pess_y = load_LowerSet(data["pess_y"])
    else:
        raise ValueError("Missing required field 'pess_y'")

    if "x" in data:
        field_x = load_any(data["x"])
    else:
        raise ValueError("Missing required field 'x'")

    return SLCheck_Data(
        opt=field_opt,
        opt_elapsed=field_opt_elapsed,
        opt_y=field_opt_y,
        pess=field_pess,
        pess_elapsed=field_pess_elapsed,
        pess_y=field_pess_y,
        x=field_x,
    )


def load_SLMap(data: object) -> "SLMap":
    """Load SLMap from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "SL_C_ITransform": load_SL_C_ITransform,
        "SL_C_Intersection": load_SL_C_Intersection,
        "SL_C_Parallel": load_SL_C_Parallel,
        "SL_C_RefineDomain": load_SL_C_RefineDomain,
        "SL_C_Series": load_SL_C_Series,
        "SL_C_Trace": load_SL_C_Trace,
        "SL_C_Union": load_SL_C_Union,
        "SL_C_WrapUnits": load_SL_C_WrapUnits,
        "SL_Identity": load_SL_Identity,
        "SL_L_Exact": load_SL_L_Exact,
        "SL_L_Explicit_Approx": load_SL_L_Explicit_Approx,
        "SL_L_Lift1_Constant": load_SL_L_Lift1_Constant,
        "SL_L_Lift1_Transform": load_SL_L_Lift1_Transform,
        "SL_Unknown": load_SL_Unknown,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for SLMap")


def load_SL_C_ITransform(data: object) -> "SL_C_ITransform":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SLMap":
            raise ValueError(f"Expected 'SLMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SLMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SLMap', got {field_kind}")
    else:
        field_kind = json.loads('"SLMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL_C_ITransform":
            raise ValueError(f"Expected 'SL_C_ITransform', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL_C_ITransform":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL_C_ITransform', got {field_type_}")
    else:
        field_type_ = json.loads('"SL_C_ITransform"')

    if "m" in data:
        field_m = load_SLMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "transform" in data:
        field_transform = load_MonotoneMap(data["transform"])
    else:
        raise ValueError("Missing required field 'transform'")

    return SL_C_ITransform(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
        transform=field_transform,
    )


def load_SL_C_Intersection(data: object) -> "SL_C_Intersection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SLMap":
            raise ValueError(f"Expected 'SLMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SLMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SLMap', got {field_kind}")
    else:
        field_kind = json.loads('"SLMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL_C_Intersection":
            raise ValueError(f"Expected 'SL_C_Intersection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL_C_Intersection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL_C_Intersection', got {field_type_}")
    else:
        field_type_ = json.loads('"SL_C_Intersection"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SLMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SL_C_Intersection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SL_C_Parallel(data: object) -> "SL_C_Parallel":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SLMap":
            raise ValueError(f"Expected 'SLMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SLMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SLMap', got {field_kind}")
    else:
        field_kind = json.loads('"SLMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL_C_Parallel":
            raise ValueError(f"Expected 'SL_C_Parallel', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL_C_Parallel":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL_C_Parallel', got {field_type_}")
    else:
        field_type_ = json.loads('"SL_C_Parallel"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SLMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SL_C_Parallel(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SL_C_RefineDomain(data: object) -> "SL_C_RefineDomain":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SLMap":
            raise ValueError(f"Expected 'SLMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SLMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SLMap', got {field_kind}")
    else:
        field_kind = json.loads('"SLMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL_C_RefineDomain":
            raise ValueError(f"Expected 'SL_C_RefineDomain', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL_C_RefineDomain":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL_C_RefineDomain', got {field_type_}")
    else:
        field_type_ = json.loads('"SL_C_RefineDomain"')

    if "m" in data:
        field_m = load_SLMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SL_C_RefineDomain(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
    )


def load_SL_C_Series(data: object) -> "SL_C_Series":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SLMap":
            raise ValueError(f"Expected 'SLMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SLMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SLMap', got {field_kind}")
    else:
        field_kind = json.loads('"SLMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL_C_Series":
            raise ValueError(f"Expected 'SL_C_Series', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL_C_Series":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL_C_Series', got {field_type_}")
    else:
        field_type_ = json.loads('"SL_C_Series"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SLMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SL_C_Series(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SL_C_Trace(data: object) -> "SL_C_Trace":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SLMap":
            raise ValueError(f"Expected 'SLMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SLMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SLMap', got {field_kind}")
    else:
        field_kind = json.loads('"SLMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL_C_Trace":
            raise ValueError(f"Expected 'SL_C_Trace', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL_C_Trace":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL_C_Trace', got {field_type_}")
    else:
        field_type_ = json.loads('"SL_C_Trace"')

    if "m" in data:
        field_m = load_SLMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "m_proj" in data:
        field_m_proj = load_SL1Map(data["m_proj"])
    else:
        raise ValueError("Missing required field 'm_proj'")

    return SL_C_Trace(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
        m_proj=field_m_proj,
    )


def load_SL_C_Union(data: object) -> "SL_C_Union":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SLMap":
            raise ValueError(f"Expected 'SLMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SLMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SLMap', got {field_kind}")
    else:
        field_kind = json.loads('"SLMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL_C_Union":
            raise ValueError(f"Expected 'SL_C_Union', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL_C_Union":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL_C_Union', got {field_type_}")
    else:
        field_type_ = json.loads('"SL_C_Union"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SLMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SL_C_Union(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SL_C_WrapUnits(data: object) -> "SL_C_WrapUnits":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SLMap":
            raise ValueError(f"Expected 'SLMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SLMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SLMap', got {field_kind}")
    else:
        field_kind = json.loads('"SLMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL_C_WrapUnits":
            raise ValueError(f"Expected 'SL_C_WrapUnits', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL_C_WrapUnits":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL_C_WrapUnits', got {field_type_}")
    else:
        field_type_ = json.loads('"SL_C_WrapUnits"')

    if "kcod_units" in data:
        field_kcod_units = load_Unit(data["kcod_units"])
    else:
        raise ValueError("Missing required field 'kcod_units'")

    if "kdom_units" in data:
        field_kdom_units = load_Unit(data["kdom_units"])
    else:
        raise ValueError("Missing required field 'kdom_units'")

    if "kimp_units" in data:
        field_kimp_units = load_Unit(data["kimp_units"])
    else:
        raise ValueError("Missing required field 'kimp_units'")

    if "m" in data:
        field_m = load_SLMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SL_C_WrapUnits(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        kcod_units=field_kcod_units,
        kdom_units=field_kdom_units,
        kimp_units=field_kimp_units,
        m=field_m,
    )


def load_SL_Identity(data: object) -> "SL_Identity":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SLMap":
            raise ValueError(f"Expected 'SLMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SLMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SLMap', got {field_kind}")
    else:
        field_kind = json.loads('"SLMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL_Identity":
            raise ValueError(f"Expected 'SL_Identity', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL_Identity":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL_Identity', got {field_type_}")
    else:
        field_type_ = json.loads('"SL_Identity"')

    return SL_Identity(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
    )


def load_SL_L_Exact(data: object) -> "SL_L_Exact":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SLMap":
            raise ValueError(f"Expected 'SLMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SLMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SLMap', got {field_kind}")
    else:
        field_kind = json.loads('"SLMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL_L_Exact":
            raise ValueError(f"Expected 'SL_L_Exact', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL_L_Exact":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL_L_Exact', got {field_type_}")
    else:
        field_type_ = json.loads('"SL_L_Exact"')

    if "m" in data:
        field_m = load_LMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SL_L_Exact(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
    )


def load_SL_L_Explicit_Approx(data: object) -> "SL_L_Explicit_Approx":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SLMap":
            raise ValueError(f"Expected 'SLMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SLMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SLMap', got {field_kind}")
    else:
        field_kind = json.loads('"SLMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL_L_Explicit_Approx":
            raise ValueError(f"Expected 'SL_L_Explicit_Approx', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL_L_Explicit_Approx":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL_L_Explicit_Approx', got {field_type_}")
    else:
        field_type_ = json.loads('"SL_L_Explicit_Approx"')

    if "optimistic" in data:
        field_optimistic = load_list_of_LMap(data["optimistic"])
    else:
        raise ValueError("Missing required field 'optimistic'")

    if "optimistic_labels" in data:
        value = data["optimistic_labels"]
        if value is None:
            field_optimistic_labels = None
        else:
            field_optimistic_labels = load_list_of_str(value)
    else:
        field_optimistic_labels = None

    if "pessimistic" in data:
        field_pessimistic = load_list_of_LMap(data["pessimistic"])
    else:
        raise ValueError("Missing required field 'pessimistic'")

    if "pessimistic_labels" in data:
        value = data["pessimistic_labels"]
        if value is None:
            field_pessimistic_labels = None
        else:
            field_pessimistic_labels = load_list_of_str(value)
    else:
        field_pessimistic_labels = None

    return SL_L_Explicit_Approx(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        optimistic=field_optimistic,
        optimistic_labels=field_optimistic_labels,
        pessimistic=field_pessimistic,
        pessimistic_labels=field_pessimistic_labels,
    )


def load_SL_L_Lift1_Constant(data: object) -> "SL_L_Lift1_Constant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SLMap":
            raise ValueError(f"Expected 'SLMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SLMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SLMap', got {field_kind}")
    else:
        field_kind = json.loads('"SLMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL_L_Lift1_Constant":
            raise ValueError(f"Expected 'SL_L_Lift1_Constant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL_L_Lift1_Constant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL_L_Lift1_Constant', got {field_type_}")
    else:
        field_type_ = json.loads('"SL_L_Lift1_Constant"')

    if "m" in data:
        field_m = load_SL1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "value" in data:
        field_value = load_any(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return SL_L_Lift1_Constant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
        value=field_value,
    )


def load_SL_L_Lift1_Transform(data: object) -> "SL_L_Lift1_Transform":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SLMap":
            raise ValueError(f"Expected 'SLMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SLMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SLMap', got {field_kind}")
    else:
        field_kind = json.loads('"SLMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL_L_Lift1_Transform":
            raise ValueError(f"Expected 'SL_L_Lift1_Transform', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL_L_Lift1_Transform":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL_L_Lift1_Transform', got {field_type_}")
    else:
        field_type_ = json.loads('"SL_L_Lift1_Transform"')

    if "m" in data:
        field_m = load_SL1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "transform" in data:
        field_transform = load_MonotoneMap(data["transform"])
    else:
        raise ValueError("Missing required field 'transform'")

    return SL_L_Lift1_Transform(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
        transform=field_transform,
    )


def load_SL_Unknown(data: object) -> "SL_Unknown":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SLMap":
            raise ValueError(f"Expected 'SLMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SLMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SLMap', got {field_kind}")
    else:
        field_kind = json.loads('"SLMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SL_Unknown":
            raise ValueError(f"Expected 'SL_Unknown', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SL_Unknown":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SL_Unknown', got {field_type_}")
    else:
        field_type_ = json.loads('"SL_Unknown"')

    return SL_Unknown(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
    )


def load_SU1Check(data: object) -> "SU1Check":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Check":
            raise ValueError(f"Expected 'Check', got {field_kind}'")
        if field_kind is not None and field_kind != "Check":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Check', got {field_kind}")
    else:
        field_kind = json.loads('"Check"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1Check":
            raise ValueError(f"Expected 'SU1Check', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1Check":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1Check', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1Check"')

    if "data" in data:
        field_data = load_list_of_SU1Check_Data(data["data"])
    else:
        raise ValueError("Missing required field 'data'")

    if "m" in data:
        field_m = load_SU1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SU1Check(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        type_=field_type_,
        data=field_data,
        m=field_m,
    )


def load_SU1Check_Data(data: object) -> "SU1Check_Data":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "opt" in data:
        field_opt = load_any(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "opt_elapsed" in data:
        value = data["opt_elapsed"]
        if value is None:
            field_opt_elapsed = None
        else:
            field_opt_elapsed = load_float(value)
    else:
        field_opt_elapsed = None

    if "opt_y" in data:
        field_opt_y = load_UpperSet(data["opt_y"])
    else:
        raise ValueError("Missing required field 'opt_y'")

    if "pess" in data:
        field_pess = load_any(data["pess"])
    else:
        raise ValueError("Missing required field 'pess'")

    if "pess_elapsed" in data:
        value = data["pess_elapsed"]
        if value is None:
            field_pess_elapsed = None
        else:
            field_pess_elapsed = load_float(value)
    else:
        field_pess_elapsed = None

    if "pess_y" in data:
        field_pess_y = load_UpperSet(data["pess_y"])
    else:
        raise ValueError("Missing required field 'pess_y'")

    if "x" in data:
        field_x = load_any(data["x"])
    else:
        raise ValueError("Missing required field 'x'")

    return SU1Check_Data(
        opt=field_opt,
        opt_elapsed=field_opt_elapsed,
        opt_y=field_opt_y,
        pess=field_pess,
        pess_elapsed=field_pess_elapsed,
        pess_y=field_pess_y,
        x=field_x,
    )


def load_SU1Map(data: object) -> "SU1Map":
    """Load SU1Map from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "SU1_C_CodSum": load_SU1_C_CodSum,
        "SU1_C_CodSumSmash": load_SU1_C_CodSumSmash,
        "SU1_C_ExplicitApprox": load_SU1_C_ExplicitApprox,
        "SU1_C_Intersection": load_SU1_C_Intersection,
        "SU1_C_Parallel": load_SU1_C_Parallel,
        "SU1_C_ProdIntersection": load_SU1_C_ProdIntersection,
        "SU1_C_Product": load_SU1_C_Product,
        "SU1_C_RefineDomain": load_SU1_C_RefineDomain,
        "SU1_C_Series": load_SU1_C_Series,
        "SU1_C_Trace": load_SU1_C_Trace,
        "SU1_C_Union": load_SU1_C_Union,
        "SU1_C_WrapUnits": load_SU1_C_WrapUnits,
        "SU1_Exact": load_SU1_Exact,
        "SU1_Identity": load_SU1_Identity,
        "SU1_InvMultiply": load_SU1_InvMultiply,
        "SU1_InvSum": load_SU1_InvSum,
        "SU1_Unknown": load_SU1_Unknown,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for SU1Map")


def load_SU1_C_CodSum(data: object) -> "SU1_C_CodSum":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_C_CodSum":
            raise ValueError(f"Expected 'SU1_C_CodSum', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_C_CodSum":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_C_CodSum', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_C_CodSum"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SU1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SU1_C_CodSum(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SU1_C_CodSumSmash(data: object) -> "SU1_C_CodSumSmash":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_C_CodSumSmash":
            raise ValueError(f"Expected 'SU1_C_CodSumSmash', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_C_CodSumSmash":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_C_CodSumSmash', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_C_CodSumSmash"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SU1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SU1_C_CodSumSmash(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SU1_C_ExplicitApprox(data: object) -> "SU1_C_ExplicitApprox":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_C_ExplicitApprox":
            raise ValueError(f"Expected 'SU1_C_ExplicitApprox', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_C_ExplicitApprox":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_C_ExplicitApprox', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_C_ExplicitApprox"')

    if "optimistic" in data:
        field_optimistic = load_list_of_U1Map(data["optimistic"])
    else:
        raise ValueError("Missing required field 'optimistic'")

    if "optimistic_labels" in data:
        value = data["optimistic_labels"]
        if value is None:
            field_optimistic_labels = None
        else:
            field_optimistic_labels = load_list_of_str(value)
    else:
        field_optimistic_labels = None

    if "pessimistic" in data:
        field_pessimistic = load_list_of_U1Map(data["pessimistic"])
    else:
        raise ValueError("Missing required field 'pessimistic'")

    if "pessimistic_labels" in data:
        value = data["pessimistic_labels"]
        if value is None:
            field_pessimistic_labels = None
        else:
            field_pessimistic_labels = load_list_of_str(value)
    else:
        field_pessimistic_labels = None

    return SU1_C_ExplicitApprox(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        optimistic=field_optimistic,
        optimistic_labels=field_optimistic_labels,
        pessimistic=field_pessimistic,
        pessimistic_labels=field_pessimistic_labels,
    )


def load_SU1_C_Intersection(data: object) -> "SU1_C_Intersection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_C_Intersection":
            raise ValueError(f"Expected 'SU1_C_Intersection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_C_Intersection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_C_Intersection', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_C_Intersection"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SU1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SU1_C_Intersection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SU1_C_Parallel(data: object) -> "SU1_C_Parallel":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_C_Parallel":
            raise ValueError(f"Expected 'SU1_C_Parallel', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_C_Parallel":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_C_Parallel', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_C_Parallel"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SU1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SU1_C_Parallel(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SU1_C_ProdIntersection(data: object) -> "SU1_C_ProdIntersection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_C_ProdIntersection":
            raise ValueError(f"Expected 'SU1_C_ProdIntersection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_C_ProdIntersection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_C_ProdIntersection', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_C_ProdIntersection"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SU1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SU1_C_ProdIntersection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SU1_C_Product(data: object) -> "SU1_C_Product":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_C_Product":
            raise ValueError(f"Expected 'SU1_C_Product', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_C_Product":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_C_Product', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_C_Product"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SU1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SU1_C_Product(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SU1_C_RefineDomain(data: object) -> "SU1_C_RefineDomain":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_C_RefineDomain":
            raise ValueError(f"Expected 'SU1_C_RefineDomain', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_C_RefineDomain":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_C_RefineDomain', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_C_RefineDomain"')

    if "m" in data:
        field_m = load_SU1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SU1_C_RefineDomain(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
    )


def load_SU1_C_Series(data: object) -> "SU1_C_Series":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_C_Series":
            raise ValueError(f"Expected 'SU1_C_Series', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_C_Series":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_C_Series', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_C_Series"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SU1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SU1_C_Series(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SU1_C_Trace(data: object) -> "SU1_C_Trace":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_C_Trace":
            raise ValueError(f"Expected 'SU1_C_Trace', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_C_Trace":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_C_Trace', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_C_Trace"')

    if "m" in data:
        field_m = load_SU1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SU1_C_Trace(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
    )


def load_SU1_C_Union(data: object) -> "SU1_C_Union":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_C_Union":
            raise ValueError(f"Expected 'SU1_C_Union', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_C_Union":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_C_Union', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_C_Union"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SU1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SU1_C_Union(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SU1_C_WrapUnits(data: object) -> "SU1_C_WrapUnits":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_C_WrapUnits":
            raise ValueError(f"Expected 'SU1_C_WrapUnits', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_C_WrapUnits":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_C_WrapUnits', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_C_WrapUnits"')

    if "kcod_units" in data:
        field_kcod_units = load_Unit(data["kcod_units"])
    else:
        raise ValueError("Missing required field 'kcod_units'")

    if "kdom_units" in data:
        field_kdom_units = load_Unit(data["kdom_units"])
    else:
        raise ValueError("Missing required field 'kdom_units'")

    if "m" in data:
        field_m = load_SU1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SU1_C_WrapUnits(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        kcod_units=field_kcod_units,
        kdom_units=field_kdom_units,
        m=field_m,
    )


def load_SU1_Exact(data: object) -> "SU1_Exact":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_Exact":
            raise ValueError(f"Expected 'SU1_Exact', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_Exact":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_Exact', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_Exact"')

    if "m" in data:
        field_m = load_U1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SU1_Exact(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
    )


def load_SU1_Identity(data: object) -> "SU1_Identity":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_Identity":
            raise ValueError(f"Expected 'SU1_Identity', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_Identity":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_Identity', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_Identity"')

    return SU1_Identity(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
    )


def load_SU1_InvMultiply(data: object) -> "SU1_InvMultiply":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_InvMultiply":
            raise ValueError(f"Expected 'SU1_InvMultiply', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_InvMultiply":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_InvMultiply', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_InvMultiply"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return SU1_InvMultiply(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        opspace=field_opspace,
    )


def load_SU1_InvSum(data: object) -> "SU1_InvSum":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_InvSum":
            raise ValueError(f"Expected 'SU1_InvSum', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_InvSum":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_InvSum', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_InvSum"')

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return SU1_InvSum(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        opspace=field_opspace,
    )


def load_SU1_Unknown(data: object) -> "SU1_Unknown":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SU1Map":
            raise ValueError(f"Expected 'SU1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "SU1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SU1Map', got {field_kind}")
    else:
        field_kind = json.loads('"SU1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU1_Unknown":
            raise ValueError(f"Expected 'SU1_Unknown', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU1_Unknown":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU1_Unknown', got {field_type_}")
    else:
        field_type_ = json.loads('"SU1_Unknown"')

    return SU1_Unknown(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
    )


def load_SUCheck(data: object) -> "SUCheck":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Check":
            raise ValueError(f"Expected 'Check', got {field_kind}'")
        if field_kind is not None and field_kind != "Check":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Check', got {field_kind}")
    else:
        field_kind = json.loads('"Check"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SUCheck":
            raise ValueError(f"Expected 'SUCheck', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SUCheck":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SUCheck', got {field_type_}")
    else:
        field_type_ = json.loads('"SUCheck"')

    if "data" in data:
        field_data = load_list_of_SUCheck_Data(data["data"])
    else:
        raise ValueError("Missing required field 'data'")

    if "m" in data:
        field_m = load_SUMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SUCheck(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        type_=field_type_,
        data=field_data,
        m=field_m,
    )


def load_SUCheck_Data(data: object) -> "SUCheck_Data":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "opt" in data:
        field_opt = load_any(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "opt_elapsed" in data:
        value = data["opt_elapsed"]
        if value is None:
            field_opt_elapsed = None
        else:
            field_opt_elapsed = load_float(value)
    else:
        field_opt_elapsed = None

    if "opt_y" in data:
        field_opt_y = load_UpperSet(data["opt_y"])
    else:
        raise ValueError("Missing required field 'opt_y'")

    if "pess" in data:
        field_pess = load_any(data["pess"])
    else:
        raise ValueError("Missing required field 'pess'")

    if "pess_elapsed" in data:
        value = data["pess_elapsed"]
        if value is None:
            field_pess_elapsed = None
        else:
            field_pess_elapsed = load_float(value)
    else:
        field_pess_elapsed = None

    if "pess_y" in data:
        field_pess_y = load_UpperSet(data["pess_y"])
    else:
        raise ValueError("Missing required field 'pess_y'")

    if "x" in data:
        field_x = load_any(data["x"])
    else:
        raise ValueError("Missing required field 'x'")

    return SUCheck_Data(
        opt=field_opt,
        opt_elapsed=field_opt_elapsed,
        opt_y=field_opt_y,
        pess=field_pess,
        pess_elapsed=field_pess_elapsed,
        pess_y=field_pess_y,
        x=field_x,
    )


def load_SUMap(data: object) -> "SUMap":
    """Load SUMap from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "SU_C_ITransform": load_SU_C_ITransform,
        "SU_C_Intersection": load_SU_C_Intersection,
        "SU_C_Parallel": load_SU_C_Parallel,
        "SU_C_RefineDomain": load_SU_C_RefineDomain,
        "SU_C_Series": load_SU_C_Series,
        "SU_C_Trace": load_SU_C_Trace,
        "SU_C_Union": load_SU_C_Union,
        "SU_C_WrapUnits": load_SU_C_WrapUnits,
        "SU_Identity": load_SU_Identity,
        "SU_L_Exact": load_SU_L_Exact,
        "SU_L_Explicit_Approx": load_SU_L_Explicit_Approx,
        "SU_L_Lift1_Constant": load_SU_L_Lift1_Constant,
        "SU_L_Lift1_Transform": load_SU_L_Lift1_Transform,
        "SU_Unknown": load_SU_Unknown,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for SUMap")


def load_SU_C_ITransform(data: object) -> "SU_C_ITransform":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SUMap":
            raise ValueError(f"Expected 'SUMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SUMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SUMap', got {field_kind}")
    else:
        field_kind = json.loads('"SUMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU_C_ITransform":
            raise ValueError(f"Expected 'SU_C_ITransform', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU_C_ITransform":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU_C_ITransform', got {field_type_}")
    else:
        field_type_ = json.loads('"SU_C_ITransform"')

    if "m" in data:
        field_m = load_SUMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "transform" in data:
        field_transform = load_MonotoneMap(data["transform"])
    else:
        raise ValueError("Missing required field 'transform'")

    return SU_C_ITransform(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
        transform=field_transform,
    )


def load_SU_C_Intersection(data: object) -> "SU_C_Intersection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SUMap":
            raise ValueError(f"Expected 'SUMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SUMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SUMap', got {field_kind}")
    else:
        field_kind = json.loads('"SUMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU_C_Intersection":
            raise ValueError(f"Expected 'SU_C_Intersection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU_C_Intersection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU_C_Intersection', got {field_type_}")
    else:
        field_type_ = json.loads('"SU_C_Intersection"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SUMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SU_C_Intersection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SU_C_Parallel(data: object) -> "SU_C_Parallel":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SUMap":
            raise ValueError(f"Expected 'SUMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SUMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SUMap', got {field_kind}")
    else:
        field_kind = json.loads('"SUMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU_C_Parallel":
            raise ValueError(f"Expected 'SU_C_Parallel', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU_C_Parallel":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU_C_Parallel', got {field_type_}")
    else:
        field_type_ = json.loads('"SU_C_Parallel"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SUMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SU_C_Parallel(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SU_C_RefineDomain(data: object) -> "SU_C_RefineDomain":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SUMap":
            raise ValueError(f"Expected 'SUMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SUMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SUMap', got {field_kind}")
    else:
        field_kind = json.loads('"SUMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU_C_RefineDomain":
            raise ValueError(f"Expected 'SU_C_RefineDomain', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU_C_RefineDomain":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU_C_RefineDomain', got {field_type_}")
    else:
        field_type_ = json.loads('"SU_C_RefineDomain"')

    if "m" in data:
        field_m = load_SUMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SU_C_RefineDomain(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
    )


def load_SU_C_Series(data: object) -> "SU_C_Series":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SUMap":
            raise ValueError(f"Expected 'SUMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SUMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SUMap', got {field_kind}")
    else:
        field_kind = json.loads('"SUMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU_C_Series":
            raise ValueError(f"Expected 'SU_C_Series', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU_C_Series":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU_C_Series', got {field_type_}")
    else:
        field_type_ = json.loads('"SU_C_Series"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SUMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SU_C_Series(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SU_C_Trace(data: object) -> "SU_C_Trace":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SUMap":
            raise ValueError(f"Expected 'SUMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SUMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SUMap', got {field_kind}")
    else:
        field_kind = json.loads('"SUMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU_C_Trace":
            raise ValueError(f"Expected 'SU_C_Trace', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU_C_Trace":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU_C_Trace', got {field_type_}")
    else:
        field_type_ = json.loads('"SU_C_Trace"')

    if "m" in data:
        field_m = load_SUMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "m_proj" in data:
        field_m_proj = load_SU1Map(data["m_proj"])
    else:
        raise ValueError("Missing required field 'm_proj'")

    return SU_C_Trace(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
        m_proj=field_m_proj,
    )


def load_SU_C_Union(data: object) -> "SU_C_Union":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SUMap":
            raise ValueError(f"Expected 'SUMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SUMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SUMap', got {field_kind}")
    else:
        field_kind = json.loads('"SUMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU_C_Union":
            raise ValueError(f"Expected 'SU_C_Union', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU_C_Union":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU_C_Union', got {field_type_}")
    else:
        field_type_ = json.loads('"SU_C_Union"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_SUMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return SU_C_Union(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_SU_C_WrapUnits(data: object) -> "SU_C_WrapUnits":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SUMap":
            raise ValueError(f"Expected 'SUMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SUMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SUMap', got {field_kind}")
    else:
        field_kind = json.loads('"SUMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU_C_WrapUnits":
            raise ValueError(f"Expected 'SU_C_WrapUnits', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU_C_WrapUnits":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU_C_WrapUnits', got {field_type_}")
    else:
        field_type_ = json.loads('"SU_C_WrapUnits"')

    if "kcod_units" in data:
        field_kcod_units = load_Unit(data["kcod_units"])
    else:
        raise ValueError("Missing required field 'kcod_units'")

    if "kdom_units" in data:
        field_kdom_units = load_Unit(data["kdom_units"])
    else:
        raise ValueError("Missing required field 'kdom_units'")

    if "kimp_units" in data:
        field_kimp_units = load_Unit(data["kimp_units"])
    else:
        raise ValueError("Missing required field 'kimp_units'")

    if "m" in data:
        field_m = load_SUMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SU_C_WrapUnits(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        kcod_units=field_kcod_units,
        kdom_units=field_kdom_units,
        kimp_units=field_kimp_units,
        m=field_m,
    )


def load_SU_Identity(data: object) -> "SU_Identity":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SUMap":
            raise ValueError(f"Expected 'SUMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SUMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SUMap', got {field_kind}")
    else:
        field_kind = json.loads('"SUMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU_Identity":
            raise ValueError(f"Expected 'SU_Identity', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU_Identity":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU_Identity', got {field_type_}")
    else:
        field_type_ = json.loads('"SU_Identity"')

    return SU_Identity(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
    )


def load_SU_L_Exact(data: object) -> "SU_L_Exact":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SUMap":
            raise ValueError(f"Expected 'SUMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SUMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SUMap', got {field_kind}")
    else:
        field_kind = json.loads('"SUMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU_L_Exact":
            raise ValueError(f"Expected 'SU_L_Exact', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU_L_Exact":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU_L_Exact', got {field_type_}")
    else:
        field_type_ = json.loads('"SU_L_Exact"')

    if "m" in data:
        field_m = load_UMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return SU_L_Exact(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
    )


def load_SU_L_Explicit_Approx(data: object) -> "SU_L_Explicit_Approx":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SUMap":
            raise ValueError(f"Expected 'SUMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SUMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SUMap', got {field_kind}")
    else:
        field_kind = json.loads('"SUMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU_L_Explicit_Approx":
            raise ValueError(f"Expected 'SU_L_Explicit_Approx', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU_L_Explicit_Approx":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU_L_Explicit_Approx', got {field_type_}")
    else:
        field_type_ = json.loads('"SU_L_Explicit_Approx"')

    if "optimistic" in data:
        field_optimistic = load_list_of_UMap(data["optimistic"])
    else:
        raise ValueError("Missing required field 'optimistic'")

    if "optimistic_labels" in data:
        value = data["optimistic_labels"]
        if value is None:
            field_optimistic_labels = None
        else:
            field_optimistic_labels = load_list_of_str(value)
    else:
        field_optimistic_labels = None

    if "pessimistic" in data:
        field_pessimistic = load_list_of_UMap(data["pessimistic"])
    else:
        raise ValueError("Missing required field 'pessimistic'")

    if "pessimistic_labels" in data:
        value = data["pessimistic_labels"]
        if value is None:
            field_pessimistic_labels = None
        else:
            field_pessimistic_labels = load_list_of_str(value)
    else:
        field_pessimistic_labels = None

    return SU_L_Explicit_Approx(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        optimistic=field_optimistic,
        optimistic_labels=field_optimistic_labels,
        pessimistic=field_pessimistic,
        pessimistic_labels=field_pessimistic_labels,
    )


def load_SU_L_Lift1_Constant(data: object) -> "SU_L_Lift1_Constant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SUMap":
            raise ValueError(f"Expected 'SUMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SUMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SUMap', got {field_kind}")
    else:
        field_kind = json.loads('"SUMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU_L_Lift1_Constant":
            raise ValueError(f"Expected 'SU_L_Lift1_Constant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU_L_Lift1_Constant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU_L_Lift1_Constant', got {field_type_}")
    else:
        field_type_ = json.loads('"SU_L_Lift1_Constant"')

    if "m" in data:
        field_m = load_SU1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "value" in data:
        field_value = load_any(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return SU_L_Lift1_Constant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
        value=field_value,
    )


def load_SU_L_Lift1_Transform(data: object) -> "SU_L_Lift1_Transform":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SUMap":
            raise ValueError(f"Expected 'SUMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SUMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SUMap', got {field_kind}")
    else:
        field_kind = json.loads('"SUMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU_L_Lift1_Transform":
            raise ValueError(f"Expected 'SU_L_Lift1_Transform', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU_L_Lift1_Transform":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU_L_Lift1_Transform', got {field_type_}")
    else:
        field_type_ = json.loads('"SU_L_Lift1_Transform"')

    if "m" in data:
        field_m = load_SU1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "transform" in data:
        field_transform = load_MonotoneMap(data["transform"])
    else:
        raise ValueError("Missing required field 'transform'")

    return SU_L_Lift1_Transform(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
        m=field_m,
        transform=field_transform,
    )


def load_SU_Unknown(data: object) -> "SU_Unknown":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "SUMap":
            raise ValueError(f"Expected 'SUMap', got {field_kind}'")
        if field_kind is not None and field_kind != "SUMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'SUMap', got {field_kind}")
    else:
        field_kind = json.loads('"SUMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "opt" in data:
        field_opt = load_Poset(data["opt"])
    else:
        raise ValueError("Missing required field 'opt'")

    if "pes" in data:
        field_pes = load_Poset(data["pes"])
    else:
        raise ValueError("Missing required field 'pes'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "SU_Unknown":
            raise ValueError(f"Expected 'SU_Unknown', got {field_type_}'")
        if field_type_ is not None and field_type_ != "SU_Unknown":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'SU_Unknown', got {field_type_}")
    else:
        field_type_ = json.loads('"SU_Unknown"')

    return SU_Unknown(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        opt=field_opt,
        pes=field_pes,
        type_=field_type_,
    )


def load_U1Check(data: object) -> "U1Check":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Check":
            raise ValueError(f"Expected 'Check', got {field_kind}'")
        if field_kind is not None and field_kind != "Check":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Check', got {field_kind}")
    else:
        field_kind = json.loads('"Check"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1Check":
            raise ValueError(f"Expected 'U1Check', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1Check":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1Check', got {field_type_}")
    else:
        field_type_ = json.loads('"U1Check"')

    if "data" in data:
        field_data = load_list_of_U1Check_Data(data["data"])
    else:
        raise ValueError("Missing required field 'data'")

    if "m" in data:
        field_m = load_U1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return U1Check(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        type_=field_type_,
        data=field_data,
        m=field_m,
    )


def load_U1Check_Data(data: object) -> "U1Check_Data":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "elapsed" in data:
        value = data["elapsed"]
        if value is None:
            field_elapsed = None
        else:
            field_elapsed = load_float(value)
    else:
        field_elapsed = None

    if "x" in data:
        field_x = load_any(data["x"])
    else:
        raise ValueError("Missing required field 'x'")

    if "y" in data:
        field_y = load_UpperSet(data["y"])
    else:
        raise ValueError("Missing required field 'y'")

    return U1Check_Data(
        elapsed=field_elapsed,
        x=field_x,
        y=field_y,
    )


def load_U1Map(data: object) -> "U1Map":
    """Load U1Map from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "U1_C_CodSum": load_U1_C_CodSum,
        "U1_C_CodSumSmash": load_U1_C_CodSumSmash,
        "U1_C_DomUnion": load_U1_C_DomUnion,
        "U1_C_Intersection": load_U1_C_Intersection,
        "U1_C_Parallel": load_U1_C_Parallel,
        "U1_C_ProdIntersection": load_U1_C_ProdIntersection,
        "U1_C_Product": load_U1_C_Product,
        "U1_C_RefineDomain": load_U1_C_RefineDomain,
        "U1_C_Series": load_U1_C_Series,
        "U1_C_Trace": load_U1_C_Trace,
        "U1_C_Union": load_U1_C_Union,
        "U1_C_WrapUnits": load_U1_C_WrapUnits,
        "U1_Catalog": load_U1_Catalog,
        "U1_Constant": load_U1_Constant,
        "U1_Entire": load_U1_Entire,
        "U1_Explicit": load_U1_Explicit,
        "U1_FromFilter": load_U1_FromFilter,
        "U1_Identity": load_U1_Identity,
        "U1_IntersectionOfPrinUpperSets": load_U1_IntersectionOfPrinUpperSets,
        "U1_InvMul_Opt": load_U1_InvMul_Opt,
        "U1_InvMul_Pes": load_U1_InvMul_Pes,
        "U1_InvSum_Opt": load_U1_InvSum_Opt,
        "U1_InvSum_Pes": load_U1_InvSum_Pes,
        "U1_L_Uinv": load_U1_L_Uinv,
        "U1_Lift": load_U1_Lift,
        "U1_RepresentPrincipalUpperSet": load_U1_RepresentPrincipalUpperSet,
        "U1_Uinv_Join": load_U1_Uinv_Join,
        "U1_Uinv_JoinConstant": load_U1_Uinv_JoinConstant,
        "U1_UnionOfPrinUpperSets": load_U1_UnionOfPrinUpperSets,
        "U1_Unknown": load_U1_Unknown,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for U1Map")


def load_U1_C_CodSum(data: object) -> "U1_C_CodSum":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_C_CodSum":
            raise ValueError(f"Expected 'U1_C_CodSum', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_C_CodSum":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_C_CodSum', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_C_CodSum"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_U1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return U1_C_CodSum(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_U1_C_CodSumSmash(data: object) -> "U1_C_CodSumSmash":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_C_CodSumSmash":
            raise ValueError(f"Expected 'U1_C_CodSumSmash', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_C_CodSumSmash":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_C_CodSumSmash', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_C_CodSumSmash"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_U1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return U1_C_CodSumSmash(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_U1_C_DomUnion(data: object) -> "U1_C_DomUnion":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_C_DomUnion":
            raise ValueError(f"Expected 'U1_C_DomUnion', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_C_DomUnion":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_C_DomUnion', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_C_DomUnion"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_U1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return U1_C_DomUnion(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_U1_C_Intersection(data: object) -> "U1_C_Intersection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_C_Intersection":
            raise ValueError(f"Expected 'U1_C_Intersection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_C_Intersection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_C_Intersection', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_C_Intersection"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_U1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return U1_C_Intersection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_U1_C_Parallel(data: object) -> "U1_C_Parallel":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_C_Parallel":
            raise ValueError(f"Expected 'U1_C_Parallel', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_C_Parallel":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_C_Parallel', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_C_Parallel"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_U1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return U1_C_Parallel(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_U1_C_ProdIntersection(data: object) -> "U1_C_ProdIntersection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_C_ProdIntersection":
            raise ValueError(f"Expected 'U1_C_ProdIntersection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_C_ProdIntersection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_C_ProdIntersection', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_C_ProdIntersection"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_U1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return U1_C_ProdIntersection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_U1_C_Product(data: object) -> "U1_C_Product":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_C_Product":
            raise ValueError(f"Expected 'U1_C_Product', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_C_Product":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_C_Product', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_C_Product"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_U1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return U1_C_Product(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_U1_C_RefineDomain(data: object) -> "U1_C_RefineDomain":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_C_RefineDomain":
            raise ValueError(f"Expected 'U1_C_RefineDomain', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_C_RefineDomain":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_C_RefineDomain', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_C_RefineDomain"')

    if "m" in data:
        field_m = load_U1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return U1_C_RefineDomain(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        m=field_m,
    )


def load_U1_C_Series(data: object) -> "U1_C_Series":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_C_Series":
            raise ValueError(f"Expected 'U1_C_Series', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_C_Series":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_C_Series', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_C_Series"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_U1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return U1_C_Series(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_U1_C_Trace(data: object) -> "U1_C_Trace":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_C_Trace":
            raise ValueError(f"Expected 'U1_C_Trace', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_C_Trace":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_C_Trace', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_C_Trace"')

    if "m" in data:
        field_m = load_U1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return U1_C_Trace(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        m=field_m,
    )


def load_U1_C_Union(data: object) -> "U1_C_Union":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_C_Union":
            raise ValueError(f"Expected 'U1_C_Union', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_C_Union":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_C_Union', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_C_Union"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_U1Map(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return U1_C_Union(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_U1_C_WrapUnits(data: object) -> "U1_C_WrapUnits":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_C_WrapUnits":
            raise ValueError(f"Expected 'U1_C_WrapUnits', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_C_WrapUnits":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_C_WrapUnits', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_C_WrapUnits"')

    if "kcod_units" in data:
        field_kcod_units = load_Unit(data["kcod_units"])
    else:
        raise ValueError("Missing required field 'kcod_units'")

    if "kdom_units" in data:
        field_kdom_units = load_Unit(data["kdom_units"])
    else:
        raise ValueError("Missing required field 'kdom_units'")

    if "m" in data:
        field_m = load_U1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return U1_C_WrapUnits(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        kcod_units=field_kcod_units,
        kdom_units=field_kdom_units,
        m=field_m,
    )


def load_U1_Catalog(data: object) -> "U1_Catalog":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_Catalog":
            raise ValueError(f"Expected 'U1_Catalog', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_Catalog":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_Catalog', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_Catalog"')

    if "options" in data:
        field_options = load_list_of_U1_Catalog_Options(data["options"])
    else:
        raise ValueError("Missing required field 'options'")

    return U1_Catalog(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        options=field_options,
    )


def load_U1_Catalog_Options(data: object) -> "U1_Catalog_Options":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "f" in data:
        field_f = load_any(data["f"])
    else:
        raise ValueError("Missing required field 'f'")

    if "r" in data:
        field_r = load_any(data["r"])
    else:
        raise ValueError("Missing required field 'r'")

    return U1_Catalog_Options(
        f=field_f,
        r=field_r,
    )


def load_U1_Constant(data: object) -> "U1_Constant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_Constant":
            raise ValueError(f"Expected 'U1_Constant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_Constant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_Constant', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_Constant"')

    if "value" in data:
        field_value = load_UpperSet(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return U1_Constant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        value=field_value,
    )


def load_U1_Entire(data: object) -> "U1_Entire":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_Entire":
            raise ValueError(f"Expected 'U1_Entire', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_Entire":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_Entire', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_Entire"')

    return U1_Entire(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
    )


def load_U1_Explicit(data: object) -> "U1_Explicit":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_Explicit":
            raise ValueError(f"Expected 'U1_Explicit', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_Explicit":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_Explicit', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_Explicit"')

    if "options" in data:
        field_options = load_list_of_U1_Explicit_Option(data["options"])
    else:
        raise ValueError("Missing required field 'options'")

    return U1_Explicit(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        options=field_options,
    )


def load_U1_Explicit_Option(data: object) -> "U1_Explicit_Option":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "x" in data:
        field_x = load_any(data["x"])
    else:
        raise ValueError("Missing required field 'x'")

    if "y" in data:
        field_y = load_UpperSet(data["y"])
    else:
        raise ValueError("Missing required field 'y'")

    return U1_Explicit_Option(
        x=field_x,
        y=field_y,
    )


def load_U1_FromFilter(data: object) -> "U1_FromFilter":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_FromFilter":
            raise ValueError(f"Expected 'U1_FromFilter', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_FromFilter":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_FromFilter', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_FromFilter"')

    if "m" in data:
        field_m = load_MonotoneMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return U1_FromFilter(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        m=field_m,
    )


def load_U1_Identity(data: object) -> "U1_Identity":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_Identity":
            raise ValueError(f"Expected 'U1_Identity', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_Identity":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_Identity', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_Identity"')

    return U1_Identity(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
    )


def load_U1_IntersectionOfPrinUpperSets(data: object) -> "U1_IntersectionOfPrinUpperSets":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_IntersectionOfPrinUpperSets":
            raise ValueError(f"Expected 'U1_IntersectionOfPrinUpperSets', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_IntersectionOfPrinUpperSets":
            raise ValueError(
                f"Invalid discriminator value for 'type': expected 'U1_IntersectionOfPrinUpperSets', got {field_type_}"
            )
    else:
        field_type_ = json.loads('"U1_IntersectionOfPrinUpperSets"')

    return U1_IntersectionOfPrinUpperSets(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
    )


def load_U1_InvMul_Opt(data: object) -> "U1_InvMul_Opt":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_InvMul_Opt":
            raise ValueError(f"Expected 'U1_InvMul_Opt', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_InvMul_Opt":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_InvMul_Opt', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_InvMul_Opt"')

    if "n" in data:
        field_n = load_int(data["n"])
    else:
        raise ValueError("Missing required field 'n'")

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return U1_InvMul_Opt(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        n=field_n,
        opspace=field_opspace,
    )


def load_U1_InvMul_Pes(data: object) -> "U1_InvMul_Pes":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_InvMul_Pes":
            raise ValueError(f"Expected 'U1_InvMul_Pes', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_InvMul_Pes":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_InvMul_Pes', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_InvMul_Pes"')

    if "n" in data:
        field_n = load_int(data["n"])
    else:
        raise ValueError("Missing required field 'n'")

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return U1_InvMul_Pes(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        n=field_n,
        opspace=field_opspace,
    )


def load_U1_InvSum_Opt(data: object) -> "U1_InvSum_Opt":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_InvSum_Opt":
            raise ValueError(f"Expected 'U1_InvSum_Opt', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_InvSum_Opt":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_InvSum_Opt', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_InvSum_Opt"')

    if "n" in data:
        field_n = load_int(data["n"])
    else:
        raise ValueError("Missing required field 'n'")

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return U1_InvSum_Opt(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        n=field_n,
        opspace=field_opspace,
    )


def load_U1_InvSum_Pes(data: object) -> "U1_InvSum_Pes":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_InvSum_Pes":
            raise ValueError(f"Expected 'U1_InvSum_Pes', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_InvSum_Pes":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_InvSum_Pes', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_InvSum_Pes"')

    if "n" in data:
        field_n = load_int(data["n"])
    else:
        raise ValueError("Missing required field 'n'")

    if "opspace" in data:
        field_opspace = load_Poset(data["opspace"])
    else:
        raise ValueError("Missing required field 'opspace'")

    return U1_InvSum_Pes(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        n=field_n,
        opspace=field_opspace,
    )


def load_U1_L_Uinv(data: object) -> "U1_L_Uinv":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_L_Uinv":
            raise ValueError(f"Expected 'U1_L_Uinv', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_L_Uinv":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_L_Uinv', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_L_Uinv"')

    if "m" in data:
        field_m = load_MonotoneMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return U1_L_Uinv(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        m=field_m,
    )


def load_U1_Lift(data: object) -> "U1_Lift":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_Lift":
            raise ValueError(f"Expected 'U1_Lift', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_Lift":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_Lift', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_Lift"')

    if "m" in data:
        field_m = load_MonotoneMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return U1_Lift(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        m=field_m,
    )


def load_U1_RepresentPrincipalUpperSet(data: object) -> "U1_RepresentPrincipalUpperSet":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_RepresentPrincipalUpperSet":
            raise ValueError(f"Expected 'U1_RepresentPrincipalUpperSet', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_RepresentPrincipalUpperSet":
            raise ValueError(
                f"Invalid discriminator value for 'type': expected 'U1_RepresentPrincipalUpperSet', got {field_type_}"
            )
    else:
        field_type_ = json.loads('"U1_RepresentPrincipalUpperSet"')

    return U1_RepresentPrincipalUpperSet(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
    )


def load_U1_Uinv_Join(data: object) -> "U1_Uinv_Join":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_Uinv_Join":
            raise ValueError(f"Expected 'U1_Uinv_Join', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_Uinv_Join":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_Uinv_Join', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_Uinv_Join"')

    if "lower_bounds" in data:
        field_lower_bounds = load_list_of_list_of_any(data["lower_bounds"])
    else:
        raise ValueError("Missing required field 'lower_bounds'")

    return U1_Uinv_Join(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        lower_bounds=field_lower_bounds,
    )


def load_U1_Uinv_JoinConstant(data: object) -> "U1_Uinv_JoinConstant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_Uinv_JoinConstant":
            raise ValueError(f"Expected 'U1_Uinv_JoinConstant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_Uinv_JoinConstant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_Uinv_JoinConstant', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_Uinv_JoinConstant"')

    if "join1_dom" in data:
        field_join1_dom = load_Poset(data["join1_dom"])
    else:
        raise ValueError("Missing required field 'join1_dom'")

    if "value" in data:
        field_value = load_Value(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return U1_Uinv_JoinConstant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
        join1_dom=field_join1_dom,
        value=field_value,
    )


def load_U1_UnionOfPrinUpperSets(data: object) -> "U1_UnionOfPrinUpperSets":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_UnionOfPrinUpperSets":
            raise ValueError(f"Expected 'U1_UnionOfPrinUpperSets', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_UnionOfPrinUpperSets":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_UnionOfPrinUpperSets', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_UnionOfPrinUpperSets"')

    return U1_UnionOfPrinUpperSets(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
    )


def load_U1_Unknown(data: object) -> "U1_Unknown":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "U1Map":
            raise ValueError(f"Expected 'U1Map', got {field_kind}'")
        if field_kind is not None and field_kind != "U1Map":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'U1Map', got {field_kind}")
    else:
        field_kind = json.loads('"U1Map"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U1_Unknown":
            raise ValueError(f"Expected 'U1_Unknown', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U1_Unknown":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U1_Unknown', got {field_type_}")
    else:
        field_type_ = json.loads('"U1_Unknown"')

    return U1_Unknown(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        type_=field_type_,
    )


def load_UCheck(data: object) -> "UCheck":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Check":
            raise ValueError(f"Expected 'Check', got {field_kind}'")
        if field_kind is not None and field_kind != "Check":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Check', got {field_kind}")
    else:
        field_kind = json.loads('"Check"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "UCheck":
            raise ValueError(f"Expected 'UCheck', got {field_type_}'")
        if field_type_ is not None and field_type_ != "UCheck":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'UCheck', got {field_type_}")
    else:
        field_type_ = json.loads('"UCheck"')

    if "data" in data:
        field_data = load_list_of_UCheck_Data(data["data"])
    else:
        raise ValueError("Missing required field 'data'")

    if "m" in data:
        field_m = load_UMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return UCheck(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        type_=field_type_,
        data=field_data,
        m=field_m,
    )


def load_UCheck_Data(data: object) -> "UCheck_Data":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "elapsed" in data:
        value = data["elapsed"]
        if value is None:
            field_elapsed = None
        else:
            field_elapsed = load_float(value)
    else:
        field_elapsed = None

    if "x" in data:
        field_x = load_any(data["x"])
    else:
        raise ValueError("Missing required field 'x'")

    if "y" in data:
        field_y = load_UpperSet(data["y"])
    else:
        raise ValueError("Missing required field 'y'")

    return UCheck_Data(
        elapsed=field_elapsed,
        x=field_x,
        y=field_y,
    )


def load_UMap(data: object) -> "UMap":
    """Load UMap from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "U_C_ITransform": load_U_C_ITransform,
        "U_C_Intersection": load_U_C_Intersection,
        "U_C_Parallel": load_U_C_Parallel,
        "U_C_RefineDomain": load_U_C_RefineDomain,
        "U_C_Series": load_U_C_Series,
        "U_C_Trace": load_U_C_Trace,
        "U_C_Union": load_U_C_Union,
        "U_C_WrapUnits": load_U_C_WrapUnits,
        "U_Catalog": load_U_Catalog,
        "U_Constant": load_U_Constant,
        "U_Identity": load_U_Identity,
        "U_L_Lift1_Constant": load_U_L_Lift1_Constant,
        "U_L_Lift1_Transform": load_U_L_Lift1_Transform,
        "U_Unknown": load_U_Unknown,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for UMap")


def load_U_C_ITransform(data: object) -> "U_C_ITransform":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UMap":
            raise ValueError(f"Expected 'UMap', got {field_kind}'")
        if field_kind is not None and field_kind != "UMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'UMap', got {field_kind}")
    else:
        field_kind = json.loads('"UMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U_C_ITransform":
            raise ValueError(f"Expected 'U_C_ITransform', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U_C_ITransform":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U_C_ITransform', got {field_type_}")
    else:
        field_type_ = json.loads('"U_C_ITransform"')

    if "m" in data:
        field_m = load_UMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "transform" in data:
        field_transform = load_MonotoneMap(data["transform"])
    else:
        raise ValueError("Missing required field 'transform'")

    return U_C_ITransform(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        m=field_m,
        transform=field_transform,
    )


def load_U_C_Intersection(data: object) -> "U_C_Intersection":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UMap":
            raise ValueError(f"Expected 'UMap', got {field_kind}'")
        if field_kind is not None and field_kind != "UMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'UMap', got {field_kind}")
    else:
        field_kind = json.loads('"UMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U_C_Intersection":
            raise ValueError(f"Expected 'U_C_Intersection', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U_C_Intersection":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U_C_Intersection', got {field_type_}")
    else:
        field_type_ = json.loads('"U_C_Intersection"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_UMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return U_C_Intersection(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_U_C_Parallel(data: object) -> "U_C_Parallel":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UMap":
            raise ValueError(f"Expected 'UMap', got {field_kind}'")
        if field_kind is not None and field_kind != "UMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'UMap', got {field_kind}")
    else:
        field_kind = json.loads('"UMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U_C_Parallel":
            raise ValueError(f"Expected 'U_C_Parallel', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U_C_Parallel":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U_C_Parallel', got {field_type_}")
    else:
        field_type_ = json.loads('"U_C_Parallel"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_UMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return U_C_Parallel(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_U_C_RefineDomain(data: object) -> "U_C_RefineDomain":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UMap":
            raise ValueError(f"Expected 'UMap', got {field_kind}'")
        if field_kind is not None and field_kind != "UMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'UMap', got {field_kind}")
    else:
        field_kind = json.loads('"UMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U_C_RefineDomain":
            raise ValueError(f"Expected 'U_C_RefineDomain', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U_C_RefineDomain":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U_C_RefineDomain', got {field_type_}")
    else:
        field_type_ = json.loads('"U_C_RefineDomain"')

    if "m" in data:
        field_m = load_UMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return U_C_RefineDomain(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        m=field_m,
    )


def load_U_C_Series(data: object) -> "U_C_Series":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UMap":
            raise ValueError(f"Expected 'UMap', got {field_kind}'")
        if field_kind is not None and field_kind != "UMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'UMap', got {field_kind}")
    else:
        field_kind = json.loads('"UMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U_C_Series":
            raise ValueError(f"Expected 'U_C_Series', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U_C_Series":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U_C_Series', got {field_type_}")
    else:
        field_type_ = json.loads('"U_C_Series"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_UMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return U_C_Series(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_U_C_Trace(data: object) -> "U_C_Trace":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UMap":
            raise ValueError(f"Expected 'UMap', got {field_kind}'")
        if field_kind is not None and field_kind != "UMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'UMap', got {field_kind}")
    else:
        field_kind = json.loads('"UMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U_C_Trace":
            raise ValueError(f"Expected 'U_C_Trace', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U_C_Trace":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U_C_Trace', got {field_type_}")
    else:
        field_type_ = json.loads('"U_C_Trace"')

    if "m" in data:
        field_m = load_UMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "m_proj" in data:
        field_m_proj = load_U1Map(data["m_proj"])
    else:
        raise ValueError("Missing required field 'm_proj'")

    return U_C_Trace(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        m=field_m,
        m_proj=field_m_proj,
    )


def load_U_C_Union(data: object) -> "U_C_Union":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UMap":
            raise ValueError(f"Expected 'UMap', got {field_kind}'")
        if field_kind is not None and field_kind != "UMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'UMap', got {field_kind}")
    else:
        field_kind = json.loads('"UMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U_C_Union":
            raise ValueError(f"Expected 'U_C_Union', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U_C_Union":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U_C_Union', got {field_type_}")
    else:
        field_type_ = json.loads('"U_C_Union"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "ms" in data:
        field_ms = load_list_of_UMap(data["ms"])
    else:
        raise ValueError("Missing required field 'ms'")

    return U_C_Union(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        labels=field_labels,
        ms=field_ms,
    )


def load_U_C_WrapUnits(data: object) -> "U_C_WrapUnits":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UMap":
            raise ValueError(f"Expected 'UMap', got {field_kind}'")
        if field_kind is not None and field_kind != "UMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'UMap', got {field_kind}")
    else:
        field_kind = json.loads('"UMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U_C_WrapUnits":
            raise ValueError(f"Expected 'U_C_WrapUnits', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U_C_WrapUnits":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U_C_WrapUnits', got {field_type_}")
    else:
        field_type_ = json.loads('"U_C_WrapUnits"')

    if "kcod_units" in data:
        field_kcod_units = load_Unit(data["kcod_units"])
    else:
        raise ValueError("Missing required field 'kcod_units'")

    if "kdom_units" in data:
        field_kdom_units = load_Unit(data["kdom_units"])
    else:
        raise ValueError("Missing required field 'kdom_units'")

    if "kimp_units" in data:
        field_kimp_units = load_Unit(data["kimp_units"])
    else:
        raise ValueError("Missing required field 'kimp_units'")

    if "m" in data:
        field_m = load_UMap(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    return U_C_WrapUnits(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        kcod_units=field_kcod_units,
        kdom_units=field_kdom_units,
        kimp_units=field_kimp_units,
        m=field_m,
    )


def load_U_Catalog(data: object) -> "U_Catalog":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UMap":
            raise ValueError(f"Expected 'UMap', got {field_kind}'")
        if field_kind is not None and field_kind != "UMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'UMap', got {field_kind}")
    else:
        field_kind = json.loads('"UMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U_Catalog":
            raise ValueError(f"Expected 'U_Catalog', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U_Catalog":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U_Catalog', got {field_type_}")
    else:
        field_type_ = json.loads('"U_Catalog"')

    if "options" in data:
        field_options = load_list_of_U_Catalog_Options(data["options"])
    else:
        raise ValueError("Missing required field 'options'")

    return U_Catalog(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        options=field_options,
    )


def load_U_Catalog_Options(data: object) -> "U_Catalog_Options":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "f" in data:
        field_f = load_any(data["f"])
    else:
        raise ValueError("Missing required field 'f'")

    if "i" in data:
        field_i = load_any(data["i"])
    else:
        raise ValueError("Missing required field 'i'")

    if "r" in data:
        field_r = load_any(data["r"])
    else:
        raise ValueError("Missing required field 'r'")

    return U_Catalog_Options(
        f=field_f,
        i=field_i,
        r=field_r,
    )


def load_U_Constant(data: object) -> "U_Constant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UMap":
            raise ValueError(f"Expected 'UMap', got {field_kind}'")
        if field_kind is not None and field_kind != "UMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'UMap', got {field_kind}")
    else:
        field_kind = json.loads('"UMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U_Constant":
            raise ValueError(f"Expected 'U_Constant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U_Constant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U_Constant', got {field_type_}")
    else:
        field_type_ = json.loads('"U_Constant"')

    if "value" in data:
        field_value = load_UpperSet(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return U_Constant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        value=field_value,
    )


def load_U_Identity(data: object) -> "U_Identity":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UMap":
            raise ValueError(f"Expected 'UMap', got {field_kind}'")
        if field_kind is not None and field_kind != "UMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'UMap', got {field_kind}")
    else:
        field_kind = json.loads('"UMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U_Identity":
            raise ValueError(f"Expected 'U_Identity', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U_Identity":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U_Identity', got {field_type_}")
    else:
        field_type_ = json.loads('"U_Identity"')

    return U_Identity(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
    )


def load_U_L_Lift1_Constant(data: object) -> "U_L_Lift1_Constant":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UMap":
            raise ValueError(f"Expected 'UMap', got {field_kind}'")
        if field_kind is not None and field_kind != "UMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'UMap', got {field_kind}")
    else:
        field_kind = json.loads('"UMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U_L_Lift1_Constant":
            raise ValueError(f"Expected 'U_L_Lift1_Constant', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U_L_Lift1_Constant":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U_L_Lift1_Constant', got {field_type_}")
    else:
        field_type_ = json.loads('"U_L_Lift1_Constant"')

    if "m" in data:
        field_m = load_U1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "value" in data:
        field_value = load_any(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return U_L_Lift1_Constant(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        m=field_m,
        value=field_value,
    )


def load_U_L_Lift1_Transform(data: object) -> "U_L_Lift1_Transform":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UMap":
            raise ValueError(f"Expected 'UMap', got {field_kind}'")
        if field_kind is not None and field_kind != "UMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'UMap', got {field_kind}")
    else:
        field_kind = json.loads('"UMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U_L_Lift1_Transform":
            raise ValueError(f"Expected 'U_L_Lift1_Transform', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U_L_Lift1_Transform":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U_L_Lift1_Transform', got {field_type_}")
    else:
        field_type_ = json.loads('"U_L_Lift1_Transform"')

    if "m" in data:
        field_m = load_U1Map(data["m"])
    else:
        raise ValueError("Missing required field 'm'")

    if "transform" in data:
        field_transform = load_MonotoneMap(data["transform"])
    else:
        raise ValueError("Missing required field 'transform'")

    return U_L_Lift1_Transform(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
        m=field_m,
        transform=field_transform,
    )


def load_U_Unknown(data: object) -> "U_Unknown":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UMap":
            raise ValueError(f"Expected 'UMap', got {field_kind}'")
        if field_kind is not None and field_kind != "UMap":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'UMap', got {field_kind}")
    else:
        field_kind = json.loads('"UMap"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "kcod" in data:
        field_kcod = load_Poset(data["kcod"])
    else:
        raise ValueError("Missing required field 'kcod'")

    if "kdom" in data:
        field_kdom = load_Poset(data["kdom"])
    else:
        raise ValueError("Missing required field 'kdom'")

    if "kimp" in data:
        field_kimp = load_Poset(data["kimp"])
    else:
        raise ValueError("Missing required field 'kimp'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "U_Unknown":
            raise ValueError(f"Expected 'U_Unknown', got {field_type_}'")
        if field_type_ is not None and field_type_ != "U_Unknown":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'U_Unknown', got {field_type_}")
    else:
        field_type_ = json.loads('"U_Unknown"')

    return U_Unknown(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        kcod=field_kcod,
        kdom=field_kdom,
        kimp=field_kimp,
        type_=field_type_,
    )


def load_Unit(data: object) -> "Unit":
    """Load Unit from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "Unit_None": load_Unit_None,
        "Unit_Single": load_Unit_Single,
        "Unit_Vector": load_Unit_Vector,
        "Unit_Wrapped": load_Unit_Wrapped,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for Unit")


def load_Unit_None(data: object) -> "Unit_None":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Unit":
            raise ValueError(f"Expected 'Unit', got {field_kind}'")
    else:
        field_kind = json.loads('"Unit"')

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "Unit_None":
            raise ValueError(f"Expected 'Unit_None', got {field_type_}'")
        if field_type_ is not None and field_type_ != "Unit_None":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'Unit_None', got {field_type_}")
    else:
        field_type_ = json.loads('"Unit_None"')

    return Unit_None(
        description=field_description,
        kind=field_kind,
        type_=field_type_,
    )


def load_Unit_Single(data: object) -> "Unit_Single":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Unit":
            raise ValueError(f"Expected 'Unit', got {field_kind}'")
    else:
        field_kind = json.loads('"Unit"')

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "Unit_Single":
            raise ValueError(f"Expected 'Unit_Single', got {field_type_}'")
        if field_type_ is not None and field_type_ != "Unit_Single":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'Unit_Single', got {field_type_}")
    else:
        field_type_ = json.loads('"Unit_Single"')

    if "units" in data:
        field_units = load_str(data["units"])
    else:
        raise ValueError("Missing required field 'units'")

    return Unit_Single(
        description=field_description,
        kind=field_kind,
        type_=field_type_,
        units=field_units,
    )


def load_Unit_Vector(data: object) -> "Unit_Vector":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Unit":
            raise ValueError(f"Expected 'Unit', got {field_kind}'")
    else:
        field_kind = json.loads('"Unit"')

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "Unit_Vector":
            raise ValueError(f"Expected 'Unit_Vector', got {field_type_}'")
        if field_type_ is not None and field_type_ != "Unit_Vector":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'Unit_Vector', got {field_type_}")
    else:
        field_type_ = json.loads('"Unit_Vector"')

    if "labels" in data:
        value = data["labels"]
        if value is None:
            field_labels = None
        else:
            field_labels = load_list_of_str(value)
    else:
        field_labels = None

    if "subs" in data:
        field_subs = load_list_of_Unit(data["subs"])
    else:
        raise ValueError("Missing required field 'subs'")

    return Unit_Vector(
        description=field_description,
        kind=field_kind,
        type_=field_type_,
        labels=field_labels,
        subs=field_subs,
    )


def load_Unit_Wrapped(data: object) -> "Unit_Wrapped":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Unit":
            raise ValueError(f"Expected 'Unit', got {field_kind}'")
    else:
        field_kind = json.loads('"Unit"')

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "Unit_Wrapped":
            raise ValueError(f"Expected 'Unit_Wrapped', got {field_type_}'")
        if field_type_ is not None and field_type_ != "Unit_Wrapped":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'Unit_Wrapped', got {field_type_}")
    else:
        field_type_ = json.loads('"Unit_Wrapped"')

    if "inside" in data:
        field_inside = load_list_of_Unit(data["inside"])
    else:
        raise ValueError("Missing required field 'inside'")

    if "name" in data:
        field_name = load_str(data["name"])
    else:
        raise ValueError("Missing required field 'name'")

    if "shape" in data:
        field_shape = load_any(data["shape"])
    else:
        raise ValueError("Missing required field 'shape'")

    return Unit_Wrapped(
        description=field_description,
        kind=field_kind,
        type_=field_type_,
        inside=field_inside,
        name=field_name,
        shape=field_shape,
    )


def load_UpperSet(data: object) -> "UpperSet":
    """Load UpperSet from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "UpperSet_Unused": load_UpperSet_Unused,
        "UpperSet_UpperClosure": load_UpperSet_UpperClosure,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for UpperSet")


def load_UpperSet_Unused(data: object) -> "UpperSet_Unused":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UpperSet":
            raise ValueError(f"Expected 'UpperSet', got {field_kind}'")
    else:
        raise ValueError("Missing required field 'kind'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "UpperSet_Unused":
            raise ValueError(f"Expected 'UpperSet_Unused', got {field_type_}'")
        if field_type_ is not None and field_type_ != "UpperSet_Unused":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'UpperSet_Unused', got {field_type_}")
    else:
        field_type_ = json.loads('"UpperSet_Unused"')

    return UpperSet_Unused(
        kind=field_kind,
        type_=field_type_,
    )


def load_UpperSet_UpperClosure(data: object) -> "UpperSet_UpperClosure":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "UpperSet":
            raise ValueError(f"Expected 'UpperSet', got {field_kind}'")
    else:
        raise ValueError("Missing required field 'kind'")

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "UpperSet_UpperClosure":
            raise ValueError(f"Expected 'UpperSet_UpperClosure', got {field_type_}'")
        if field_type_ is not None and field_type_ != "UpperSet_UpperClosure":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'UpperSet_UpperClosure', got {field_type_}")
    else:
        field_type_ = json.loads('"UpperSet_UpperClosure"')

    if "points" in data:
        field_points = load_list_of_any(data["points"])
    else:
        raise ValueError("Missing required field 'points'")

    return UpperSet_UpperClosure(
        kind=field_kind,
        type_=field_type_,
        points=field_points,
    )


def load_Value(data: object) -> "Value":
    """Load Value from a dictionary based on the 'type' discriminator."""
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)
    discriminator: Any = data.get("type")
    mapping = {
        "VU": load_VU,
    }
    if discriminator in mapping:
        return mapping[discriminator](data)
    raise ValueError(f"Unknown discriminator value: {discriminator} for Value")


def load_VU(data: object) -> "VU":
    if not isinstance(data, dict):
        raise ValueError("Data must be a dictionary")
    data = cast(dict[str, object], data)

    if "description" in data:
        value = data["description"]
        if value is None:
            field_description = None
        else:
            field_description = load_str(value)
    else:
        field_description = None

    if "hash" in data:
        value = data["hash"]
        if value is None:
            field_hash = None
        else:
            field_hash = load_str(value)
    else:
        field_hash = None

    if "kind" in data:
        field_kind = load_str(data["kind"])
        if field_kind != "Value":
            raise ValueError(f"Expected 'Value', got {field_kind}'")
        if field_kind is not None and field_kind != "Value":
            raise ValueError(f"Invalid discriminator value for 'kind': expected 'Value', got {field_kind}")
    else:
        field_kind = json.loads('"Value"')

    if "version" in data:
        value = data["version"]
        if value is None:
            field_version = None
        else:
            field_version = load_str(value)
    else:
        field_version = None

    if "address" in data:
        value = data["address"]
        if value is None:
            field_address = None
        else:
            field_address = load_Address(value)
    else:
        field_address = None

    if "type" in data:
        field_type_ = load_str(data["type"])
        if field_type_ != "VU":
            raise ValueError(f"Expected 'VU', got {field_type_}'")
        if field_type_ is not None and field_type_ != "VU":
            raise ValueError(f"Invalid discriminator value for 'type': expected 'VU', got {field_type_}")
    else:
        field_type_ = json.loads('"VU"')

    if "poset" in data:
        field_poset = load_Poset(data["poset"])
    else:
        raise ValueError("Missing required field 'poset'")

    if "value" in data:
        field_value = load_any(data["value"])
    else:
        raise ValueError("Missing required field 'value'")

    return VU(
        description=field_description,
        hash=field_hash,
        kind=field_kind,
        version=field_version,
        address=field_address,
        type_=field_type_,
        poset=field_poset,
        value=field_value,
    )


# Schema definitions
@dataclass(frozen=True)
class Address:
    library: str = field()
    spec: Literal["models", "templates", "values", "posets", "primitivedps", "interfaces", "queries"] = field()
    thing: str = field()
    type_: Literal["Address"] = field()
    repo: str | None = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["library"] = self.library
        if self.repo is not None:
            result["repo"] = self.repo
        result["spec"] = self.spec
        result["thing"] = self.thing
        result["type"] = self.type_
        return result

    @classmethod
    def make(
        cls,
        *,
        library: str,
        spec: Literal["models", "templates", "values", "posets", "primitivedps", "interfaces", "queries"],
        thing: str,
        repo: str | None = None,
    ) -> Self:
        """Create a new Address instance."""
        type_ = "Address"
        return cls(
            library=library,
            repo=repo,
            spec=spec,
            thing=thing,
            type_=type_,
        )


"""The Root schema contains as subtypes all kinds of objects that can serialized in a MCDP file during an export operation."""


@dataclass(frozen=True)
class Root:
    kind: Literal[
        "Check",
        "DP",
        "L1Map",
        "LMap",
        "MonotoneMap",
        "NDP",
        "NDPInterface",
        "NDPTemplate",
        "Poset",
        "Query",
        "SL1Map",
        "SLMap",
        "SU1Map",
        "SUMap",
        "U1Map",
        "UMap",
        "Value",
    ] = field()
    description: str | None = field()
    hash: str | None = field()
    version: str | None = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        if self.description is not None:
            result["description"] = self.description
        if self.hash is not None:
            result["hash"] = self.hash
        result["kind"] = self.kind
        if self.version is not None:
            result["version"] = self.version
        return result


@dataclass(frozen=True)
class Check(Root):
    kind: Literal["Check"] = field()
    type_: Literal["L1Check", "LCheck", "MapCheck", "SL1Check", "SLCheck", "SU1Check", "SUCheck", "U1Check", "UCheck"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class Connection:
    source: ConnectionSource = field()
    target: ConnectionTarget = field()
    type_: Literal["Connection"] = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["source"] = self.source.to_data()
        result["target"] = self.target.to_data()
        result["type"] = self.type_
        return result

    @classmethod
    def make(cls, *, source: ConnectionSource, target: ConnectionTarget) -> Self:
        """Create a new Connection instance."""
        type_ = "Connection"
        return cls(
            source=source,
            target=target,
            type_=type_,
        )


@dataclass(frozen=True)
class ConnectionSource:
    type_: Literal["ModelFunctionality", "NodeRequirement"] = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class ConnectionTarget:
    type_: Literal["ModelRequirement", "NodeFunctionality"] = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class DP(Root):
    kind: Literal["DP"] = field()
    B: Poset | None = field()
    F: Poset = field()
    I: Poset | None = field()
    R: Poset = field()
    address: Address | None = field()
    type_: Literal[
        "DP_All_Constants_And_F_Leq_R",
        "DP_All_Constants_Leq_R",
        "DP_All_Fi_Leq_R",
        "DP_AmbientConversion",
        "DP_Any_Constants_Or_F_Leq_R",
        "DP_Any_Fi_Leq_R",
        "DP_C_ExplicitApprox",
        "DP_C_Intersection",
        "DP_C_Parallel",
        "DP_C_Series",
        "DP_C_Trace",
        "DP_C_Union",
        "DP_Catalog",
        "DP_Compiled",
        "DP_F_Leq_All_Constants",
        "DP_F_Leq_All_R_And_Constants",
        "DP_F_Leq_All_Ri",
        "DP_F_Leq_Any_R_And_Constants",
        "DP_F_Leq_Any_Ri",
        "DP_False",
        "DP_FuncNotMoreThan",
        "DP_GenericConstant",
        "DP_Identity",
        "DP_Iso",
        "DP_LiftL",
        "DP_LiftU",
        "DP_ResNotLessThan",
        "DP_True",
        "DP_Unknown",
    ] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.B is not None:
            result["B"] = self.B.to_data()
        result["F"] = self.F.to_data()
        if self.I is not None:
            result["I"] = self.I.to_data()
        result["R"] = self.R.to_data()
        if self.address is not None:
            result["address"] = self.address.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class DP_All_Constants_And_F_Leq_R(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_All_Constants_And_F_Leq_R"] = field()
    constants: list[Any] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["constants"] = self.constants
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        constants: list[Any],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_All_Constants_And_F_Leq_R instance."""
        kind = "DP"
        type_ = "DP_All_Constants_And_F_Leq_R"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            constants=constants,
        )


@dataclass(frozen=True)
class DP_All_Constants_Leq_R(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_All_Constants_Leq_R"] = field()
    constants: list[Any] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["constants"] = self.constants
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        constants: list[Any],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_All_Constants_Leq_R instance."""
        kind = "DP"
        type_ = "DP_All_Constants_Leq_R"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            constants=constants,
        )


@dataclass(frozen=True)
class DP_All_Fi_Leq_R(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_All_Fi_Leq_R"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_All_Fi_Leq_R instance."""
        kind = "DP"
        type_ = "DP_All_Fi_Leq_R"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
        )


@dataclass(frozen=True)
class DP_AmbientConversion(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_AmbientConversion"] = field()
    common: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["common"] = self.common.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        common: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_AmbientConversion instance."""
        kind = "DP"
        type_ = "DP_AmbientConversion"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            common=common,
        )


@dataclass(frozen=True)
class DP_Any_Constants_Or_F_Leq_R(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_Any_Constants_Or_F_Leq_R"] = field()
    constants: list[Any] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["constants"] = self.constants
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        constants: list[Any],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_Any_Constants_Or_F_Leq_R instance."""
        kind = "DP"
        type_ = "DP_Any_Constants_Or_F_Leq_R"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            constants=constants,
        )


@dataclass(frozen=True)
class DP_Any_Fi_Leq_R(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_Any_Fi_Leq_R"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_Any_Fi_Leq_R instance."""
        kind = "DP"
        type_ = "DP_Any_Fi_Leq_R"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
        )


@dataclass(frozen=True)
class DP_C_ExplicitApprox(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_C_ExplicitApprox"] = field()
    optimistic: list[DP] = field()
    optimistic_labels: list[str] | None = field()
    pessimistic: list[DP] = field()
    pessimistic_labels: list[str] | None = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["optimistic"] = [item.to_data() for item in self.optimistic]
        if self.optimistic_labels is not None:
            result["optimistic_labels"] = self.optimistic_labels
        result["pessimistic"] = [item.to_data() for item in self.pessimistic]
        if self.pessimistic_labels is not None:
            result["pessimistic_labels"] = self.pessimistic_labels
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        optimistic: list[DP],
        pessimistic: list[DP],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
        optimistic_labels: list[str] | None = None,
        pessimistic_labels: list[str] | None = None,
    ) -> Self:
        """Create a new DP_C_ExplicitApprox instance."""
        kind = "DP"
        type_ = "DP_C_ExplicitApprox"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            optimistic=optimistic,
            optimistic_labels=optimistic_labels,
            pessimistic=pessimistic,
            pessimistic_labels=pessimistic_labels,
        )

    # Valid examples
    __examples__ = [
        {
            "F": {"kind": "Poset", "type": "P_Decimal"},
            "R": {"kind": "Poset", "type": "P_Decimal"},
            "kind": "DP",
            "optimistic": [
                {
                    "F": {"kind": "Poset", "type": "P_Decimal"},
                    "R": {"kind": "Poset", "type": "P_Decimal"},
                    "kind": "DP",
                    "type": "DP_True",
                    "value": {
                        "kind": "Value",
                        "poset": {"kind": "Poset", "naked": [], "ranges": [], "subs": [], "type": "P_C_ProductSmash"},
                        "type": "VU",
                        "value": [],
                    },
                }
            ],
            "pessimistic": [
                {
                    "F": {"kind": "Poset", "type": "P_Decimal"},
                    "R": {"kind": "Poset", "type": "P_Decimal"},
                    "kind": "DP",
                    "type": "DP_False",
                }
            ],
            "type": "DP_C_ExplicitApprox",
        },
    ]


@dataclass(frozen=True)
class DP_C_Intersection(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_C_Intersection"] = field()
    dps: list[DP] = field()
    labels: list[str] | None = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["dps"] = [item.to_data() for item in self.dps]
        if self.labels is not None:
            result["labels"] = self.labels
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        dps: list[DP],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new DP_C_Intersection instance."""
        kind = "DP"
        type_ = "DP_C_Intersection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            dps=dps,
            labels=labels,
        )


@dataclass(frozen=True)
class DP_C_Parallel(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_C_Parallel"] = field()
    dps: list[DP] = field()
    labels: list[str] | None = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["dps"] = [item.to_data() for item in self.dps]
        if self.labels is not None:
            result["labels"] = self.labels
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        dps: list[DP],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new DP_C_Parallel instance."""
        kind = "DP"
        type_ = "DP_C_Parallel"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            dps=dps,
            labels=labels,
        )


@dataclass(frozen=True)
class DP_C_Series(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_C_Series"] = field()
    dps: list[DP] = field()
    labels: list[str] | None = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["dps"] = [item.to_data() for item in self.dps]
        if self.labels is not None:
            result["labels"] = self.labels
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        dps: list[DP],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new DP_C_Series instance."""
        kind = "DP"
        type_ = "DP_C_Series"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            dps=dps,
            labels=labels,
        )


@dataclass(frozen=True)
class DP_C_Trace(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_C_Trace"] = field()
    dp: DP = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["dp"] = self.dp.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        dp: DP,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_C_Trace instance."""
        kind = "DP"
        type_ = "DP_C_Trace"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            dp=dp,
        )


@dataclass(frozen=True)
class DP_C_Union(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_C_Union"] = field()
    dps: list[DP] = field()
    labels: list[str] | None = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["dps"] = [item.to_data() for item in self.dps]
        if self.labels is not None:
            result["labels"] = self.labels
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        dps: list[DP],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new DP_C_Union instance."""
        kind = "DP"
        type_ = "DP_C_Union"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            dps=dps,
            labels=labels,
        )


@dataclass(frozen=True)
class DP_Catalog(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_Catalog"] = field()
    options: list[DP_Catalog_Options] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["options"] = [item.to_data() for item in self.options]
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        options: list[DP_Catalog_Options],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_Catalog instance."""
        kind = "DP"
        type_ = "DP_Catalog"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            options=options,
        )


@dataclass(frozen=True)
class DP_Catalog_Options:
    b: Any = field()
    f: Any = field()
    i: Any = field()
    r: Any = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["b"] = self.b
        result["f"] = self.f
        result["i"] = self.i
        result["r"] = self.r
        return result

    @classmethod
    def make(cls, *, b: Any, f: Any, i: Any, r: Any) -> Self:
        """Create a new DP_Catalog_Options instance."""
        return cls(
            b=b,
            f=f,
            i=i,
            r=r,
        )


@dataclass(frozen=True)
class DP_Compiled(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_Compiled"] = field()
    f_b_r: SUMap = field()
    f_i_r: SUMap = field()
    f_r: SU1Map = field()
    i_availability: MonotoneMap = field()
    i_b: MonotoneMap = field()
    i_codfeas: MonotoneMap = field()
    prov: MonotoneMap = field()
    r_b_f: SLMap = field()
    r_f: SL1Map = field()
    r_i_f: SLMap = field()
    req: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["f_b_r"] = self.f_b_r.to_data()
        result["f_i_r"] = self.f_i_r.to_data()
        result["f_r"] = self.f_r.to_data()
        result["i_availability"] = self.i_availability.to_data()
        result["i_b"] = self.i_b.to_data()
        result["i_codfeas"] = self.i_codfeas.to_data()
        result["prov"] = self.prov.to_data()
        result["r_b_f"] = self.r_b_f.to_data()
        result["r_f"] = self.r_f.to_data()
        result["r_i_f"] = self.r_i_f.to_data()
        result["req"] = self.req.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        f_b_r: SUMap,
        f_i_r: SUMap,
        f_r: SU1Map,
        i_availability: MonotoneMap,
        i_b: MonotoneMap,
        i_codfeas: MonotoneMap,
        prov: MonotoneMap,
        r_b_f: SLMap,
        r_f: SL1Map,
        r_i_f: SLMap,
        req: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_Compiled instance."""
        kind = "DP"
        type_ = "DP_Compiled"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            f_b_r=f_b_r,
            f_i_r=f_i_r,
            f_r=f_r,
            i_availability=i_availability,
            i_b=i_b,
            i_codfeas=i_codfeas,
            prov=prov,
            r_b_f=r_b_f,
            r_f=r_f,
            r_i_f=r_i_f,
            req=req,
        )


@dataclass(frozen=True)
class DP_F_Leq_All_Constants(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_F_Leq_All_Constants"] = field()
    constants: list[Any] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["constants"] = self.constants
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        constants: list[Any],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_F_Leq_All_Constants instance."""
        kind = "DP"
        type_ = "DP_F_Leq_All_Constants"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            constants=constants,
        )


@dataclass(frozen=True)
class DP_F_Leq_All_R_And_Constants(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_F_Leq_All_R_And_Constants"] = field()
    constants: list[Any] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["constants"] = self.constants
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        constants: list[Any],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_F_Leq_All_R_And_Constants instance."""
        kind = "DP"
        type_ = "DP_F_Leq_All_R_And_Constants"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            constants=constants,
        )


@dataclass(frozen=True)
class DP_F_Leq_All_Ri(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_F_Leq_All_Ri"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_F_Leq_All_Ri instance."""
        kind = "DP"
        type_ = "DP_F_Leq_All_Ri"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
        )


@dataclass(frozen=True)
class DP_F_Leq_Any_R_And_Constants(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_F_Leq_Any_R_And_Constants"] = field()
    constants: list[Any] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["constants"] = self.constants
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        constants: list[Any],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_F_Leq_Any_R_And_Constants instance."""
        kind = "DP"
        type_ = "DP_F_Leq_Any_R_And_Constants"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            constants=constants,
        )


@dataclass(frozen=True)
class DP_F_Leq_Any_Ri(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_F_Leq_Any_Ri"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_F_Leq_Any_Ri instance."""
        kind = "DP"
        type_ = "DP_F_Leq_Any_Ri"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
        )


@dataclass(frozen=True)
class DP_False(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_False"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_False instance."""
        kind = "DP"
        type_ = "DP_False"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
        )


@dataclass(frozen=True)
class DP_FuncNotMoreThan(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_FuncNotMoreThan"] = field()
    limit: Any = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["limit"] = self.limit
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        limit: Any,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_FuncNotMoreThan instance."""
        kind = "DP"
        type_ = "DP_FuncNotMoreThan"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            limit=limit,
        )


@dataclass(frozen=True)
class DP_GenericConstant(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_GenericConstant"] = field()
    b_value: Any = field()
    lower_set: LowerSet = field()
    upper_set: UpperSet = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["b_value"] = self.b_value
        result["lower_set"] = self.lower_set.to_data()
        result["upper_set"] = self.upper_set.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        b_value: Any,
        lower_set: LowerSet,
        upper_set: UpperSet,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_GenericConstant instance."""
        kind = "DP"
        type_ = "DP_GenericConstant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            b_value=b_value,
            lower_set=lower_set,
            upper_set=upper_set,
        )


@dataclass(frozen=True)
class DP_Identity(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_Identity"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_Identity instance."""
        kind = "DP"
        type_ = "DP_Identity"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
        )


@dataclass(frozen=True)
class DP_Iso(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_Iso"] = field()
    bwd: MonotoneMap = field()
    fwd: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["bwd"] = self.bwd.to_data()
        result["fwd"] = self.fwd.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        bwd: MonotoneMap,
        fwd: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_Iso instance."""
        kind = "DP"
        type_ = "DP_Iso"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            bwd=bwd,
            fwd=fwd,
        )


@dataclass(frozen=True)
class DP_LiftL(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_LiftL"] = field()
    m: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        m: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_LiftL instance."""
        kind = "DP"
        type_ = "DP_LiftL"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class DP_LiftU(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_LiftU"] = field()
    m: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        m: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_LiftU instance."""
        kind = "DP"
        type_ = "DP_LiftU"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class DP_ResNotLessThan(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_ResNotLessThan"] = field()
    limit: Any = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["limit"] = self.limit
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        limit: Any,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_ResNotLessThan instance."""
        kind = "DP"
        type_ = "DP_ResNotLessThan"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            limit=limit,
        )


@dataclass(frozen=True)
class DP_True(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_True"] = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_True instance."""
        kind = "DP"
        type_ = "DP_True"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
            value=value,
        )

    # Valid examples
    __examples__ = [
        {
            "B": {
                "kind": "Poset",
                "naked": true,
                "ranges": "...",
                "subs": [{"kind": "Poset", "type": "P_Decimal"}],
                "type": "P_C_ProductSmash",
            },
            "F": {"kind": "Poset", "subs": [], "type": "P_C_Product"},
            "I": {"kind": "Poset", "subs": [], "type": "P_C_ProductSmash"},
            "R": {"kind": "Poset", "subs": [], "type": "P_C_Product"},
            "kind": "DP",
            "type": "DP_True",
            "value": {
                "kind": "Value",
                "poset": {
                    "kind": "Poset",
                    "naked": true,
                    "ranges": "...",
                    "subs": [{"kind": "Poset", "type": "P_Decimal"}],
                    "type": "P_C_ProductSmash",
                },
                "type": "VU",
                "value": [15],
            },
        },
    ]


@dataclass(frozen=True)
class DP_Unknown(DP):
    kind: Literal["DP"] = field()
    type_: Literal["DP_Unknown"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        F: Poset,
        R: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        B: Poset | None = None,
        I: Poset | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new DP_Unknown instance."""
        kind = "DP"
        type_ = "DP_Unknown"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            B=B,
            F=F,
            I=I,
            R=R,
            address=address,
            type_=type_,
        )


@dataclass(frozen=True)
class L1Check(Check):
    kind: Literal["Check"] = field()
    type_: Literal["L1Check"] = field()
    data: list[L1Check_Data] = field()
    m: L1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["data"] = [item.to_data() for item in self.data]
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        data: list[L1Check_Data],
        m: L1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L1Check instance."""
        kind = "Check"
        type_ = "L1Check"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            type_=type_,
            data=data,
            m=m,
        )


@dataclass(frozen=True)
class L1Check_Data:
    x: Any = field()
    y: LowerSet = field()
    elapsed: float | None = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        if self.elapsed is not None:
            result["elapsed"] = self.elapsed
        result["x"] = self.x
        result["y"] = self.y.to_data()
        return result

    @classmethod
    def make(cls, *, x: Any, y: LowerSet, elapsed: float | None = None) -> Self:
        """Create a new L1Check_Data instance."""
        return cls(
            elapsed=elapsed,
            x=x,
            y=y,
        )


@dataclass(frozen=True)
class L1Map(Root):
    kind: Literal["L1Map"] = field()
    kcod: Poset = field()
    kdom: Poset = field()
    type_: Literal[
        "L1_C_CodSum",
        "L1_C_CodSumSmash",
        "L1_C_DomUnion",
        "L1_C_Intersection",
        "L1_C_Parallel",
        "L1_C_ProdIntersection",
        "L1_C_Product",
        "L1_C_RefineDomain",
        "L1_C_Series",
        "L1_C_Trace",
        "L1_C_Union",
        "L1_C_WrapUnits",
        "L1_Catalog",
        "L1_Constant",
        "L1_Entire",
        "L1_Explicit",
        "L1_FromFilter",
        "L1_Identity",
        "L1_IntersectionOfPrinLowerSets",
        "L1_InvMul_Opt",
        "L1_InvMul_Pes",
        "L1_InvSum_Opt",
        "L1_InvSum_Pes",
        "L1_L_Linv",
        "L1_Lift",
        "L1_RepresentPrincipalLowerSet",
        "L1_TopAlternating",
        "L1_UnionOfPrinLowerSets",
        "L1_Unknown",
    ] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod"] = self.kcod.to_data()
        result["kdom"] = self.kdom.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class L1_C_CodSum(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_C_CodSum"] = field()
    labels: list[str] | None = field()
    ms: list[L1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[L1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new L1_C_CodSum instance."""
        kind = "L1Map"
        type_ = "L1_C_CodSum"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class L1_C_CodSumSmash(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_C_CodSumSmash"] = field()
    labels: list[str] | None = field()
    ms: list[L1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[L1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new L1_C_CodSumSmash instance."""
        kind = "L1Map"
        type_ = "L1_C_CodSumSmash"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class L1_C_DomUnion(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_C_DomUnion"] = field()
    labels: list[str] | None = field()
    ms: list[L1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[L1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new L1_C_DomUnion instance."""
        kind = "L1Map"
        type_ = "L1_C_DomUnion"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class L1_C_Intersection(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_C_Intersection"] = field()
    labels: list[str] | None = field()
    ms: list[L1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[L1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new L1_C_Intersection instance."""
        kind = "L1Map"
        type_ = "L1_C_Intersection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class L1_C_Parallel(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_C_Parallel"] = field()
    labels: list[str] | None = field()
    ms: list[L1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[L1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new L1_C_Parallel instance."""
        kind = "L1Map"
        type_ = "L1_C_Parallel"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class L1_C_ProdIntersection(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_C_ProdIntersection"] = field()
    labels: list[str] | None = field()
    ms: list[L1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[L1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new L1_C_ProdIntersection instance."""
        kind = "L1Map"
        type_ = "L1_C_ProdIntersection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class L1_C_Product(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_C_Product"] = field()
    labels: list[str] | None = field()
    ms: list[L1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[L1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new L1_C_Product instance."""
        kind = "L1Map"
        type_ = "L1_C_Product"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class L1_C_RefineDomain(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_C_RefineDomain"] = field()
    m: L1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        m: L1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L1_C_RefineDomain instance."""
        kind = "L1Map"
        type_ = "L1_C_RefineDomain"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class L1_C_Series(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_C_Series"] = field()
    labels: list[str] | None = field()
    ms: list[L1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[L1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new L1_C_Series instance."""
        kind = "L1Map"
        type_ = "L1_C_Series"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class L1_C_Trace(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_C_Trace"] = field()
    m: L1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        m: L1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L1_C_Trace instance."""
        kind = "L1Map"
        type_ = "L1_C_Trace"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class L1_C_Union(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_C_Union"] = field()
    labels: list[str] | None = field()
    ms: list[L1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[L1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new L1_C_Union instance."""
        kind = "L1Map"
        type_ = "L1_C_Union"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class L1_C_WrapUnits(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_C_WrapUnits"] = field()
    kcod_units: Unit = field()
    kdom_units: Unit = field()
    m: L1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod_units"] = self.kcod_units.to_data()
        result["kdom_units"] = self.kdom_units.to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kcod_units: Unit,
        kdom_units: Unit,
        m: L1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L1_C_WrapUnits instance."""
        kind = "L1Map"
        type_ = "L1_C_WrapUnits"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            kcod_units=kcod_units,
            kdom_units=kdom_units,
            m=m,
        )


@dataclass(frozen=True)
class L1_Catalog(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_Catalog"] = field()
    options: list[L1_Catalog_Options] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["options"] = [item.to_data() for item in self.options]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        options: list[L1_Catalog_Options],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L1_Catalog instance."""
        kind = "L1Map"
        type_ = "L1_Catalog"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            options=options,
        )


@dataclass(frozen=True)
class L1_Catalog_Options:
    f: Any = field()
    r: Any = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["f"] = self.f
        result["r"] = self.r
        return result

    @classmethod
    def make(cls, *, f: Any, r: Any) -> Self:
        """Create a new L1_Catalog_Options instance."""
        return cls(
            f=f,
            r=r,
        )


@dataclass(frozen=True)
class L1_Constant(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_Constant"] = field()
    value: LowerSet = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        value: LowerSet,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L1_Constant instance."""
        kind = "L1Map"
        type_ = "L1_Constant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            value=value,
        )


@dataclass(frozen=True)
class L1_Entire(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_Entire"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, kcod: Poset, kdom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new L1_Entire instance."""
        kind = "L1Map"
        type_ = "L1_Entire"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
        )


@dataclass(frozen=True)
class L1_Explicit(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_Explicit"] = field()
    options: list[L1_Explicit_Option] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["options"] = [item.to_data() for item in self.options]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        options: list[L1_Explicit_Option],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L1_Explicit instance."""
        kind = "L1Map"
        type_ = "L1_Explicit"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            options=options,
        )


@dataclass(frozen=True)
class L1_Explicit_Option:
    x: Any = field()
    y: LowerSet = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["x"] = self.x
        result["y"] = self.y.to_data()
        return result

    @classmethod
    def make(cls, *, x: Any, y: LowerSet) -> Self:
        """Create a new L1_Explicit_Option instance."""
        return cls(
            x=x,
            y=y,
        )


@dataclass(frozen=True)
class L1_FromFilter(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_FromFilter"] = field()
    m: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        m: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L1_FromFilter instance."""
        kind = "L1Map"
        type_ = "L1_FromFilter"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class L1_Identity(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_Identity"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, kcod: Poset, kdom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new L1_Identity instance."""
        kind = "L1Map"
        type_ = "L1_Identity"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
        )


@dataclass(frozen=True)
class L1_IntersectionOfPrinLowerSets(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_IntersectionOfPrinLowerSets"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, kcod: Poset, kdom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new L1_IntersectionOfPrinLowerSets instance."""
        kind = "L1Map"
        type_ = "L1_IntersectionOfPrinLowerSets"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
        )


@dataclass(frozen=True)
class L1_InvMul_Opt(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_InvMul_Opt"] = field()
    n: int = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["n"] = self.n
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        n: int,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L1_InvMul_Opt instance."""
        kind = "L1Map"
        type_ = "L1_InvMul_Opt"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            n=n,
            opspace=opspace,
        )


@dataclass(frozen=True)
class L1_InvMul_Pes(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_InvMul_Pes"] = field()
    n: int = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["n"] = self.n
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        n: int,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L1_InvMul_Pes instance."""
        kind = "L1Map"
        type_ = "L1_InvMul_Pes"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            n=n,
            opspace=opspace,
        )


@dataclass(frozen=True)
class L1_InvSum_Opt(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_InvSum_Opt"] = field()
    n: int = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["n"] = self.n
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        n: int,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L1_InvSum_Opt instance."""
        kind = "L1Map"
        type_ = "L1_InvSum_Opt"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            n=n,
            opspace=opspace,
        )


@dataclass(frozen=True)
class L1_InvSum_Pes(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_InvSum_Pes"] = field()
    n: int = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["n"] = self.n
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        n: int,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L1_InvSum_Pes instance."""
        kind = "L1Map"
        type_ = "L1_InvSum_Pes"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            n=n,
            opspace=opspace,
        )


@dataclass(frozen=True)
class L1_L_Linv(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_L_Linv"] = field()
    m: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        m: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L1_L_Linv instance."""
        kind = "L1Map"
        type_ = "L1_L_Linv"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class L1_Lift(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_Lift"] = field()
    m: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        m: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L1_Lift instance."""
        kind = "L1Map"
        type_ = "L1_Lift"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class L1_RepresentPrincipalLowerSet(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_RepresentPrincipalLowerSet"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, kcod: Poset, kdom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new L1_RepresentPrincipalLowerSet instance."""
        kind = "L1Map"
        type_ = "L1_RepresentPrincipalLowerSet"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
        )


@dataclass(frozen=True)
class L1_TopAlternating(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_TopAlternating"] = field()
    upper_bounds: list[list[Any]] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["upper_bounds"] = self.upper_bounds
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        upper_bounds: list[list[Any]],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L1_TopAlternating instance."""
        kind = "L1Map"
        type_ = "L1_TopAlternating"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            upper_bounds=upper_bounds,
        )


@dataclass(frozen=True)
class L1_UnionOfPrinLowerSets(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_UnionOfPrinLowerSets"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, kcod: Poset, kdom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new L1_UnionOfPrinLowerSets instance."""
        kind = "L1Map"
        type_ = "L1_UnionOfPrinLowerSets"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
        )


@dataclass(frozen=True)
class L1_Unknown(L1Map):
    kind: Literal["L1Map"] = field()
    type_: Literal["L1_Unknown"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, kcod: Poset, kdom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new L1_Unknown instance."""
        kind = "L1Map"
        type_ = "L1_Unknown"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
        )


@dataclass(frozen=True)
class LCheck(Check):
    kind: Literal["Check"] = field()
    type_: Literal["LCheck"] = field()
    data: list[LCheck_Data] = field()
    m: LMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["data"] = [item.to_data() for item in self.data]
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        data: list[LCheck_Data],
        m: LMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new LCheck instance."""
        kind = "Check"
        type_ = "LCheck"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            type_=type_,
            data=data,
            m=m,
        )


@dataclass(frozen=True)
class LCheck_Data:
    x: Any = field()
    y: LowerSet = field()
    elapsed: float | None = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        if self.elapsed is not None:
            result["elapsed"] = self.elapsed
        result["x"] = self.x
        result["y"] = self.y.to_data()
        return result

    @classmethod
    def make(cls, *, x: Any, y: LowerSet, elapsed: float | None = None) -> Self:
        """Create a new LCheck_Data instance."""
        return cls(
            elapsed=elapsed,
            x=x,
            y=y,
        )


@dataclass(frozen=True)
class LMap(Root):
    kind: Literal["LMap"] = field()
    kcod: Poset = field()
    kdom: Poset = field()
    kimp: Poset = field()
    type_: Literal[
        "L_C_ITransform",
        "L_C_Intersection",
        "L_C_Parallel",
        "L_C_RefineDomain",
        "L_C_Series",
        "L_C_Trace",
        "L_C_Union",
        "L_C_WrapUnits",
        "L_Catalog",
        "L_Constant",
        "L_Identity",
        "L_L_Lift1_Constant",
        "L_L_Lift1_Transform",
        "L_Unknown",
    ] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod"] = self.kcod.to_data()
        result["kdom"] = self.kdom.to_data()
        result["kimp"] = self.kimp.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class L_C_ITransform(LMap):
    kind: Literal["LMap"] = field()
    type_: Literal["L_C_ITransform"] = field()
    m: LMap = field()
    transform: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["transform"] = self.transform.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        m: LMap,
        transform: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L_C_ITransform instance."""
        kind = "LMap"
        type_ = "L_C_ITransform"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            m=m,
            transform=transform,
        )


@dataclass(frozen=True)
class L_C_Intersection(LMap):
    kind: Literal["LMap"] = field()
    type_: Literal["L_C_Intersection"] = field()
    labels: list[str] | None = field()
    ms: list[LMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        ms: list[LMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new L_C_Intersection instance."""
        kind = "LMap"
        type_ = "L_C_Intersection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class L_C_Parallel(LMap):
    kind: Literal["LMap"] = field()
    type_: Literal["L_C_Parallel"] = field()
    labels: list[str] | None = field()
    ms: list[LMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        ms: list[LMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new L_C_Parallel instance."""
        kind = "LMap"
        type_ = "L_C_Parallel"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class L_C_RefineDomain(LMap):
    kind: Literal["LMap"] = field()
    type_: Literal["L_C_RefineDomain"] = field()
    m: LMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        m: LMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L_C_RefineDomain instance."""
        kind = "LMap"
        type_ = "L_C_RefineDomain"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class L_C_Series(LMap):
    kind: Literal["LMap"] = field()
    type_: Literal["L_C_Series"] = field()
    labels: list[str] | None = field()
    ms: list[LMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        ms: list[LMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new L_C_Series instance."""
        kind = "LMap"
        type_ = "L_C_Series"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class L_C_Trace(LMap):
    kind: Literal["LMap"] = field()
    type_: Literal["L_C_Trace"] = field()
    m: LMap = field()
    m_proj: L1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["m_proj"] = self.m_proj.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        m: LMap,
        m_proj: L1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L_C_Trace instance."""
        kind = "LMap"
        type_ = "L_C_Trace"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            m=m,
            m_proj=m_proj,
        )


@dataclass(frozen=True)
class L_C_Union(LMap):
    kind: Literal["LMap"] = field()
    type_: Literal["L_C_Union"] = field()
    labels: list[str] | None = field()
    ms: list[LMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        ms: list[LMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new L_C_Union instance."""
        kind = "LMap"
        type_ = "L_C_Union"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class L_C_WrapUnits(LMap):
    kind: Literal["LMap"] = field()
    type_: Literal["L_C_WrapUnits"] = field()
    kcod_units: Unit = field()
    kdom_units: Unit = field()
    kimp_units: Unit = field()
    m: LMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod_units"] = self.kcod_units.to_data()
        result["kdom_units"] = self.kdom_units.to_data()
        result["kimp_units"] = self.kimp_units.to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        kcod_units: Unit,
        kdom_units: Unit,
        kimp_units: Unit,
        m: LMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L_C_WrapUnits instance."""
        kind = "LMap"
        type_ = "L_C_WrapUnits"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            kcod_units=kcod_units,
            kdom_units=kdom_units,
            kimp_units=kimp_units,
            m=m,
        )


@dataclass(frozen=True)
class L_Catalog(LMap):
    kind: Literal["LMap"] = field()
    type_: Literal["L_Catalog"] = field()
    options: list[L_Catalog_Options] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["options"] = [item.to_data() for item in self.options]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        options: list[L_Catalog_Options],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L_Catalog instance."""
        kind = "LMap"
        type_ = "L_Catalog"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            options=options,
        )


@dataclass(frozen=True)
class L_Catalog_Options:
    f: Any = field()
    i: Any = field()
    r: Any = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["f"] = self.f
        result["i"] = self.i
        result["r"] = self.r
        return result

    @classmethod
    def make(cls, *, f: Any, i: Any, r: Any) -> Self:
        """Create a new L_Catalog_Options instance."""
        return cls(
            f=f,
            i=i,
            r=r,
        )


@dataclass(frozen=True)
class L_Constant(LMap):
    kind: Literal["LMap"] = field()
    type_: Literal["L_Constant"] = field()
    value: LowerSet = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        value: LowerSet,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L_Constant instance."""
        kind = "LMap"
        type_ = "L_Constant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            value=value,
        )


@dataclass(frozen=True)
class L_Identity(LMap):
    kind: Literal["LMap"] = field()
    type_: Literal["L_Identity"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L_Identity instance."""
        kind = "LMap"
        type_ = "L_Identity"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
        )


@dataclass(frozen=True)
class L_L_Lift1_Constant(LMap):
    kind: Literal["LMap"] = field()
    type_: Literal["L_L_Lift1_Constant"] = field()
    m: L1Map = field()
    value: Any = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["value"] = self.value
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        m: L1Map,
        value: Any,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L_L_Lift1_Constant instance."""
        kind = "LMap"
        type_ = "L_L_Lift1_Constant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            m=m,
            value=value,
        )


@dataclass(frozen=True)
class L_L_Lift1_Transform(LMap):
    kind: Literal["LMap"] = field()
    type_: Literal["L_L_Lift1_Transform"] = field()
    m: L1Map = field()
    transform: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["transform"] = self.transform.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        m: L1Map,
        transform: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L_L_Lift1_Transform instance."""
        kind = "LMap"
        type_ = "L_L_Lift1_Transform"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            m=m,
            transform=transform,
        )


@dataclass(frozen=True)
class L_Unknown(LMap):
    kind: Literal["LMap"] = field()
    type_: Literal["L_Unknown"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new L_Unknown instance."""
        kind = "LMap"
        type_ = "L_Unknown"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
        )


@dataclass(frozen=True)
class LowerSet:
    kind: Literal["LowerSet"] = field()
    type_: Literal["LowerSet_LowerClosure", "LowerSet_Unused"] = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["kind"] = self.kind
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class LowerSet_LowerClosure(LowerSet):
    type_: Literal["LowerSet_LowerClosure"] = field()
    points: list[Any] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["points"] = self.points
        return result

    @classmethod
    def make(cls, *, points: list[Any]) -> Self:
        """Create a new LowerSet_LowerClosure instance."""
        kind = "LowerSet"
        type_ = "LowerSet_LowerClosure"
        return cls(
            kind=kind,
            type_=type_,
            points=points,
        )


@dataclass(frozen=True)
class LowerSet_Unused(LowerSet):
    type_: Literal["LowerSet_Unused"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(cls) -> Self:
        """Create a new LowerSet_Unused instance."""
        kind = "LowerSet"
        type_ = "LowerSet_Unused"
        return cls(
            kind=kind,
            type_=type_,
        )


@dataclass(frozen=True)
class MonotoneMap(Root):
    kind: Literal["MonotoneMap"] = field()
    cod: Poset = field()
    dom: Poset = field()
    type_: Literal[
        "M_AddL",
        "M_AddLConstant",
        "M_AddU",
        "M_AddUConstant",
        "M_BottomIfNotTop",
        "M_C_Coproduct",
        "M_C_CoproductSmash",
        "M_C_DomProdCodSmash",
        "M_C_DomSmashCodProd",
        "M_C_DomUnion",
        "M_C_Leq_X",
        "M_C_LiftToSubsets",
        "M_C_Lt_X",
        "M_C_Op",
        "M_C_Parallel",
        "M_C_ParallelSmash",
        "M_C_Product",
        "M_C_ProductSmash",
        "M_C_RefineDomain",
        "M_C_Series",
        "M_C_Sum",
        "M_C_SumSmash",
        "M_C_WrapUnits",
        "M_Ceil0",
        "M_Coerce",
        "M_Constant",
        "M_ContainedInLowerSet",
        "M_ContainedInUpperSet",
        "M_DivideLConstant",
        "M_DivideUConstant",
        "M_Empty",
        "M_Explicit",
        "M_Floor0",
        "M_Id",
        "M_IdentityBelowThreshold",
        "M_Injection",
        "M_Join",
        "M_JoinConstant",
        "M_Leq",
        "M_Lift",
        "M_LiftToLowerSets",
        "M_LiftToUpperSets",
        "M_Meet",
        "M_MeetConstant",
        "M_MultiplyL",
        "M_MultiplyLConstant",
        "M_MultiplyU",
        "M_MultiplyUConstant",
        "M_PowerFracL",
        "M_PowerFracU",
        "M_ReprLowerSet",
        "M_ReprUpperSet",
        "M_RepresentPrincipalLowerSet_TotalOrderBounded",
        "M_RepresentPrincipalUpperSet_TotalOrderBounded",
        "M_RoundDown",
        "M_RoundUp",
        "M_ScaleL",
        "M_ScaleU",
        "M_SmashInjection",
        "M_SubLConstant",
        "M_SubUConstant",
        "M_TakeIndex",
        "M_TakeRange",
        "M_Threshold1",
        "M_Threshold2",
        "M_TopIfNotBottom",
        "M_Undefined",
        "M_Unknown",
        "M_Unlift",
        "M_X_Leq_C",
        "M_X_Lt_C",
    ] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["cod"] = self.cod.to_data()
        result["dom"] = self.dom.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class M_AddL(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_AddL"] = field()
    opspaces: list[Poset] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspaces"] = [item.to_data() for item in self.opspaces]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspaces: list[Poset],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_AddL instance."""
        kind = "MonotoneMap"
        type_ = "M_AddL"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspaces=opspaces,
        )


@dataclass(frozen=True)
class M_AddLConstant(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_AddLConstant"] = field()
    opspace: Poset = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_AddLConstant instance."""
        kind = "MonotoneMap"
        type_ = "M_AddLConstant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
            value=value,
        )


@dataclass(frozen=True)
class M_AddU(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_AddU"] = field()
    opspaces: list[Poset] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspaces"] = [item.to_data() for item in self.opspaces]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspaces: list[Poset],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_AddU instance."""
        kind = "MonotoneMap"
        type_ = "M_AddU"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspaces=opspaces,
        )


@dataclass(frozen=True)
class M_AddUConstant(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_AddUConstant"] = field()
    opspace: Poset = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_AddUConstant instance."""
        kind = "MonotoneMap"
        type_ = "M_AddUConstant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
            value=value,
        )


@dataclass(frozen=True)
class M_BottomIfNotTop(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_BottomIfNotTop"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, cod: Poset, dom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new M_BottomIfNotTop instance."""
        kind = "MonotoneMap"
        type_ = "M_BottomIfNotTop"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
        )


@dataclass(frozen=True)
class M_C_Coproduct(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_Coproduct"] = field()
    labels: list[str] | None = field()
    maps: list[MonotoneMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["maps"] = [item.to_data() for item in self.maps]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        maps: list[MonotoneMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new M_C_Coproduct instance."""
        kind = "MonotoneMap"
        type_ = "M_C_Coproduct"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            labels=labels,
            maps=maps,
        )


@dataclass(frozen=True)
class M_C_CoproductSmash(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_CoproductSmash"] = field()
    labels: list[str] | None = field()
    maps: list[MonotoneMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["maps"] = [item.to_data() for item in self.maps]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        maps: list[MonotoneMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new M_C_CoproductSmash instance."""
        kind = "MonotoneMap"
        type_ = "M_C_CoproductSmash"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            labels=labels,
            maps=maps,
        )


@dataclass(frozen=True)
class M_C_DomProdCodSmash(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_DomProdCodSmash"] = field()
    labels: list[str] | None = field()
    maps: list[MonotoneMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["maps"] = [item.to_data() for item in self.maps]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        maps: list[MonotoneMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new M_C_DomProdCodSmash instance."""
        kind = "MonotoneMap"
        type_ = "M_C_DomProdCodSmash"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            labels=labels,
            maps=maps,
        )


@dataclass(frozen=True)
class M_C_DomSmashCodProd(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_DomSmashCodProd"] = field()
    labels: list[str] | None = field()
    maps: list[MonotoneMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["maps"] = [item.to_data() for item in self.maps]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        maps: list[MonotoneMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new M_C_DomSmashCodProd instance."""
        kind = "MonotoneMap"
        type_ = "M_C_DomSmashCodProd"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            labels=labels,
            maps=maps,
        )


@dataclass(frozen=True)
class M_C_DomUnion(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_DomUnion"] = field()
    labels: list[str] | None = field()
    maps: list[MonotoneMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["maps"] = [item.to_data() for item in self.maps]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        maps: list[MonotoneMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new M_C_DomUnion instance."""
        kind = "MonotoneMap"
        type_ = "M_C_DomUnion"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            labels=labels,
            maps=maps,
        )


@dataclass(frozen=True)
class M_C_Leq_X(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_Leq_X"] = field()
    opspace: Poset = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_C_Leq_X instance."""
        kind = "MonotoneMap"
        type_ = "M_C_Leq_X"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
            value=value,
        )


@dataclass(frozen=True)
class M_C_LiftToSubsets(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_LiftToSubsets"] = field()
    m: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        m: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_C_LiftToSubsets instance."""
        kind = "MonotoneMap"
        type_ = "M_C_LiftToSubsets"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class M_C_Lt_X(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_Lt_X"] = field()
    opspace: Poset = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_C_Lt_X instance."""
        kind = "MonotoneMap"
        type_ = "M_C_Lt_X"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
            value=value,
        )


@dataclass(frozen=True)
class M_C_Op(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_Op"] = field()
    m: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        m: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_C_Op instance."""
        kind = "MonotoneMap"
        type_ = "M_C_Op"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class M_C_Parallel(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_Parallel"] = field()
    labels: list[str] | None = field()
    maps: list[MonotoneMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["maps"] = [item.to_data() for item in self.maps]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        maps: list[MonotoneMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new M_C_Parallel instance."""
        kind = "MonotoneMap"
        type_ = "M_C_Parallel"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            labels=labels,
            maps=maps,
        )


@dataclass(frozen=True)
class M_C_ParallelSmash(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_ParallelSmash"] = field()
    labels: list[str] | None = field()
    maps: list[MonotoneMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["maps"] = [item.to_data() for item in self.maps]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        maps: list[MonotoneMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new M_C_ParallelSmash instance."""
        kind = "MonotoneMap"
        type_ = "M_C_ParallelSmash"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            labels=labels,
            maps=maps,
        )


@dataclass(frozen=True)
class M_C_Product(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_Product"] = field()
    labels: list[str] | None = field()
    maps: list[MonotoneMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["maps"] = [item.to_data() for item in self.maps]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        maps: list[MonotoneMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new M_C_Product instance."""
        kind = "MonotoneMap"
        type_ = "M_C_Product"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            labels=labels,
            maps=maps,
        )


@dataclass(frozen=True)
class M_C_ProductSmash(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_ProductSmash"] = field()
    labels: list[str] | None = field()
    maps: list[MonotoneMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["maps"] = [item.to_data() for item in self.maps]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        maps: list[MonotoneMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new M_C_ProductSmash instance."""
        kind = "MonotoneMap"
        type_ = "M_C_ProductSmash"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            labels=labels,
            maps=maps,
        )


@dataclass(frozen=True)
class M_C_RefineDomain(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_RefineDomain"] = field()
    m: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        m: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_C_RefineDomain instance."""
        kind = "MonotoneMap"
        type_ = "M_C_RefineDomain"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class M_C_Series(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_Series"] = field()
    labels: list[str] | None = field()
    maps: list[MonotoneMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["maps"] = [item.to_data() for item in self.maps]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        maps: list[MonotoneMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new M_C_Series instance."""
        kind = "MonotoneMap"
        type_ = "M_C_Series"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            labels=labels,
            maps=maps,
        )


@dataclass(frozen=True)
class M_C_Sum(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_Sum"] = field()
    labels: list[str] | None = field()
    maps: list[MonotoneMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["maps"] = [item.to_data() for item in self.maps]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        maps: list[MonotoneMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new M_C_Sum instance."""
        kind = "MonotoneMap"
        type_ = "M_C_Sum"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            labels=labels,
            maps=maps,
        )


@dataclass(frozen=True)
class M_C_SumSmash(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_SumSmash"] = field()
    labels: list[str] | None = field()
    maps: list[MonotoneMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["maps"] = [item.to_data() for item in self.maps]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        maps: list[MonotoneMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new M_C_SumSmash instance."""
        kind = "MonotoneMap"
        type_ = "M_C_SumSmash"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            labels=labels,
            maps=maps,
        )


@dataclass(frozen=True)
class M_C_WrapUnits(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_C_WrapUnits"] = field()
    cod_units: Unit = field()
    dom_units: Unit = field()
    m: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["cod_units"] = self.cod_units.to_data()
        result["dom_units"] = self.dom_units.to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        cod_units: Unit,
        dom_units: Unit,
        m: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_C_WrapUnits instance."""
        kind = "MonotoneMap"
        type_ = "M_C_WrapUnits"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            cod_units=cod_units,
            dom_units=dom_units,
            m=m,
        )


@dataclass(frozen=True)
class M_Ceil0(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Ceil0"] = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_Ceil0 instance."""
        kind = "MonotoneMap"
        type_ = "M_Ceil0"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
        )


@dataclass(frozen=True)
class M_Coerce(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Coerce"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, cod: Poset, dom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new M_Coerce instance."""
        kind = "MonotoneMap"
        type_ = "M_Coerce"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
        )


@dataclass(frozen=True)
class M_Constant(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Constant"] = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_Constant instance."""
        kind = "MonotoneMap"
        type_ = "M_Constant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            value=value,
        )


@dataclass(frozen=True)
class M_ContainedInLowerSet(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_ContainedInLowerSet"] = field()
    lower_set: LowerSet = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["lower_set"] = self.lower_set.to_data()
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        lower_set: LowerSet,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_ContainedInLowerSet instance."""
        kind = "MonotoneMap"
        type_ = "M_ContainedInLowerSet"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            lower_set=lower_set,
            opspace=opspace,
        )


@dataclass(frozen=True)
class M_ContainedInUpperSet(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_ContainedInUpperSet"] = field()
    opspace: Poset = field()
    upper_set: UpperSet = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        result["upper_set"] = self.upper_set.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        upper_set: UpperSet,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_ContainedInUpperSet instance."""
        kind = "MonotoneMap"
        type_ = "M_ContainedInUpperSet"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
            upper_set=upper_set,
        )


@dataclass(frozen=True)
class M_DivideLConstant(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_DivideLConstant"] = field()
    opspace: Poset = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_DivideLConstant instance."""
        kind = "MonotoneMap"
        type_ = "M_DivideLConstant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
            value=value,
        )


@dataclass(frozen=True)
class M_DivideUConstant(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_DivideUConstant"] = field()
    opspace: Poset = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_DivideUConstant instance."""
        kind = "MonotoneMap"
        type_ = "M_DivideUConstant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
            value=value,
        )


@dataclass(frozen=True)
class M_Empty(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Empty"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, cod: Poset, dom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new M_Empty instance."""
        kind = "MonotoneMap"
        type_ = "M_Empty"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
        )


@dataclass(frozen=True)
class M_Explicit(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Explicit"] = field()
    options: list[M_Explicit_Option] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["options"] = [item.to_data() for item in self.options]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        options: list[M_Explicit_Option],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_Explicit instance."""
        kind = "MonotoneMap"
        type_ = "M_Explicit"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            options=options,
        )


@dataclass(frozen=True)
class M_Explicit_Option:
    x: Any = field()
    y: Any = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["x"] = self.x
        result["y"] = self.y
        return result

    @classmethod
    def make(cls, *, x: Any, y: Any) -> Self:
        """Create a new M_Explicit_Option instance."""
        return cls(
            x=x,
            y=y,
        )


@dataclass(frozen=True)
class M_Floor0(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Floor0"] = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_Floor0 instance."""
        kind = "MonotoneMap"
        type_ = "M_Floor0"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
        )


@dataclass(frozen=True)
class M_Id(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Id"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, cod: Poset, dom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new M_Id instance."""
        kind = "MonotoneMap"
        type_ = "M_Id"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
        )


@dataclass(frozen=True)
class M_IdentityBelowThreshold(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_IdentityBelowThreshold"] = field()
    threshold: Value = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["threshold"] = self.threshold.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        threshold: Value,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_IdentityBelowThreshold instance."""
        kind = "MonotoneMap"
        type_ = "M_IdentityBelowThreshold"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            threshold=threshold,
            value=value,
        )


@dataclass(frozen=True)
class M_Injection(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Injection"] = field()
    index: int = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["index"] = self.index
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        index: int,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_Injection instance."""
        kind = "MonotoneMap"
        type_ = "M_Injection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            index=index,
        )


@dataclass(frozen=True)
class M_Join(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Join"] = field()
    opspaces: list[Poset] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspaces"] = [item.to_data() for item in self.opspaces]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspaces: list[Poset],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_Join instance."""
        kind = "MonotoneMap"
        type_ = "M_Join"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspaces=opspaces,
        )


@dataclass(frozen=True)
class M_JoinConstant(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_JoinConstant"] = field()
    opspace: Poset = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_JoinConstant instance."""
        kind = "MonotoneMap"
        type_ = "M_JoinConstant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
            value=value,
        )


@dataclass(frozen=True)
class M_Leq(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Leq"] = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_Leq instance."""
        kind = "MonotoneMap"
        type_ = "M_Leq"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
        )


@dataclass(frozen=True)
class M_Lift(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Lift"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, cod: Poset, dom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new M_Lift instance."""
        kind = "MonotoneMap"
        type_ = "M_Lift"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
        )


@dataclass(frozen=True)
class M_LiftToLowerSets(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_LiftToLowerSets"] = field()
    m: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        m: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_LiftToLowerSets instance."""
        kind = "MonotoneMap"
        type_ = "M_LiftToLowerSets"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class M_LiftToUpperSets(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_LiftToUpperSets"] = field()
    m: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        m: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_LiftToUpperSets instance."""
        kind = "MonotoneMap"
        type_ = "M_LiftToUpperSets"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class M_Meet(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Meet"] = field()
    opspaces: list[Poset] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspaces"] = [item.to_data() for item in self.opspaces]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspaces: list[Poset],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_Meet instance."""
        kind = "MonotoneMap"
        type_ = "M_Meet"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspaces=opspaces,
        )


@dataclass(frozen=True)
class M_MeetConstant(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_MeetConstant"] = field()
    opspace: Poset = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_MeetConstant instance."""
        kind = "MonotoneMap"
        type_ = "M_MeetConstant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
            value=value,
        )


@dataclass(frozen=True)
class M_MultiplyL(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_MultiplyL"] = field()
    opspaces: list[Poset] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspaces"] = [item.to_data() for item in self.opspaces]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspaces: list[Poset],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_MultiplyL instance."""
        kind = "MonotoneMap"
        type_ = "M_MultiplyL"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspaces=opspaces,
        )


@dataclass(frozen=True)
class M_MultiplyLConstant(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_MultiplyLConstant"] = field()
    opspace: Poset = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_MultiplyLConstant instance."""
        kind = "MonotoneMap"
        type_ = "M_MultiplyLConstant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
            value=value,
        )


@dataclass(frozen=True)
class M_MultiplyU(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_MultiplyU"] = field()
    opspaces: list[Poset] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspaces"] = [item.to_data() for item in self.opspaces]
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspaces: list[Poset],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_MultiplyU instance."""
        kind = "MonotoneMap"
        type_ = "M_MultiplyU"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspaces=opspaces,
        )


@dataclass(frozen=True)
class M_MultiplyUConstant(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_MultiplyUConstant"] = field()
    opspace: Poset = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_MultiplyUConstant instance."""
        kind = "MonotoneMap"
        type_ = "M_MultiplyUConstant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
            value=value,
        )


@dataclass(frozen=True)
class M_PowerFracL(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_PowerFracL"] = field()
    den: str = field()
    num: str = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["den"] = self.den
        result["num"] = self.num
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        den: str,
        num: str,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_PowerFracL instance."""
        kind = "MonotoneMap"
        type_ = "M_PowerFracL"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            den=den,
            num=num,
            opspace=opspace,
        )


@dataclass(frozen=True)
class M_PowerFracU(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_PowerFracU"] = field()
    den: str = field()
    num: str = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["den"] = self.den
        result["num"] = self.num
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        den: str,
        num: str,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_PowerFracU instance."""
        kind = "MonotoneMap"
        type_ = "M_PowerFracU"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            den=den,
            num=num,
            opspace=opspace,
        )


@dataclass(frozen=True)
class M_ReprLowerSet(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_ReprLowerSet"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, cod: Poset, dom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new M_ReprLowerSet instance."""
        kind = "MonotoneMap"
        type_ = "M_ReprLowerSet"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
        )


@dataclass(frozen=True)
class M_ReprUpperSet(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_ReprUpperSet"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, cod: Poset, dom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new M_ReprUpperSet instance."""
        kind = "MonotoneMap"
        type_ = "M_ReprUpperSet"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
        )


@dataclass(frozen=True)
class M_RepresentPrincipalLowerSet_TotalOrderBounded(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_RepresentPrincipalLowerSet_TotalOrderBounded"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, cod: Poset, dom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new M_RepresentPrincipalLowerSet_TotalOrderBounded instance."""
        kind = "MonotoneMap"
        type_ = "M_RepresentPrincipalLowerSet_TotalOrderBounded"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
        )


@dataclass(frozen=True)
class M_RepresentPrincipalUpperSet_TotalOrderBounded(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_RepresentPrincipalUpperSet_TotalOrderBounded"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, cod: Poset, dom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new M_RepresentPrincipalUpperSet_TotalOrderBounded instance."""
        kind = "MonotoneMap"
        type_ = "M_RepresentPrincipalUpperSet_TotalOrderBounded"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
        )


@dataclass(frozen=True)
class M_RoundDown(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_RoundDown"] = field()
    offset: Any = field()
    opspace: Poset = field()
    step: str = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["offset"] = self.offset
        result["opspace"] = self.opspace.to_data()
        result["step"] = self.step
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        offset: Any,
        opspace: Poset,
        step: str,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_RoundDown instance."""
        kind = "MonotoneMap"
        type_ = "M_RoundDown"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            offset=offset,
            opspace=opspace,
            step=step,
        )


@dataclass(frozen=True)
class M_RoundUp(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_RoundUp"] = field()
    offset: Any = field()
    opspace: Poset = field()
    step: str = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["offset"] = self.offset
        result["opspace"] = self.opspace.to_data()
        result["step"] = self.step
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        offset: Any,
        opspace: Poset,
        step: str,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_RoundUp instance."""
        kind = "MonotoneMap"
        type_ = "M_RoundUp"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            offset=offset,
            opspace=opspace,
            step=step,
        )


@dataclass(frozen=True)
class M_ScaleL(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_ScaleL"] = field()
    den: str = field()
    num: str = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["den"] = self.den
        result["num"] = self.num
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        den: str,
        num: str,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_ScaleL instance."""
        kind = "MonotoneMap"
        type_ = "M_ScaleL"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            den=den,
            num=num,
            opspace=opspace,
        )


@dataclass(frozen=True)
class M_ScaleU(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_ScaleU"] = field()
    den: str = field()
    num: str = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["den"] = self.den
        result["num"] = self.num
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        den: str,
        num: str,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_ScaleU instance."""
        kind = "MonotoneMap"
        type_ = "M_ScaleU"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            den=den,
            num=num,
            opspace=opspace,
        )


@dataclass(frozen=True)
class M_SmashInjection(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_SmashInjection"] = field()
    index: int = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["index"] = self.index
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        index: int,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_SmashInjection instance."""
        kind = "MonotoneMap"
        type_ = "M_SmashInjection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            index=index,
        )


@dataclass(frozen=True)
class M_SubLConstant(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_SubLConstant"] = field()
    opspace: Poset = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_SubLConstant instance."""
        kind = "MonotoneMap"
        type_ = "M_SubLConstant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
            value=value,
        )


@dataclass(frozen=True)
class M_SubUConstant(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_SubUConstant"] = field()
    opspace: Poset = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_SubUConstant instance."""
        kind = "MonotoneMap"
        type_ = "M_SubUConstant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
            value=value,
        )


@dataclass(frozen=True)
class M_TakeIndex(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_TakeIndex"] = field()
    projection: Projection = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["projection"] = self.projection.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        projection: Projection,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_TakeIndex instance."""
        kind = "MonotoneMap"
        type_ = "M_TakeIndex"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            projection=projection,
        )


@dataclass(frozen=True)
class M_TakeRange(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_TakeRange"] = field()
    range: Range = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["range"] = self.range.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        range: Range,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_TakeRange instance."""
        kind = "MonotoneMap"
        type_ = "M_TakeRange"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            range=range,
        )


@dataclass(frozen=True)
class M_Threshold1(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Threshold1"] = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_Threshold1 instance."""
        kind = "MonotoneMap"
        type_ = "M_Threshold1"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            value=value,
        )


@dataclass(frozen=True)
class M_Threshold2(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Threshold2"] = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_Threshold2 instance."""
        kind = "MonotoneMap"
        type_ = "M_Threshold2"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            value=value,
        )


@dataclass(frozen=True)
class M_TopIfNotBottom(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_TopIfNotBottom"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, cod: Poset, dom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new M_TopIfNotBottom instance."""
        kind = "MonotoneMap"
        type_ = "M_TopIfNotBottom"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
        )


@dataclass(frozen=True)
class M_Undefined(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Undefined"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, cod: Poset, dom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new M_Undefined instance."""
        kind = "MonotoneMap"
        type_ = "M_Undefined"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
        )


@dataclass(frozen=True)
class M_Unknown(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Unknown"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, cod: Poset, dom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new M_Unknown instance."""
        kind = "MonotoneMap"
        type_ = "M_Unknown"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
        )


@dataclass(frozen=True)
class M_Unlift(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_Unlift"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, cod: Poset, dom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new M_Unlift instance."""
        kind = "MonotoneMap"
        type_ = "M_Unlift"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
        )


@dataclass(frozen=True)
class M_X_Leq_C(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_X_Leq_C"] = field()
    opspace: Poset = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_X_Leq_C instance."""
        kind = "MonotoneMap"
        type_ = "M_X_Leq_C"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
            value=value,
        )


@dataclass(frozen=True)
class M_X_Lt_C(MonotoneMap):
    kind: Literal["MonotoneMap"] = field()
    type_: Literal["M_X_Lt_C"] = field()
    opspace: Poset = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        cod: Poset,
        dom: Poset,
        opspace: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new M_X_Lt_C instance."""
        kind = "MonotoneMap"
        type_ = "M_X_Lt_C"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            cod=cod,
            dom=dom,
            type_=type_,
            opspace=opspace,
            value=value,
        )


@dataclass(frozen=True)
class MapCheck(Check):
    kind: Literal["Check"] = field()
    type_: Literal["MapCheck"] = field()
    data: list[MapCheck_Data] = field()
    m: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["data"] = [item.to_data() for item in self.data]
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        data: list[MapCheck_Data],
        m: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new MapCheck instance."""
        kind = "Check"
        type_ = "MapCheck"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            type_=type_,
            data=data,
            m=m,
        )


@dataclass(frozen=True)
class MapCheck_Data:
    x: Any = field()
    y: Any = field()
    elapsed: float | None = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        if self.elapsed is not None:
            result["elapsed"] = self.elapsed
        result["x"] = self.x
        result["y"] = self.y
        return result

    @classmethod
    def make(cls, *, x: Any, y: Any, elapsed: float | None = None) -> Self:
        """Create a new MapCheck_Data instance."""
        return cls(
            elapsed=elapsed,
            x=x,
            y=y,
        )


@dataclass(frozen=True)
class ModelFunctionality(ConnectionSource):
    type_: Literal["ModelFunctionality"] = field()
    functionality: str = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["functionality"] = self.functionality
        return result

    @classmethod
    def make(cls, *, functionality: str) -> Self:
        """Create a new ModelFunctionality instance."""
        type_ = "ModelFunctionality"
        return cls(
            type_=type_,
            functionality=functionality,
        )


@dataclass(frozen=True)
class ModelRequirement(ConnectionTarget):
    type_: Literal["ModelRequirement"] = field()
    requirement: str = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["requirement"] = self.requirement
        return result

    @classmethod
    def make(cls, *, requirement: str) -> Self:
        """Create a new ModelRequirement instance."""
        type_ = "ModelRequirement"
        return cls(
            type_=type_,
            requirement=requirement,
        )


@dataclass(frozen=True)
class NDP(Root):
    kind: Literal["NDP"] = field()
    C: Poset = field()
    F: dict[str, Poset] = field()
    J: Poset = field()
    R: dict[str, Poset] = field()
    address: Address | None = field()
    type_: Literal["NDP_Composite", "NDP_Simple", "NDP_Sum", "NDP_TemplateHole"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["C"] = self.C.to_data()
        result["F"] = {k: v.to_data() for k, v in self.F.items()}
        result["J"] = self.J.to_data()
        result["R"] = {k: v.to_data() for k, v in self.R.items()}
        if self.address is not None:
            result["address"] = self.address.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class NDPInterface(Root):
    kind: Literal["NDPInterface"] = field()
    address: Address | None = field()
    type_: Literal["NDPInterface_Explicit"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.address is not None:
            result["address"] = self.address.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class NDPInterface_Explicit(NDPInterface):
    kind: Literal["NDPInterface"] = field()
    fs: dict[str, Poset] = field()
    rs: dict[str, Poset] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["fs"] = {k: v.to_data() for k, v in self.fs.items()}
        result["rs"] = {k: v.to_data() for k, v in self.rs.items()}
        return result

    @classmethod
    def make(
        cls,
        *,
        fs: dict[str, Poset],
        rs: dict[str, Poset],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new NDPInterface_Explicit instance."""
        kind = "NDPInterface"
        type_ = "NDPInterface_Explicit"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            fs=fs,
            rs=rs,
        )


@dataclass(frozen=True)
class NDPTemplate(Root):
    kind: Literal["NDPTemplate"] = field()
    address: Address | None = field()
    type_: Literal["NDPTemplate_Simple"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.address is not None:
            result["address"] = self.address.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class NDPTemplate_Simple(NDPTemplate):
    kind: Literal["NDPTemplate"] = field()
    ndp: NDP = field()
    parameters: dict[str, NDPInterface] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["ndp"] = self.ndp.to_data()
        result["parameters"] = {k: v.to_data() for k, v in self.parameters.items()}
        return result

    @classmethod
    def make(
        cls,
        *,
        ndp: NDP,
        parameters: dict[str, NDPInterface],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new NDPTemplate_Simple instance."""
        kind = "NDPTemplate"
        type_ = "NDPTemplate_Simple"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            ndp=ndp,
            parameters=parameters,
        )


@dataclass(frozen=True)
class NDP_Composite(NDP):
    kind: Literal["NDP"] = field()
    type_: Literal["NDP_Composite"] = field()
    connections: list[Connection] = field()
    nodes: dict[str, NDP] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["connections"] = [item.to_data() for item in self.connections]
        result["nodes"] = {k: v.to_data() for k, v in self.nodes.items()}
        return result

    @classmethod
    def make(
        cls,
        *,
        C: Poset,
        F: dict[str, Poset],
        J: Poset,
        R: dict[str, Poset],
        connections: list[Connection],
        nodes: dict[str, NDP],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new NDP_Composite instance."""
        kind = "NDP"
        type_ = "NDP_Composite"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            C=C,
            F=F,
            J=J,
            R=R,
            address=address,
            type_=type_,
            connections=connections,
            nodes=nodes,
        )


@dataclass(frozen=True)
class NDP_Simple(NDP):
    kind: Literal["NDP"] = field()
    type_: Literal["NDP_Simple"] = field()
    dp: DP = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["dp"] = self.dp.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        C: Poset,
        F: dict[str, Poset],
        J: Poset,
        R: dict[str, Poset],
        dp: DP,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new NDP_Simple instance."""
        kind = "NDP"
        type_ = "NDP_Simple"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            C=C,
            F=F,
            J=J,
            R=R,
            address=address,
            type_=type_,
            dp=dp,
        )


@dataclass(frozen=True)
class NDP_Sum(NDP):
    kind: Literal["NDP"] = field()
    type_: Literal["NDP_Sum"] = field()
    dps: dict[str, NDP] = field()
    labels: list[str] | None = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["dps"] = {k: v.to_data() for k, v in self.dps.items()}
        if self.labels is not None:
            result["labels"] = self.labels
        return result

    @classmethod
    def make(
        cls,
        *,
        C: Poset,
        F: dict[str, Poset],
        J: Poset,
        R: dict[str, Poset],
        dps: dict[str, NDP],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new NDP_Sum instance."""
        kind = "NDP"
        type_ = "NDP_Sum"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            C=C,
            F=F,
            J=J,
            R=R,
            address=address,
            type_=type_,
            dps=dps,
            labels=labels,
        )


@dataclass(frozen=True)
class NDP_TemplateHole(NDP):
    kind: Literal["NDP"] = field()
    type_: Literal["NDP_TemplateHole"] = field()
    parameter_name: str = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["parameter_name"] = self.parameter_name
        return result

    @classmethod
    def make(
        cls,
        *,
        C: Poset,
        F: dict[str, Poset],
        J: Poset,
        R: dict[str, Poset],
        parameter_name: str,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new NDP_TemplateHole instance."""
        kind = "NDP"
        type_ = "NDP_TemplateHole"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            C=C,
            F=F,
            J=J,
            R=R,
            address=address,
            type_=type_,
            parameter_name=parameter_name,
        )


@dataclass(frozen=True)
class NodeFunctionality(ConnectionTarget):
    type_: Literal["NodeFunctionality"] = field()
    node: str = field()
    node_functionality: str = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["node"] = self.node
        result["node_functionality"] = self.node_functionality
        return result

    @classmethod
    def make(cls, *, node: str, node_functionality: str) -> Self:
        """Create a new NodeFunctionality instance."""
        type_ = "NodeFunctionality"
        return cls(
            type_=type_,
            node=node,
            node_functionality=node_functionality,
        )


@dataclass(frozen=True)
class NodeRequirement(ConnectionSource):
    type_: Literal["NodeRequirement"] = field()
    node: str = field()
    node_requirement: str = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["node"] = self.node
        result["node_requirement"] = self.node_requirement
        return result

    @classmethod
    def make(cls, *, node: str, node_requirement: str) -> Self:
        """Create a new NodeRequirement instance."""
        type_ = "NodeRequirement"
        return cls(
            type_=type_,
            node=node,
            node_requirement=node_requirement,
        )


@dataclass(frozen=True)
class Poset(Root):
    kind: Literal["Poset"] = field()
    address: Address | None = field()
    type_: Literal[
        "P_Bool",
        "P_C_Arrow",
        "P_C_Discretized",
        "P_C_Lexicographic",
        "P_C_LowerSets",
        "P_C_Multisets",
        "P_C_Opposite",
        "P_C_Power",
        "P_C_Product",
        "P_C_ProductDS",
        "P_C_ProductSmash",
        "P_C_Sum",
        "P_C_SumSmash",
        "P_C_Twisted",
        "P_C_Units",
        "P_C_UpperSets",
        "P_Decimal",
        "P_F_Bounded",
        "P_F_C_Intersection",
        "P_F_C_Union",
        "P_F_Interval",
        "P_F_LowerClosure",
        "P_F_Subposet",
        "P_F_UpperClosure",
        "P_Finite",
        "P_Float",
        "P_Fractions",
        "P_Integer",
        "P_Unknown",
    ] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.address is not None:
            result["address"] = self.address.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class P_Bool(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_Bool"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_Bool instance."""
        kind = "Poset"
        type_ = "P_Bool"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
        )

    # Valid examples
    __examples__ = [
        {"kind": "Poset", "type": "P_Bool"},
    ]


@dataclass(frozen=True)
class P_C_Arrow(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_C_Arrow"] = field()
    poset: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["poset"] = self.poset.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        poset: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_C_Arrow instance."""
        kind = "Poset"
        type_ = "P_C_Arrow"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            poset=poset,
        )

    # Valid examples
    __examples__ = [
        {"kind": "Poset", "poset": {"kind": "Poset", "type": "P_Decimal"}, "type": "P_C_Arrow"},
    ]


@dataclass(frozen=True)
class P_C_Discretized(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_C_Discretized"] = field()
    poset: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["poset"] = self.poset.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        poset: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_C_Discretized instance."""
        kind = "Poset"
        type_ = "P_C_Discretized"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            poset=poset,
        )

    # Valid examples
    __examples__ = [
        {"kind": "Poset", "poset": {"kind": "Poset", "type": "P_Bool"}, "type": "P_C_Discretized"},
    ]


@dataclass(frozen=True)
class P_C_Lexicographic(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_C_Lexicographic"] = field()
    labels: list[str] | None = field()
    subs: list[Poset] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["subs"] = [item.to_data() for item in self.subs]
        return result

    @classmethod
    def make(
        cls,
        *,
        subs: list[Poset],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new P_C_Lexicographic instance."""
        kind = "Poset"
        type_ = "P_C_Lexicographic"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            labels=labels,
            subs=subs,
        )

    # Valid examples
    __examples__ = [
        {
            "kind": "Poset",
            "subs": [{"kind": "Poset", "type": "P_Decimal"}, {"kind": "Poset", "type": "P_Bool"}],
            "type": "P_C_Lexicographic",
        },
    ]


@dataclass(frozen=True)
class P_C_LowerSets(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_C_LowerSets"] = field()
    poset: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["poset"] = self.poset.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        poset: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_C_LowerSets instance."""
        kind = "Poset"
        type_ = "P_C_LowerSets"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            poset=poset,
        )

    # Valid examples
    __examples__ = [
        {"kind": "Poset", "poset": {"kind": "Poset", "type": "P_Decimal"}, "type": "P_C_LowerSets"},
    ]


@dataclass(frozen=True)
class P_C_Multisets(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_C_Multisets"] = field()
    counts: Poset = field()
    values: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["counts"] = self.counts.to_data()
        result["values"] = self.values.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        counts: Poset,
        values: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_C_Multisets instance."""
        kind = "Poset"
        type_ = "P_C_Multisets"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            counts=counts,
            values=values,
        )


@dataclass(frozen=True)
class P_C_Opposite(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_C_Opposite"] = field()
    poset: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["poset"] = self.poset.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        poset: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_C_Opposite instance."""
        kind = "Poset"
        type_ = "P_C_Opposite"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            poset=poset,
        )

    # Valid examples
    __examples__ = [
        {"kind": "Poset", "poset": {"kind": "Poset", "type": "P_Decimal"}, "type": "P_C_Opposite"},
    ]


@dataclass(frozen=True)
class P_C_Power(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_C_Power"] = field()
    poset: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["poset"] = self.poset.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        poset: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_C_Power instance."""
        kind = "Poset"
        type_ = "P_C_Power"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            poset=poset,
        )

    # Valid examples
    __examples__ = [
        {"kind": "Poset", "poset": {"kind": "Poset", "type": "P_Decimal"}, "type": "P_C_Power"},
    ]


@dataclass(frozen=True)
class P_C_Product(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_C_Product"] = field()
    labels: list[str] | None = field()
    subs: list[Poset] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["subs"] = [item.to_data() for item in self.subs]
        return result

    @classmethod
    def make(
        cls,
        *,
        subs: list[Poset],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new P_C_Product instance."""
        kind = "Poset"
        type_ = "P_C_Product"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            labels=labels,
            subs=subs,
        )

    # Valid examples
    __examples__ = [
        {
            "kind": "Poset",
            "subs": [{"kind": "Poset", "type": "P_Decimal"}, {"kind": "Poset", "type": "P_Bool"}],
            "type": "P_C_Product",
        },
        {"kind": "Poset", "subs": [], "type": "P_C_Product"},
    ]


@dataclass(frozen=True)
class P_C_ProductDS(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_C_ProductDS"] = field()
    labels: list[str] | None = field()
    subs: list[Poset] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["subs"] = [item.to_data() for item in self.subs]
        return result

    @classmethod
    def make(
        cls,
        *,
        subs: list[Poset],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new P_C_ProductDS instance."""
        kind = "Poset"
        type_ = "P_C_ProductDS"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            labels=labels,
            subs=subs,
        )


@dataclass(frozen=True)
class P_C_ProductSmash(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_C_ProductSmash"] = field()
    labels: list[str] | None = field()
    naked: list[bool] = field()
    ranges: list[Range] = field()
    subs: list[Poset] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["naked"] = self.naked
        result["ranges"] = [item.to_data() for item in self.ranges]
        result["subs"] = [item.to_data() for item in self.subs]
        return result

    @classmethod
    def make(
        cls,
        *,
        naked: list[bool],
        ranges: list[Range],
        subs: list[Poset],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new P_C_ProductSmash instance."""
        kind = "Poset"
        type_ = "P_C_ProductSmash"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            labels=labels,
            naked=naked,
            ranges=ranges,
            subs=subs,
        )

    # Valid examples
    __examples__ = [
        {"kind": "Poset", "naked": [], "ranges": [], "subs": [], "type": "P_C_ProductSmash"},
        {
            "kind": "Poset",
            "naked": [true, false, true],
            "ranges": [
                {"ntot": 4, "start": 0, "stop": 1, "type": "Range"},
                {"ntot": 4, "start": 1, "stop": 3, "type": "Range"},
                {"ntot": 4, "start": 3, "stop": 4, "type": "Range"},
            ],
            "subs": [
                {"kind": "Poset", "type": "P_Decimal"},
                {
                    "kind": "Poset",
                    "naked": [true, true],
                    "ranges": [
                        {"ntot": 2, "start": 0, "stop": 1, "type": "Range"},
                        {"ntot": 2, "start": 1, "stop": 2, "type": "Range"},
                    ],
                    "subs": [{"kind": "Poset", "type": "P_Decimal"}, {"kind": "Poset", "type": "P_Bool"}],
                    "type": "P_C_ProductSmash",
                },
                {"kind": "Poset", "type": "P_Decimal"},
            ],
            "type": "P_C_ProductSmash",
        },
    ]


@dataclass(frozen=True)
class P_C_Sum(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_C_Sum"] = field()
    labels: list[str] | None = field()
    subs: list[Poset] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["subs"] = [item.to_data() for item in self.subs]
        return result

    @classmethod
    def make(
        cls,
        *,
        subs: list[Poset],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new P_C_Sum instance."""
        kind = "Poset"
        type_ = "P_C_Sum"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            labels=labels,
            subs=subs,
        )

    # Valid examples
    __examples__ = [
        {
            "kind": "Poset",
            "subs": [{"kind": "Poset", "type": "P_Decimal"}, {"kind": "Poset", "type": "P_Bool"}],
            "type": "P_C_Sum",
        },
    ]


@dataclass(frozen=True)
class P_C_SumSmash(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_C_SumSmash"] = field()
    labels: list[str] | None = field()
    naked: list[bool] = field()
    ranges: list[Range] = field()
    subs: list[Poset] = field()
    trivial: bool = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["naked"] = self.naked
        result["ranges"] = [item.to_data() for item in self.ranges]
        result["subs"] = [item.to_data() for item in self.subs]
        result["trivial"] = self.trivial
        return result

    @classmethod
    def make(
        cls,
        *,
        naked: list[bool],
        ranges: list[Range],
        subs: list[Poset],
        trivial: bool,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new P_C_SumSmash instance."""
        kind = "Poset"
        type_ = "P_C_SumSmash"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            labels=labels,
            naked=naked,
            ranges=ranges,
            subs=subs,
            trivial=trivial,
        )

    # Valid examples
    __examples__ = [
        {
            "kind": "Poset",
            "naked": [true, true],
            "ranges": [{"ntot": 2, "start": 0, "stop": 1, "type": "Range"}, {"ntot": 2, "start": 0, "stop": 1, "type": "Range"}],
            "subs": [{"kind": "Poset", "type": "P_Decimal"}, {"kind": "Poset", "type": "P_Bool"}],
            "trivial": false,
            "type": "P_C_SumSmash",
        },
    ]


@dataclass(frozen=True)
class P_C_Twisted(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_C_Twisted"] = field()
    poset: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["poset"] = self.poset.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        poset: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_C_Twisted instance."""
        kind = "Poset"
        type_ = "P_C_Twisted"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            poset=poset,
        )

    # Valid examples
    __examples__ = [
        {"kind": "Poset", "poset": {"kind": "Poset", "type": "P_Decimal"}, "type": "P_C_Twisted"},
    ]


@dataclass(frozen=True)
class P_C_Units(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_C_Units"] = field()
    poset: Poset = field()
    units: Unit = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["poset"] = self.poset.to_data()
        result["units"] = self.units.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        poset: Poset,
        units: Unit,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_C_Units instance."""
        kind = "Poset"
        type_ = "P_C_Units"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            poset=poset,
            units=units,
        )

    # Valid examples
    __examples__ = [
        {
            "kind": "Poset",
            "poset": {"kind": "Poset", "type": "P_Decimal"},
            "type": "P_C_Units",
            "units": {"kind": "Unit", "type": "Unit_Single", "units": "m^2/s"},
        },
        {
            "kind": "Poset",
            "poset": {
                "kind": "Poset",
                "subs": [{"kind": "Poset", "type": "P_Decimal"}, {"kind": "Poset", "type": "P_Decimal"}],
                "type": "P_C_Product",
            },
            "type": "P_C_Units",
            "units": {
                "kind": "Unit",
                "subs": [
                    {"kind": "Unit", "type": "Unit_Single", "units": "m"},
                    {"kind": "Unit", "type": "Unit_Single", "units": "g"},
                ],
                "type": "Unit_Vector",
            },
        },
    ]


@dataclass(frozen=True)
class P_C_UpperSets(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_C_UpperSets"] = field()
    poset: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["poset"] = self.poset.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        poset: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_C_UpperSets instance."""
        kind = "Poset"
        type_ = "P_C_UpperSets"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            poset=poset,
        )

    # Valid examples
    __examples__ = [
        {"kind": "Poset", "poset": {"kind": "Poset", "type": "P_Decimal"}, "type": "P_C_UpperSets"},
    ]


@dataclass(frozen=True)
class P_Decimal(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_Decimal"] = field()
    precision: int = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["precision"] = self.precision
        return result

    @classmethod
    def make(
        cls,
        *,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
        precision: int = json.loads("9"),
    ) -> Self:
        """Create a new P_Decimal instance."""
        kind = "Poset"
        type_ = "P_Decimal"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            precision=precision,
        )

    # Valid examples
    __examples__ = [
        {"kind": "Poset", "precision": 9, "type": "P_Decimal"},
    ]


@dataclass(frozen=True)
class P_F_Bounded(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_F_Bounded"] = field()
    bottom: Any = field()
    bound_high: Any = field()
    bound_low: Any = field()
    offset: Any = field()
    poset: Poset = field()
    step: str = field()
    top: Any = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["bottom"] = self.bottom
        result["bound_high"] = self.bound_high
        result["bound_low"] = self.bound_low
        result["offset"] = self.offset
        result["poset"] = self.poset.to_data()
        result["step"] = self.step
        result["top"] = self.top
        return result

    @classmethod
    def make(
        cls,
        *,
        bottom: Any,
        bound_high: Any,
        bound_low: Any,
        offset: Any,
        poset: Poset,
        step: str,
        top: Any,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_F_Bounded instance."""
        kind = "Poset"
        type_ = "P_F_Bounded"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            bottom=bottom,
            bound_high=bound_high,
            bound_low=bound_low,
            offset=offset,
            poset=poset,
            step=step,
            top=top,
        )

    # Valid examples
    __examples__ = [
        {
            "bottom": "0",
            "bound_high": "+inf",
            "bound_low": "0",
            "kind": "Poset",
            "offset": "0",
            "poset": {"kind": "Poset", "type": "P_Decimal"},
            "step": "1",
            "top": "+inf",
            "type": "P_F_Bounded",
        },
        {
            "bottom": "-inf",
            "bound_high": "+inf",
            "bound_low": "-inf",
            "kind": "Poset",
            "offset": "1",
            "poset": {"kind": "Poset", "type": "P_Decimal"},
            "step": "2",
            "top": "+inf",
            "type": "P_F_Bounded",
        },
        {
            "bottom": "-inf",
            "bound_high": "6",
            "bound_low": "0",
            "kind": "Poset",
            "offset": "0",
            "poset": {"kind": "Poset", "type": "P_Decimal"},
            "step": "1.5",
            "top": "+inf",
            "type": "P_F_Bounded",
        },
    ]


@dataclass(frozen=True)
class P_F_C_Intersection(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_F_C_Intersection"] = field()
    ambient: Poset = field()
    labels: list[str] | None = field()
    subs: list[Poset] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["ambient"] = self.ambient.to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["subs"] = [item.to_data() for item in self.subs]
        return result

    @classmethod
    def make(
        cls,
        *,
        ambient: Poset,
        subs: list[Poset],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new P_F_C_Intersection instance."""
        kind = "Poset"
        type_ = "P_F_C_Intersection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            ambient=ambient,
            labels=labels,
            subs=subs,
        )


@dataclass(frozen=True)
class P_F_C_Union(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_F_C_Union"] = field()
    ambient: Poset = field()
    labels: list[str] | None = field()
    subs: list[Poset] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["ambient"] = self.ambient.to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["subs"] = [item.to_data() for item in self.subs]
        return result

    @classmethod
    def make(
        cls,
        *,
        ambient: Poset,
        subs: list[Poset],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new P_F_C_Union instance."""
        kind = "Poset"
        type_ = "P_F_C_Union"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            ambient=ambient,
            labels=labels,
            subs=subs,
        )

    # Valid examples
    __examples__ = [
        {
            "ambient": {"kind": "Poset", "type": "P_Decimal"},
            "kind": "Poset",
            "subs": [
                {
                    "high": "20",
                    "kind": "Poset",
                    "low": "10",
                    "poset": {"kind": "Poset", "type": "P_Decimal"},
                    "type": "P_F_Interval",
                },
                {
                    "high": "35",
                    "kind": "Poset",
                    "low": "30",
                    "poset": {"kind": "Poset", "type": "P_Decimal"},
                    "type": "P_F_Interval",
                },
            ],
            "type": "P_F_C_Union",
        },
    ]


@dataclass(frozen=True)
class P_F_Interval(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_F_Interval"] = field()
    high: Any = field()
    low: Any = field()
    poset: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["high"] = self.high
        result["low"] = self.low
        result["poset"] = self.poset.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        high: Any,
        low: Any,
        poset: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_F_Interval instance."""
        kind = "Poset"
        type_ = "P_F_Interval"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            high=high,
            low=low,
            poset=poset,
        )

    # Valid examples
    __examples__ = [
        {"high": "20", "kind": "Poset", "low": "10", "poset": {"kind": "Poset", "type": "P_Decimal"}, "type": "P_F_Interval"},
    ]


@dataclass(frozen=True)
class P_F_LowerClosure(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_F_LowerClosure"] = field()
    ls: LowerSet = field()
    poset: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["ls"] = self.ls.to_data()
        result["poset"] = self.poset.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        ls: LowerSet,
        poset: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_F_LowerClosure instance."""
        kind = "Poset"
        type_ = "P_F_LowerClosure"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            ls=ls,
            poset=poset,
        )

    # Valid examples
    __examples__ = [
        {
            "kind": "Poset",
            "ls": {"kind": "LowerSet", "points": [["10", true], ["20", false]], "type": "LowerSet_LowerClosure"},
            "poset": {
                "kind": "Poset",
                "subs": [{"kind": "Poset", "type": "P_Decimal"}, {"kind": "Poset", "type": "P_Bool"}],
                "type": "P_C_Product",
            },
            "type": "P_F_LowerClosure",
        },
    ]


@dataclass(frozen=True)
class P_F_Subposet(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_F_Subposet"] = field()
    elements: list[Any] = field()
    poset: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["elements"] = self.elements
        result["poset"] = self.poset.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        elements: list[Any],
        poset: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_F_Subposet instance."""
        kind = "Poset"
        type_ = "P_F_Subposet"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            elements=elements,
            poset=poset,
        )

    # Valid examples
    __examples__ = [
        {"elements": ["0.1", "0.2"], "kind": "Poset", "poset": {"kind": "Poset", "type": "P_Decimal"}, "type": "P_F_Subposet"},
        {"elements": [], "kind": "Poset", "poset": {"kind": "Poset", "type": "P_Decimal"}, "type": "P_F_Subposet"},
    ]


@dataclass(frozen=True)
class P_F_UpperClosure(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_F_UpperClosure"] = field()
    poset: Poset = field()
    us: UpperSet = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["poset"] = self.poset.to_data()
        result["us"] = self.us.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        poset: Poset,
        us: UpperSet,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_F_UpperClosure instance."""
        kind = "Poset"
        type_ = "P_F_UpperClosure"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            poset=poset,
            us=us,
        )

    # Valid examples
    __examples__ = [
        {
            "kind": "Poset",
            "poset": {
                "kind": "Poset",
                "subs": [{"kind": "Poset", "type": "P_Decimal"}, {"kind": "Poset", "type": "P_Bool"}],
                "type": "P_C_Product",
            },
            "type": "P_F_UpperClosure",
            "us": {"kind": "UpperSet", "points": [["10", true], ["20", false]], "type": "UpperSet_UpperClosure"},
        },
    ]


@dataclass(frozen=True)
class P_Finite(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_Finite"] = field()
    aliases: dict[str, list[str]] | None = field()
    elements: list[str] = field()
    relations: list[list[str]] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.aliases is not None:
            result["aliases"] = self.aliases
        result["elements"] = self.elements
        result["relations"] = self.relations
        return result

    @classmethod
    def make(
        cls,
        *,
        elements: list[str],
        relations: list[list[str]],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
        aliases: dict[str, list[str]] | None = None,
    ) -> Self:
        """Create a new P_Finite instance."""
        kind = "Poset"
        type_ = "P_Finite"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            aliases=aliases,
            elements=elements,
            relations=relations,
        )

    # Valid examples
    __examples__ = [
        {"aliases": {}, "elements": [], "kind": "Poset", "relations": [], "type": "P_Finite"},
        {"elements": ["a", "b"], "kind": "Poset", "relations": [], "type": "P_Finite"},
        {"elements": ["a", "b"], "kind": "Poset", "relations": [["a", "b"]], "type": "P_Finite"},
        {
            "aliases": {"a": ["a1", "a2"]},
            "elements": ["a", "b", "c"],
            "kind": "Poset",
            "relations": [["a", "b"], ["b", "c"]],
            "type": "P_Finite",
        },
    ]


@dataclass(frozen=True)
class P_Float(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_Float"] = field()
    size: Literal["f8", "f16", "f32", "f64", "f80", "f128"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["size"] = self.size
        return result

    @classmethod
    def make(
        cls,
        *,
        size: Literal["f8", "f16", "f32", "f64", "f80", "f128"],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_Float instance."""
        kind = "Poset"
        type_ = "P_Float"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            size=size,
        )

    # Valid examples
    __examples__ = [
        {"kind": "Poset", "size": "f32", "type": "P_Float"},
    ]


@dataclass(frozen=True)
class P_Fractions(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_Fractions"] = field()
    max_abs_denominator: int = field()
    max_abs_numerator: int = field()
    size: Literal["i8", "i16", "i32", "i64", "i128"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["max_abs_denominator"] = self.max_abs_denominator
        result["max_abs_numerator"] = self.max_abs_numerator
        result["size"] = self.size
        return result

    @classmethod
    def make(
        cls,
        *,
        max_abs_denominator: int,
        max_abs_numerator: int,
        size: Literal["i8", "i16", "i32", "i64", "i128"],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_Fractions instance."""
        kind = "Poset"
        type_ = "P_Fractions"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            max_abs_denominator=max_abs_denominator,
            max_abs_numerator=max_abs_numerator,
            size=size,
        )

    # Valid examples
    __examples__ = [
        {"kind": "Poset", "max_abs_denominator": 1000, "max_abs_numerator": 1000, "size": "i32", "type": "P_Fractions"},
    ]


@dataclass(frozen=True)
class P_Integer(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_Integer"] = field()
    size: Literal["i8", "i16", "i32", "i64", "i128"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["size"] = self.size
        return result

    @classmethod
    def make(
        cls,
        *,
        size: Literal["i8", "i16", "i32", "i64", "i128"],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_Integer instance."""
        kind = "Poset"
        type_ = "P_Integer"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            size=size,
        )

    # Valid examples
    __examples__ = [
        {"kind": "Poset", "size": "i32", "type": "P_Integer"},
    ]


@dataclass(frozen=True)
class P_Unknown(Poset):
    kind: Literal["Poset"] = field()
    type_: Literal["P_Unknown"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new P_Unknown instance."""
        kind = "Poset"
        type_ = "P_Unknown"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
        )

    # Valid examples
    __examples__ = [
        {"kind": "Poset", "type": "P_Unknown"},
    ]


@dataclass(frozen=True)
class Projection:
    index: int = field()
    ntot: int = field()
    type_: Literal["Projection"] = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["index"] = self.index
        result["ntot"] = self.ntot
        result["type"] = self.type_
        return result

    @classmethod
    def make(cls, *, index: int, ntot: int) -> Self:
        """Create a new Projection instance."""
        type_ = "Projection"
        return cls(
            index=index,
            ntot=ntot,
            type_=type_,
        )


@dataclass(frozen=True)
class Query(Root):
    kind: Literal["Query"] = field()
    address: Address | None = field()
    type_: Literal["Query_Single"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.address is not None:
            result["address"] = self.address.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class QueryData:
    type_: Literal["QueryFixFunMinReqData", "QueryFixReqMaxFunData"] = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class QueryFixFunMinReqData(QueryData):
    type_: Literal["QueryFixFunMinReqData"] = field()
    f: dict[str, Value] | None = field()
    optimize_for: list[str] | None = field()
    r: dict[str, Value] | None = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.f is not None:
            result["f"] = {k: v.to_data() for k, v in self.f.items()}
        if self.optimize_for is not None:
            result["optimize_for"] = self.optimize_for
        if self.r is not None:
            result["r"] = {k: v.to_data() for k, v in self.r.items()}
        return result

    @classmethod
    def make(
        cls, *, f: dict[str, Value] | None = None, optimize_for: list[str] | None = None, r: dict[str, Value] | None = None
    ) -> Self:
        """Create a new QueryFixFunMinReqData instance."""
        type_ = "QueryFixFunMinReqData"
        return cls(
            type_=type_,
            f=f,
            optimize_for=optimize_for,
            r=r,
        )


@dataclass(frozen=True)
class QueryFixReqMaxFunData(QueryData):
    type_: Literal["QueryFixReqMaxFunData"] = field()
    f: dict[str, Value] | None = field()
    optimize_for: list[str] | None = field()
    r: dict[str, Value] | None = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.f is not None:
            result["f"] = {k: v.to_data() for k, v in self.f.items()}
        if self.optimize_for is not None:
            result["optimize_for"] = self.optimize_for
        if self.r is not None:
            result["r"] = {k: v.to_data() for k, v in self.r.items()}
        return result

    @classmethod
    def make(
        cls, *, f: dict[str, Value] | None = None, optimize_for: list[str] | None = None, r: dict[str, Value] | None = None
    ) -> Self:
        """Create a new QueryFixReqMaxFunData instance."""
        type_ = "QueryFixReqMaxFunData"
        return cls(
            type_=type_,
            f=f,
            optimize_for=optimize_for,
            r=r,
        )


@dataclass(frozen=True)
class Query_Single(Query):
    kind: Literal["Query"] = field()
    model: NDP = field()
    query_data: QueryData = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["model"] = self.model.to_data()
        result["query_data"] = self.query_data.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        model: NDP,
        query_data: QueryData,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new Query_Single instance."""
        kind = "Query"
        type_ = "Query_Single"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            model=model,
            query_data=query_data,
        )


@dataclass(frozen=True)
class Range:
    ntot: int = field()
    start: int = field()
    stop: int = field()
    type_: Literal["Range"] = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["ntot"] = self.ntot
        result["start"] = self.start
        result["stop"] = self.stop
        result["type"] = self.type_
        return result

    @classmethod
    def make(cls, *, ntot: int, start: int, stop: int) -> Self:
        """Create a new Range instance."""
        type_ = "Range"
        return cls(
            ntot=ntot,
            start=start,
            stop=stop,
            type_=type_,
        )


@dataclass(frozen=True)
class SL1Check(Check):
    kind: Literal["Check"] = field()
    type_: Literal["SL1Check"] = field()
    data: list[SL1Check_Data] = field()
    m: SL1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["data"] = [item.to_data() for item in self.data]
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        data: list[SL1Check_Data],
        m: SL1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL1Check instance."""
        kind = "Check"
        type_ = "SL1Check"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            type_=type_,
            data=data,
            m=m,
        )


@dataclass(frozen=True)
class SL1Check_Data:
    opt: Any = field()
    opt_y: LowerSet = field()
    pess: Any = field()
    pess_y: LowerSet = field()
    x: Any = field()
    opt_elapsed: float | None = field()
    pess_elapsed: float | None = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["opt"] = self.opt
        if self.opt_elapsed is not None:
            result["opt_elapsed"] = self.opt_elapsed
        result["opt_y"] = self.opt_y.to_data()
        result["pess"] = self.pess
        if self.pess_elapsed is not None:
            result["pess_elapsed"] = self.pess_elapsed
        result["pess_y"] = self.pess_y.to_data()
        result["x"] = self.x
        return result

    @classmethod
    def make(
        cls,
        *,
        opt: Any,
        opt_y: LowerSet,
        pess: Any,
        pess_y: LowerSet,
        x: Any,
        opt_elapsed: float | None = None,
        pess_elapsed: float | None = None,
    ) -> Self:
        """Create a new SL1Check_Data instance."""
        return cls(
            opt=opt,
            opt_elapsed=opt_elapsed,
            opt_y=opt_y,
            pess=pess,
            pess_elapsed=pess_elapsed,
            pess_y=pess_y,
            x=x,
        )


@dataclass(frozen=True)
class SL1Map(Root):
    kind: Literal["SL1Map"] = field()
    kcod: Poset = field()
    kdom: Poset = field()
    opt: Poset = field()
    pes: Poset = field()
    type_: Literal[
        "SL1_C_CodSum",
        "SL1_C_CodSumSmash",
        "SL1_C_ExplicitApprox",
        "SL1_C_Intersection",
        "SL1_C_Parallel",
        "SL1_C_ProdIntersection",
        "SL1_C_Product",
        "SL1_C_RefineDomain",
        "SL1_C_Series",
        "SL1_C_Trace",
        "SL1_C_Union",
        "SL1_C_WrapUnits",
        "SL1_Exact",
        "SL1_Identity",
        "SL1_InvMultiply",
        "SL1_InvSum",
        "SL1_Unknown",
    ] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod"] = self.kcod.to_data()
        result["kdom"] = self.kdom.to_data()
        result["opt"] = self.opt.to_data()
        result["pes"] = self.pes.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class SL1_C_CodSum(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_C_CodSum"] = field()
    labels: list[str] | None = field()
    ms: list[SL1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SL1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SL1_C_CodSum instance."""
        kind = "SL1Map"
        type_ = "SL1_C_CodSum"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SL1_C_CodSumSmash(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_C_CodSumSmash"] = field()
    labels: list[str] | None = field()
    ms: list[SL1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SL1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SL1_C_CodSumSmash instance."""
        kind = "SL1Map"
        type_ = "SL1_C_CodSumSmash"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SL1_C_ExplicitApprox(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_C_ExplicitApprox"] = field()
    optimistic: list[L1Map] = field()
    optimistic_labels: list[str] | None = field()
    pessimistic: list[L1Map] = field()
    pessimistic_labels: list[str] | None = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["optimistic"] = [item.to_data() for item in self.optimistic]
        if self.optimistic_labels is not None:
            result["optimistic_labels"] = self.optimistic_labels
        result["pessimistic"] = [item.to_data() for item in self.pessimistic]
        if self.pessimistic_labels is not None:
            result["pessimistic_labels"] = self.pessimistic_labels
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        optimistic: list[L1Map],
        pessimistic: list[L1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        optimistic_labels: list[str] | None = None,
        pessimistic_labels: list[str] | None = None,
    ) -> Self:
        """Create a new SL1_C_ExplicitApprox instance."""
        kind = "SL1Map"
        type_ = "SL1_C_ExplicitApprox"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            optimistic=optimistic,
            optimistic_labels=optimistic_labels,
            pessimistic=pessimistic,
            pessimistic_labels=pessimistic_labels,
        )


@dataclass(frozen=True)
class SL1_C_Intersection(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_C_Intersection"] = field()
    labels: list[str] | None = field()
    ms: list[SL1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SL1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SL1_C_Intersection instance."""
        kind = "SL1Map"
        type_ = "SL1_C_Intersection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SL1_C_Parallel(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_C_Parallel"] = field()
    labels: list[str] | None = field()
    ms: list[SL1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SL1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SL1_C_Parallel instance."""
        kind = "SL1Map"
        type_ = "SL1_C_Parallel"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SL1_C_ProdIntersection(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_C_ProdIntersection"] = field()
    labels: list[str] | None = field()
    ms: list[SL1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SL1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SL1_C_ProdIntersection instance."""
        kind = "SL1Map"
        type_ = "SL1_C_ProdIntersection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SL1_C_Product(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_C_Product"] = field()
    labels: list[str] | None = field()
    ms: list[SL1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SL1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SL1_C_Product instance."""
        kind = "SL1Map"
        type_ = "SL1_C_Product"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SL1_C_RefineDomain(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_C_RefineDomain"] = field()
    m: SL1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        m: SL1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL1_C_RefineDomain instance."""
        kind = "SL1Map"
        type_ = "SL1_C_RefineDomain"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class SL1_C_Series(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_C_Series"] = field()
    labels: list[str] | None = field()
    ms: list[SL1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SL1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SL1_C_Series instance."""
        kind = "SL1Map"
        type_ = "SL1_C_Series"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SL1_C_Trace(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_C_Trace"] = field()
    m: SL1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        m: SL1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL1_C_Trace instance."""
        kind = "SL1Map"
        type_ = "SL1_C_Trace"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class SL1_C_Union(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_C_Union"] = field()
    labels: list[str] | None = field()
    ms: list[SL1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SL1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SL1_C_Union instance."""
        kind = "SL1Map"
        type_ = "SL1_C_Union"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SL1_C_WrapUnits(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_C_WrapUnits"] = field()
    kcod_units: Unit = field()
    kdom_units: Unit = field()
    m: SL1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod_units"] = self.kcod_units.to_data()
        result["kdom_units"] = self.kdom_units.to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        kcod_units: Unit,
        kdom_units: Unit,
        m: SL1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL1_C_WrapUnits instance."""
        kind = "SL1Map"
        type_ = "SL1_C_WrapUnits"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            kcod_units=kcod_units,
            kdom_units=kdom_units,
            m=m,
        )


@dataclass(frozen=True)
class SL1_Exact(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_Exact"] = field()
    m: L1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        m: L1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL1_Exact instance."""
        kind = "SL1Map"
        type_ = "SL1_Exact"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class SL1_Identity(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_Identity"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL1_Identity instance."""
        kind = "SL1Map"
        type_ = "SL1_Identity"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
        )


@dataclass(frozen=True)
class SL1_InvMultiply(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_InvMultiply"] = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL1_InvMultiply instance."""
        kind = "SL1Map"
        type_ = "SL1_InvMultiply"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            opspace=opspace,
        )


@dataclass(frozen=True)
class SL1_InvSum(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_InvSum"] = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL1_InvSum instance."""
        kind = "SL1Map"
        type_ = "SL1_InvSum"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            opspace=opspace,
        )


@dataclass(frozen=True)
class SL1_Unknown(SL1Map):
    kind: Literal["SL1Map"] = field()
    type_: Literal["SL1_Unknown"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL1_Unknown instance."""
        kind = "SL1Map"
        type_ = "SL1_Unknown"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
        )


@dataclass(frozen=True)
class SLCheck(Check):
    kind: Literal["Check"] = field()
    type_: Literal["SLCheck"] = field()
    data: list[SLCheck_Data] = field()
    m: SLMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["data"] = [item.to_data() for item in self.data]
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        data: list[SLCheck_Data],
        m: SLMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SLCheck instance."""
        kind = "Check"
        type_ = "SLCheck"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            type_=type_,
            data=data,
            m=m,
        )


@dataclass(frozen=True)
class SLCheck_Data:
    opt: Any = field()
    opt_y: LowerSet = field()
    pess: Any = field()
    pess_y: LowerSet = field()
    x: Any = field()
    opt_elapsed: float | None = field()
    pess_elapsed: float | None = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["opt"] = self.opt
        if self.opt_elapsed is not None:
            result["opt_elapsed"] = self.opt_elapsed
        result["opt_y"] = self.opt_y.to_data()
        result["pess"] = self.pess
        if self.pess_elapsed is not None:
            result["pess_elapsed"] = self.pess_elapsed
        result["pess_y"] = self.pess_y.to_data()
        result["x"] = self.x
        return result

    @classmethod
    def make(
        cls,
        *,
        opt: Any,
        opt_y: LowerSet,
        pess: Any,
        pess_y: LowerSet,
        x: Any,
        opt_elapsed: float | None = None,
        pess_elapsed: float | None = None,
    ) -> Self:
        """Create a new SLCheck_Data instance."""
        return cls(
            opt=opt,
            opt_elapsed=opt_elapsed,
            opt_y=opt_y,
            pess=pess,
            pess_elapsed=pess_elapsed,
            pess_y=pess_y,
            x=x,
        )


@dataclass(frozen=True)
class SLMap(Root):
    kind: Literal["SLMap"] = field()
    kcod: Poset = field()
    kdom: Poset = field()
    kimp: Poset = field()
    opt: Poset = field()
    pes: Poset = field()
    type_: Literal[
        "SL_C_ITransform",
        "SL_C_Intersection",
        "SL_C_Parallel",
        "SL_C_RefineDomain",
        "SL_C_Series",
        "SL_C_Trace",
        "SL_C_Union",
        "SL_C_WrapUnits",
        "SL_Identity",
        "SL_L_Exact",
        "SL_L_Explicit_Approx",
        "SL_L_Lift1_Constant",
        "SL_L_Lift1_Transform",
        "SL_Unknown",
    ] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod"] = self.kcod.to_data()
        result["kdom"] = self.kdom.to_data()
        result["kimp"] = self.kimp.to_data()
        result["opt"] = self.opt.to_data()
        result["pes"] = self.pes.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class SL_C_ITransform(SLMap):
    kind: Literal["SLMap"] = field()
    type_: Literal["SL_C_ITransform"] = field()
    m: SLMap = field()
    transform: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["transform"] = self.transform.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        m: SLMap,
        transform: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL_C_ITransform instance."""
        kind = "SLMap"
        type_ = "SL_C_ITransform"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
            transform=transform,
        )


@dataclass(frozen=True)
class SL_C_Intersection(SLMap):
    kind: Literal["SLMap"] = field()
    type_: Literal["SL_C_Intersection"] = field()
    labels: list[str] | None = field()
    ms: list[SLMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SLMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SL_C_Intersection instance."""
        kind = "SLMap"
        type_ = "SL_C_Intersection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SL_C_Parallel(SLMap):
    kind: Literal["SLMap"] = field()
    type_: Literal["SL_C_Parallel"] = field()
    labels: list[str] | None = field()
    ms: list[SLMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SLMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SL_C_Parallel instance."""
        kind = "SLMap"
        type_ = "SL_C_Parallel"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SL_C_RefineDomain(SLMap):
    kind: Literal["SLMap"] = field()
    type_: Literal["SL_C_RefineDomain"] = field()
    m: SLMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        m: SLMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL_C_RefineDomain instance."""
        kind = "SLMap"
        type_ = "SL_C_RefineDomain"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class SL_C_Series(SLMap):
    kind: Literal["SLMap"] = field()
    type_: Literal["SL_C_Series"] = field()
    labels: list[str] | None = field()
    ms: list[SLMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SLMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SL_C_Series instance."""
        kind = "SLMap"
        type_ = "SL_C_Series"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SL_C_Trace(SLMap):
    kind: Literal["SLMap"] = field()
    type_: Literal["SL_C_Trace"] = field()
    m: SLMap = field()
    m_proj: SL1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["m_proj"] = self.m_proj.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        m: SLMap,
        m_proj: SL1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL_C_Trace instance."""
        kind = "SLMap"
        type_ = "SL_C_Trace"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
            m_proj=m_proj,
        )


@dataclass(frozen=True)
class SL_C_Union(SLMap):
    kind: Literal["SLMap"] = field()
    type_: Literal["SL_C_Union"] = field()
    labels: list[str] | None = field()
    ms: list[SLMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SLMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SL_C_Union instance."""
        kind = "SLMap"
        type_ = "SL_C_Union"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SL_C_WrapUnits(SLMap):
    kind: Literal["SLMap"] = field()
    type_: Literal["SL_C_WrapUnits"] = field()
    kcod_units: Unit = field()
    kdom_units: Unit = field()
    kimp_units: Unit = field()
    m: SLMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod_units"] = self.kcod_units.to_data()
        result["kdom_units"] = self.kdom_units.to_data()
        result["kimp_units"] = self.kimp_units.to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        kcod_units: Unit,
        kdom_units: Unit,
        kimp_units: Unit,
        m: SLMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL_C_WrapUnits instance."""
        kind = "SLMap"
        type_ = "SL_C_WrapUnits"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            kcod_units=kcod_units,
            kdom_units=kdom_units,
            kimp_units=kimp_units,
            m=m,
        )


@dataclass(frozen=True)
class SL_Identity(SLMap):
    kind: Literal["SLMap"] = field()
    type_: Literal["SL_Identity"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL_Identity instance."""
        kind = "SLMap"
        type_ = "SL_Identity"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
        )


@dataclass(frozen=True)
class SL_L_Exact(SLMap):
    kind: Literal["SLMap"] = field()
    type_: Literal["SL_L_Exact"] = field()
    m: LMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        m: LMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL_L_Exact instance."""
        kind = "SLMap"
        type_ = "SL_L_Exact"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class SL_L_Explicit_Approx(SLMap):
    kind: Literal["SLMap"] = field()
    type_: Literal["SL_L_Explicit_Approx"] = field()
    optimistic: list[LMap] = field()
    optimistic_labels: list[str] | None = field()
    pessimistic: list[LMap] = field()
    pessimistic_labels: list[str] | None = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["optimistic"] = [item.to_data() for item in self.optimistic]
        if self.optimistic_labels is not None:
            result["optimistic_labels"] = self.optimistic_labels
        result["pessimistic"] = [item.to_data() for item in self.pessimistic]
        if self.pessimistic_labels is not None:
            result["pessimistic_labels"] = self.pessimistic_labels
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        optimistic: list[LMap],
        pessimistic: list[LMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        optimistic_labels: list[str] | None = None,
        pessimistic_labels: list[str] | None = None,
    ) -> Self:
        """Create a new SL_L_Explicit_Approx instance."""
        kind = "SLMap"
        type_ = "SL_L_Explicit_Approx"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            optimistic=optimistic,
            optimistic_labels=optimistic_labels,
            pessimistic=pessimistic,
            pessimistic_labels=pessimistic_labels,
        )


@dataclass(frozen=True)
class SL_L_Lift1_Constant(SLMap):
    kind: Literal["SLMap"] = field()
    type_: Literal["SL_L_Lift1_Constant"] = field()
    m: SL1Map = field()
    value: Any = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["value"] = self.value
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        m: SL1Map,
        value: Any,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL_L_Lift1_Constant instance."""
        kind = "SLMap"
        type_ = "SL_L_Lift1_Constant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
            value=value,
        )


@dataclass(frozen=True)
class SL_L_Lift1_Transform(SLMap):
    kind: Literal["SLMap"] = field()
    type_: Literal["SL_L_Lift1_Transform"] = field()
    m: SL1Map = field()
    transform: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["transform"] = self.transform.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        m: SL1Map,
        transform: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL_L_Lift1_Transform instance."""
        kind = "SLMap"
        type_ = "SL_L_Lift1_Transform"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
            transform=transform,
        )


@dataclass(frozen=True)
class SL_Unknown(SLMap):
    kind: Literal["SLMap"] = field()
    type_: Literal["SL_Unknown"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SL_Unknown instance."""
        kind = "SLMap"
        type_ = "SL_Unknown"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
        )


@dataclass(frozen=True)
class SU1Check(Check):
    kind: Literal["Check"] = field()
    type_: Literal["SU1Check"] = field()
    data: list[SU1Check_Data] = field()
    m: SU1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["data"] = [item.to_data() for item in self.data]
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        data: list[SU1Check_Data],
        m: SU1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU1Check instance."""
        kind = "Check"
        type_ = "SU1Check"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            type_=type_,
            data=data,
            m=m,
        )


@dataclass(frozen=True)
class SU1Check_Data:
    opt: Any = field()
    opt_y: UpperSet = field()
    pess: Any = field()
    pess_y: UpperSet = field()
    x: Any = field()
    opt_elapsed: float | None = field()
    pess_elapsed: float | None = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["opt"] = self.opt
        if self.opt_elapsed is not None:
            result["opt_elapsed"] = self.opt_elapsed
        result["opt_y"] = self.opt_y.to_data()
        result["pess"] = self.pess
        if self.pess_elapsed is not None:
            result["pess_elapsed"] = self.pess_elapsed
        result["pess_y"] = self.pess_y.to_data()
        result["x"] = self.x
        return result

    @classmethod
    def make(
        cls,
        *,
        opt: Any,
        opt_y: UpperSet,
        pess: Any,
        pess_y: UpperSet,
        x: Any,
        opt_elapsed: float | None = None,
        pess_elapsed: float | None = None,
    ) -> Self:
        """Create a new SU1Check_Data instance."""
        return cls(
            opt=opt,
            opt_elapsed=opt_elapsed,
            opt_y=opt_y,
            pess=pess,
            pess_elapsed=pess_elapsed,
            pess_y=pess_y,
            x=x,
        )


@dataclass(frozen=True)
class SU1Map(Root):
    kind: Literal["SU1Map"] = field()
    kcod: Poset = field()
    kdom: Poset = field()
    opt: Poset = field()
    pes: Poset = field()
    type_: Literal[
        "SU1_C_CodSum",
        "SU1_C_CodSumSmash",
        "SU1_C_ExplicitApprox",
        "SU1_C_Intersection",
        "SU1_C_Parallel",
        "SU1_C_ProdIntersection",
        "SU1_C_Product",
        "SU1_C_RefineDomain",
        "SU1_C_Series",
        "SU1_C_Trace",
        "SU1_C_Union",
        "SU1_C_WrapUnits",
        "SU1_Exact",
        "SU1_Identity",
        "SU1_InvMultiply",
        "SU1_InvSum",
        "SU1_Unknown",
    ] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod"] = self.kcod.to_data()
        result["kdom"] = self.kdom.to_data()
        result["opt"] = self.opt.to_data()
        result["pes"] = self.pes.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class SU1_C_CodSum(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_C_CodSum"] = field()
    labels: list[str] | None = field()
    ms: list[SU1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SU1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SU1_C_CodSum instance."""
        kind = "SU1Map"
        type_ = "SU1_C_CodSum"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SU1_C_CodSumSmash(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_C_CodSumSmash"] = field()
    labels: list[str] | None = field()
    ms: list[SU1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SU1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SU1_C_CodSumSmash instance."""
        kind = "SU1Map"
        type_ = "SU1_C_CodSumSmash"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SU1_C_ExplicitApprox(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_C_ExplicitApprox"] = field()
    optimistic: list[U1Map] = field()
    optimistic_labels: list[str] | None = field()
    pessimistic: list[U1Map] = field()
    pessimistic_labels: list[str] | None = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["optimistic"] = [item.to_data() for item in self.optimistic]
        if self.optimistic_labels is not None:
            result["optimistic_labels"] = self.optimistic_labels
        result["pessimistic"] = [item.to_data() for item in self.pessimistic]
        if self.pessimistic_labels is not None:
            result["pessimistic_labels"] = self.pessimistic_labels
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        optimistic: list[U1Map],
        pessimistic: list[U1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        optimistic_labels: list[str] | None = None,
        pessimistic_labels: list[str] | None = None,
    ) -> Self:
        """Create a new SU1_C_ExplicitApprox instance."""
        kind = "SU1Map"
        type_ = "SU1_C_ExplicitApprox"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            optimistic=optimistic,
            optimistic_labels=optimistic_labels,
            pessimistic=pessimistic,
            pessimistic_labels=pessimistic_labels,
        )


@dataclass(frozen=True)
class SU1_C_Intersection(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_C_Intersection"] = field()
    labels: list[str] | None = field()
    ms: list[SU1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SU1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SU1_C_Intersection instance."""
        kind = "SU1Map"
        type_ = "SU1_C_Intersection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SU1_C_Parallel(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_C_Parallel"] = field()
    labels: list[str] | None = field()
    ms: list[SU1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SU1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SU1_C_Parallel instance."""
        kind = "SU1Map"
        type_ = "SU1_C_Parallel"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SU1_C_ProdIntersection(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_C_ProdIntersection"] = field()
    labels: list[str] | None = field()
    ms: list[SU1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SU1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SU1_C_ProdIntersection instance."""
        kind = "SU1Map"
        type_ = "SU1_C_ProdIntersection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SU1_C_Product(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_C_Product"] = field()
    labels: list[str] | None = field()
    ms: list[SU1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SU1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SU1_C_Product instance."""
        kind = "SU1Map"
        type_ = "SU1_C_Product"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SU1_C_RefineDomain(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_C_RefineDomain"] = field()
    m: SU1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        m: SU1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU1_C_RefineDomain instance."""
        kind = "SU1Map"
        type_ = "SU1_C_RefineDomain"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class SU1_C_Series(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_C_Series"] = field()
    labels: list[str] | None = field()
    ms: list[SU1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SU1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SU1_C_Series instance."""
        kind = "SU1Map"
        type_ = "SU1_C_Series"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SU1_C_Trace(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_C_Trace"] = field()
    m: SU1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        m: SU1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU1_C_Trace instance."""
        kind = "SU1Map"
        type_ = "SU1_C_Trace"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class SU1_C_Union(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_C_Union"] = field()
    labels: list[str] | None = field()
    ms: list[SU1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SU1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SU1_C_Union instance."""
        kind = "SU1Map"
        type_ = "SU1_C_Union"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SU1_C_WrapUnits(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_C_WrapUnits"] = field()
    kcod_units: Unit = field()
    kdom_units: Unit = field()
    m: SU1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod_units"] = self.kcod_units.to_data()
        result["kdom_units"] = self.kdom_units.to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        kcod_units: Unit,
        kdom_units: Unit,
        m: SU1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU1_C_WrapUnits instance."""
        kind = "SU1Map"
        type_ = "SU1_C_WrapUnits"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            kcod_units=kcod_units,
            kdom_units=kdom_units,
            m=m,
        )


@dataclass(frozen=True)
class SU1_Exact(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_Exact"] = field()
    m: U1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        m: U1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU1_Exact instance."""
        kind = "SU1Map"
        type_ = "SU1_Exact"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class SU1_Identity(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_Identity"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU1_Identity instance."""
        kind = "SU1Map"
        type_ = "SU1_Identity"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
        )


@dataclass(frozen=True)
class SU1_InvMultiply(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_InvMultiply"] = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU1_InvMultiply instance."""
        kind = "SU1Map"
        type_ = "SU1_InvMultiply"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            opspace=opspace,
        )


@dataclass(frozen=True)
class SU1_InvSum(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_InvSum"] = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU1_InvSum instance."""
        kind = "SU1Map"
        type_ = "SU1_InvSum"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
            opspace=opspace,
        )


@dataclass(frozen=True)
class SU1_Unknown(SU1Map):
    kind: Literal["SU1Map"] = field()
    type_: Literal["SU1_Unknown"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        opt: Poset,
        pes: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU1_Unknown instance."""
        kind = "SU1Map"
        type_ = "SU1_Unknown"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            opt=opt,
            pes=pes,
            type_=type_,
        )


@dataclass(frozen=True)
class SUCheck(Check):
    kind: Literal["Check"] = field()
    type_: Literal["SUCheck"] = field()
    data: list[SUCheck_Data] = field()
    m: SUMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["data"] = [item.to_data() for item in self.data]
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        data: list[SUCheck_Data],
        m: SUMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SUCheck instance."""
        kind = "Check"
        type_ = "SUCheck"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            type_=type_,
            data=data,
            m=m,
        )


@dataclass(frozen=True)
class SUCheck_Data:
    opt: Any = field()
    opt_y: UpperSet = field()
    pess: Any = field()
    pess_y: UpperSet = field()
    x: Any = field()
    opt_elapsed: float | None = field()
    pess_elapsed: float | None = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["opt"] = self.opt
        if self.opt_elapsed is not None:
            result["opt_elapsed"] = self.opt_elapsed
        result["opt_y"] = self.opt_y.to_data()
        result["pess"] = self.pess
        if self.pess_elapsed is not None:
            result["pess_elapsed"] = self.pess_elapsed
        result["pess_y"] = self.pess_y.to_data()
        result["x"] = self.x
        return result

    @classmethod
    def make(
        cls,
        *,
        opt: Any,
        opt_y: UpperSet,
        pess: Any,
        pess_y: UpperSet,
        x: Any,
        opt_elapsed: float | None = None,
        pess_elapsed: float | None = None,
    ) -> Self:
        """Create a new SUCheck_Data instance."""
        return cls(
            opt=opt,
            opt_elapsed=opt_elapsed,
            opt_y=opt_y,
            pess=pess,
            pess_elapsed=pess_elapsed,
            pess_y=pess_y,
            x=x,
        )


@dataclass(frozen=True)
class SUMap(Root):
    kind: Literal["SUMap"] = field()
    kcod: Poset = field()
    kdom: Poset = field()
    kimp: Poset = field()
    opt: Poset = field()
    pes: Poset = field()
    type_: Literal[
        "SU_C_ITransform",
        "SU_C_Intersection",
        "SU_C_Parallel",
        "SU_C_RefineDomain",
        "SU_C_Series",
        "SU_C_Trace",
        "SU_C_Union",
        "SU_C_WrapUnits",
        "SU_Identity",
        "SU_L_Exact",
        "SU_L_Explicit_Approx",
        "SU_L_Lift1_Constant",
        "SU_L_Lift1_Transform",
        "SU_Unknown",
    ] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod"] = self.kcod.to_data()
        result["kdom"] = self.kdom.to_data()
        result["kimp"] = self.kimp.to_data()
        result["opt"] = self.opt.to_data()
        result["pes"] = self.pes.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class SU_C_ITransform(SUMap):
    kind: Literal["SUMap"] = field()
    type_: Literal["SU_C_ITransform"] = field()
    m: SUMap = field()
    transform: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["transform"] = self.transform.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        m: SUMap,
        transform: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU_C_ITransform instance."""
        kind = "SUMap"
        type_ = "SU_C_ITransform"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
            transform=transform,
        )


@dataclass(frozen=True)
class SU_C_Intersection(SUMap):
    kind: Literal["SUMap"] = field()
    type_: Literal["SU_C_Intersection"] = field()
    labels: list[str] | None = field()
    ms: list[SUMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SUMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SU_C_Intersection instance."""
        kind = "SUMap"
        type_ = "SU_C_Intersection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SU_C_Parallel(SUMap):
    kind: Literal["SUMap"] = field()
    type_: Literal["SU_C_Parallel"] = field()
    labels: list[str] | None = field()
    ms: list[SUMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SUMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SU_C_Parallel instance."""
        kind = "SUMap"
        type_ = "SU_C_Parallel"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SU_C_RefineDomain(SUMap):
    kind: Literal["SUMap"] = field()
    type_: Literal["SU_C_RefineDomain"] = field()
    m: SUMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        m: SUMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU_C_RefineDomain instance."""
        kind = "SUMap"
        type_ = "SU_C_RefineDomain"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class SU_C_Series(SUMap):
    kind: Literal["SUMap"] = field()
    type_: Literal["SU_C_Series"] = field()
    labels: list[str] | None = field()
    ms: list[SUMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SUMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SU_C_Series instance."""
        kind = "SUMap"
        type_ = "SU_C_Series"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SU_C_Trace(SUMap):
    kind: Literal["SUMap"] = field()
    type_: Literal["SU_C_Trace"] = field()
    m: SUMap = field()
    m_proj: SU1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["m_proj"] = self.m_proj.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        m: SUMap,
        m_proj: SU1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU_C_Trace instance."""
        kind = "SUMap"
        type_ = "SU_C_Trace"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
            m_proj=m_proj,
        )


@dataclass(frozen=True)
class SU_C_Union(SUMap):
    kind: Literal["SUMap"] = field()
    type_: Literal["SU_C_Union"] = field()
    labels: list[str] | None = field()
    ms: list[SUMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        ms: list[SUMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new SU_C_Union instance."""
        kind = "SUMap"
        type_ = "SU_C_Union"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class SU_C_WrapUnits(SUMap):
    kind: Literal["SUMap"] = field()
    type_: Literal["SU_C_WrapUnits"] = field()
    kcod_units: Unit = field()
    kdom_units: Unit = field()
    kimp_units: Unit = field()
    m: SUMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod_units"] = self.kcod_units.to_data()
        result["kdom_units"] = self.kdom_units.to_data()
        result["kimp_units"] = self.kimp_units.to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        kcod_units: Unit,
        kdom_units: Unit,
        kimp_units: Unit,
        m: SUMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU_C_WrapUnits instance."""
        kind = "SUMap"
        type_ = "SU_C_WrapUnits"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            kcod_units=kcod_units,
            kdom_units=kdom_units,
            kimp_units=kimp_units,
            m=m,
        )


@dataclass(frozen=True)
class SU_Identity(SUMap):
    kind: Literal["SUMap"] = field()
    type_: Literal["SU_Identity"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU_Identity instance."""
        kind = "SUMap"
        type_ = "SU_Identity"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
        )


@dataclass(frozen=True)
class SU_L_Exact(SUMap):
    kind: Literal["SUMap"] = field()
    type_: Literal["SU_L_Exact"] = field()
    m: UMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        m: UMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU_L_Exact instance."""
        kind = "SUMap"
        type_ = "SU_L_Exact"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class SU_L_Explicit_Approx(SUMap):
    kind: Literal["SUMap"] = field()
    type_: Literal["SU_L_Explicit_Approx"] = field()
    optimistic: list[UMap] = field()
    optimistic_labels: list[str] | None = field()
    pessimistic: list[UMap] = field()
    pessimistic_labels: list[str] | None = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["optimistic"] = [item.to_data() for item in self.optimistic]
        if self.optimistic_labels is not None:
            result["optimistic_labels"] = self.optimistic_labels
        result["pessimistic"] = [item.to_data() for item in self.pessimistic]
        if self.pessimistic_labels is not None:
            result["pessimistic_labels"] = self.pessimistic_labels
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        optimistic: list[UMap],
        pessimistic: list[UMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        optimistic_labels: list[str] | None = None,
        pessimistic_labels: list[str] | None = None,
    ) -> Self:
        """Create a new SU_L_Explicit_Approx instance."""
        kind = "SUMap"
        type_ = "SU_L_Explicit_Approx"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            optimistic=optimistic,
            optimistic_labels=optimistic_labels,
            pessimistic=pessimistic,
            pessimistic_labels=pessimistic_labels,
        )


@dataclass(frozen=True)
class SU_L_Lift1_Constant(SUMap):
    kind: Literal["SUMap"] = field()
    type_: Literal["SU_L_Lift1_Constant"] = field()
    m: SU1Map = field()
    value: Any = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["value"] = self.value
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        m: SU1Map,
        value: Any,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU_L_Lift1_Constant instance."""
        kind = "SUMap"
        type_ = "SU_L_Lift1_Constant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
            value=value,
        )


@dataclass(frozen=True)
class SU_L_Lift1_Transform(SUMap):
    kind: Literal["SUMap"] = field()
    type_: Literal["SU_L_Lift1_Transform"] = field()
    m: SU1Map = field()
    transform: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["transform"] = self.transform.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        m: SU1Map,
        transform: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU_L_Lift1_Transform instance."""
        kind = "SUMap"
        type_ = "SU_L_Lift1_Transform"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
            m=m,
            transform=transform,
        )


@dataclass(frozen=True)
class SU_Unknown(SUMap):
    kind: Literal["SUMap"] = field()
    type_: Literal["SU_Unknown"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        opt: Poset,
        pes: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new SU_Unknown instance."""
        kind = "SUMap"
        type_ = "SU_Unknown"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            opt=opt,
            pes=pes,
            type_=type_,
        )


@dataclass(frozen=True)
class U1Check(Check):
    kind: Literal["Check"] = field()
    type_: Literal["U1Check"] = field()
    data: list[U1Check_Data] = field()
    m: U1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["data"] = [item.to_data() for item in self.data]
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        data: list[U1Check_Data],
        m: U1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1Check instance."""
        kind = "Check"
        type_ = "U1Check"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            type_=type_,
            data=data,
            m=m,
        )


@dataclass(frozen=True)
class U1Check_Data:
    x: Any = field()
    y: UpperSet = field()
    elapsed: float | None = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        if self.elapsed is not None:
            result["elapsed"] = self.elapsed
        result["x"] = self.x
        result["y"] = self.y.to_data()
        return result

    @classmethod
    def make(cls, *, x: Any, y: UpperSet, elapsed: float | None = None) -> Self:
        """Create a new U1Check_Data instance."""
        return cls(
            elapsed=elapsed,
            x=x,
            y=y,
        )


@dataclass(frozen=True)
class U1Map(Root):
    kind: Literal["U1Map"] = field()
    kcod: Poset = field()
    kdom: Poset = field()
    type_: Literal[
        "U1_C_CodSum",
        "U1_C_CodSumSmash",
        "U1_C_DomUnion",
        "U1_C_Intersection",
        "U1_C_Parallel",
        "U1_C_ProdIntersection",
        "U1_C_Product",
        "U1_C_RefineDomain",
        "U1_C_Series",
        "U1_C_Trace",
        "U1_C_Union",
        "U1_C_WrapUnits",
        "U1_Catalog",
        "U1_Constant",
        "U1_Entire",
        "U1_Explicit",
        "U1_FromFilter",
        "U1_Identity",
        "U1_IntersectionOfPrinUpperSets",
        "U1_InvMul_Opt",
        "U1_InvMul_Pes",
        "U1_InvSum_Opt",
        "U1_InvSum_Pes",
        "U1_L_Uinv",
        "U1_Lift",
        "U1_RepresentPrincipalUpperSet",
        "U1_Uinv_Join",
        "U1_Uinv_JoinConstant",
        "U1_UnionOfPrinUpperSets",
        "U1_Unknown",
    ] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod"] = self.kcod.to_data()
        result["kdom"] = self.kdom.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class U1_C_CodSum(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_C_CodSum"] = field()
    labels: list[str] | None = field()
    ms: list[U1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[U1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new U1_C_CodSum instance."""
        kind = "U1Map"
        type_ = "U1_C_CodSum"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class U1_C_CodSumSmash(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_C_CodSumSmash"] = field()
    labels: list[str] | None = field()
    ms: list[U1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[U1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new U1_C_CodSumSmash instance."""
        kind = "U1Map"
        type_ = "U1_C_CodSumSmash"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class U1_C_DomUnion(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_C_DomUnion"] = field()
    labels: list[str] | None = field()
    ms: list[U1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[U1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new U1_C_DomUnion instance."""
        kind = "U1Map"
        type_ = "U1_C_DomUnion"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class U1_C_Intersection(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_C_Intersection"] = field()
    labels: list[str] | None = field()
    ms: list[U1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[U1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new U1_C_Intersection instance."""
        kind = "U1Map"
        type_ = "U1_C_Intersection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class U1_C_Parallel(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_C_Parallel"] = field()
    labels: list[str] | None = field()
    ms: list[U1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[U1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new U1_C_Parallel instance."""
        kind = "U1Map"
        type_ = "U1_C_Parallel"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class U1_C_ProdIntersection(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_C_ProdIntersection"] = field()
    labels: list[str] | None = field()
    ms: list[U1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[U1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new U1_C_ProdIntersection instance."""
        kind = "U1Map"
        type_ = "U1_C_ProdIntersection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class U1_C_Product(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_C_Product"] = field()
    labels: list[str] | None = field()
    ms: list[U1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[U1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new U1_C_Product instance."""
        kind = "U1Map"
        type_ = "U1_C_Product"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class U1_C_RefineDomain(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_C_RefineDomain"] = field()
    m: U1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        m: U1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1_C_RefineDomain instance."""
        kind = "U1Map"
        type_ = "U1_C_RefineDomain"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class U1_C_Series(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_C_Series"] = field()
    labels: list[str] | None = field()
    ms: list[U1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[U1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new U1_C_Series instance."""
        kind = "U1Map"
        type_ = "U1_C_Series"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class U1_C_Trace(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_C_Trace"] = field()
    m: U1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        m: U1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1_C_Trace instance."""
        kind = "U1Map"
        type_ = "U1_C_Trace"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class U1_C_Union(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_C_Union"] = field()
    labels: list[str] | None = field()
    ms: list[U1Map] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        ms: list[U1Map],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new U1_C_Union instance."""
        kind = "U1Map"
        type_ = "U1_C_Union"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class U1_C_WrapUnits(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_C_WrapUnits"] = field()
    kcod_units: Unit = field()
    kdom_units: Unit = field()
    m: U1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod_units"] = self.kcod_units.to_data()
        result["kdom_units"] = self.kdom_units.to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kcod_units: Unit,
        kdom_units: Unit,
        m: U1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1_C_WrapUnits instance."""
        kind = "U1Map"
        type_ = "U1_C_WrapUnits"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            kcod_units=kcod_units,
            kdom_units=kdom_units,
            m=m,
        )


@dataclass(frozen=True)
class U1_Catalog(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_Catalog"] = field()
    options: list[U1_Catalog_Options] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["options"] = [item.to_data() for item in self.options]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        options: list[U1_Catalog_Options],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1_Catalog instance."""
        kind = "U1Map"
        type_ = "U1_Catalog"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            options=options,
        )


@dataclass(frozen=True)
class U1_Catalog_Options:
    f: Any = field()
    r: Any = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["f"] = self.f
        result["r"] = self.r
        return result

    @classmethod
    def make(cls, *, f: Any, r: Any) -> Self:
        """Create a new U1_Catalog_Options instance."""
        return cls(
            f=f,
            r=r,
        )


@dataclass(frozen=True)
class U1_Constant(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_Constant"] = field()
    value: UpperSet = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        value: UpperSet,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1_Constant instance."""
        kind = "U1Map"
        type_ = "U1_Constant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            value=value,
        )


@dataclass(frozen=True)
class U1_Entire(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_Entire"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, kcod: Poset, kdom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new U1_Entire instance."""
        kind = "U1Map"
        type_ = "U1_Entire"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
        )


@dataclass(frozen=True)
class U1_Explicit(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_Explicit"] = field()
    options: list[U1_Explicit_Option] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["options"] = [item.to_data() for item in self.options]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        options: list[U1_Explicit_Option],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1_Explicit instance."""
        kind = "U1Map"
        type_ = "U1_Explicit"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            options=options,
        )


@dataclass(frozen=True)
class U1_Explicit_Option:
    x: Any = field()
    y: UpperSet = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["x"] = self.x
        result["y"] = self.y.to_data()
        return result

    @classmethod
    def make(cls, *, x: Any, y: UpperSet) -> Self:
        """Create a new U1_Explicit_Option instance."""
        return cls(
            x=x,
            y=y,
        )


@dataclass(frozen=True)
class U1_FromFilter(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_FromFilter"] = field()
    m: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        m: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1_FromFilter instance."""
        kind = "U1Map"
        type_ = "U1_FromFilter"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class U1_Identity(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_Identity"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, kcod: Poset, kdom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new U1_Identity instance."""
        kind = "U1Map"
        type_ = "U1_Identity"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
        )


@dataclass(frozen=True)
class U1_IntersectionOfPrinUpperSets(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_IntersectionOfPrinUpperSets"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, kcod: Poset, kdom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new U1_IntersectionOfPrinUpperSets instance."""
        kind = "U1Map"
        type_ = "U1_IntersectionOfPrinUpperSets"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
        )


@dataclass(frozen=True)
class U1_InvMul_Opt(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_InvMul_Opt"] = field()
    n: int = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["n"] = self.n
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        n: int,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1_InvMul_Opt instance."""
        kind = "U1Map"
        type_ = "U1_InvMul_Opt"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            n=n,
            opspace=opspace,
        )


@dataclass(frozen=True)
class U1_InvMul_Pes(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_InvMul_Pes"] = field()
    n: int = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["n"] = self.n
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        n: int,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1_InvMul_Pes instance."""
        kind = "U1Map"
        type_ = "U1_InvMul_Pes"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            n=n,
            opspace=opspace,
        )


@dataclass(frozen=True)
class U1_InvSum_Opt(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_InvSum_Opt"] = field()
    n: int = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["n"] = self.n
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        n: int,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1_InvSum_Opt instance."""
        kind = "U1Map"
        type_ = "U1_InvSum_Opt"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            n=n,
            opspace=opspace,
        )


@dataclass(frozen=True)
class U1_InvSum_Pes(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_InvSum_Pes"] = field()
    n: int = field()
    opspace: Poset = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["n"] = self.n
        result["opspace"] = self.opspace.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        n: int,
        opspace: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1_InvSum_Pes instance."""
        kind = "U1Map"
        type_ = "U1_InvSum_Pes"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            n=n,
            opspace=opspace,
        )


@dataclass(frozen=True)
class U1_L_Uinv(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_L_Uinv"] = field()
    m: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        m: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1_L_Uinv instance."""
        kind = "U1Map"
        type_ = "U1_L_Uinv"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class U1_Lift(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_Lift"] = field()
    m: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        m: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1_Lift instance."""
        kind = "U1Map"
        type_ = "U1_Lift"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class U1_RepresentPrincipalUpperSet(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_RepresentPrincipalUpperSet"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, kcod: Poset, kdom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new U1_RepresentPrincipalUpperSet instance."""
        kind = "U1Map"
        type_ = "U1_RepresentPrincipalUpperSet"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
        )


@dataclass(frozen=True)
class U1_Uinv_Join(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_Uinv_Join"] = field()
    lower_bounds: list[list[Any]] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["lower_bounds"] = self.lower_bounds
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        lower_bounds: list[list[Any]],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1_Uinv_Join instance."""
        kind = "U1Map"
        type_ = "U1_Uinv_Join"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            lower_bounds=lower_bounds,
        )


@dataclass(frozen=True)
class U1_Uinv_JoinConstant(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_Uinv_JoinConstant"] = field()
    join1_dom: Poset = field()
    value: Value = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["join1_dom"] = self.join1_dom.to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        join1_dom: Poset,
        value: Value,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U1_Uinv_JoinConstant instance."""
        kind = "U1Map"
        type_ = "U1_Uinv_JoinConstant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
            join1_dom=join1_dom,
            value=value,
        )


@dataclass(frozen=True)
class U1_UnionOfPrinUpperSets(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_UnionOfPrinUpperSets"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, kcod: Poset, kdom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new U1_UnionOfPrinUpperSets instance."""
        kind = "U1Map"
        type_ = "U1_UnionOfPrinUpperSets"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
        )


@dataclass(frozen=True)
class U1_Unknown(U1Map):
    kind: Literal["U1Map"] = field()
    type_: Literal["U1_Unknown"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls, *, kcod: Poset, kdom: Poset, description: str | None = None, hash: str | None = None, version: str | None = None
    ) -> Self:
        """Create a new U1_Unknown instance."""
        kind = "U1Map"
        type_ = "U1_Unknown"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            type_=type_,
        )


@dataclass(frozen=True)
class UCheck(Check):
    kind: Literal["Check"] = field()
    type_: Literal["UCheck"] = field()
    data: list[UCheck_Data] = field()
    m: UMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["data"] = [item.to_data() for item in self.data]
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        data: list[UCheck_Data],
        m: UMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new UCheck instance."""
        kind = "Check"
        type_ = "UCheck"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            type_=type_,
            data=data,
            m=m,
        )


@dataclass(frozen=True)
class UCheck_Data:
    x: Any = field()
    y: UpperSet = field()
    elapsed: float | None = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        if self.elapsed is not None:
            result["elapsed"] = self.elapsed
        result["x"] = self.x
        result["y"] = self.y.to_data()
        return result

    @classmethod
    def make(cls, *, x: Any, y: UpperSet, elapsed: float | None = None) -> Self:
        """Create a new UCheck_Data instance."""
        return cls(
            elapsed=elapsed,
            x=x,
            y=y,
        )


@dataclass(frozen=True)
class UMap(Root):
    kind: Literal["UMap"] = field()
    kcod: Poset = field()
    kdom: Poset = field()
    kimp: Poset = field()
    type_: Literal[
        "U_C_ITransform",
        "U_C_Intersection",
        "U_C_Parallel",
        "U_C_RefineDomain",
        "U_C_Series",
        "U_C_Trace",
        "U_C_Union",
        "U_C_WrapUnits",
        "U_Catalog",
        "U_Constant",
        "U_Identity",
        "U_L_Lift1_Constant",
        "U_L_Lift1_Transform",
        "U_Unknown",
    ] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod"] = self.kcod.to_data()
        result["kdom"] = self.kdom.to_data()
        result["kimp"] = self.kimp.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class U_C_ITransform(UMap):
    kind: Literal["UMap"] = field()
    type_: Literal["U_C_ITransform"] = field()
    m: UMap = field()
    transform: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["transform"] = self.transform.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        m: UMap,
        transform: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U_C_ITransform instance."""
        kind = "UMap"
        type_ = "U_C_ITransform"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            m=m,
            transform=transform,
        )


@dataclass(frozen=True)
class U_C_Intersection(UMap):
    kind: Literal["UMap"] = field()
    type_: Literal["U_C_Intersection"] = field()
    labels: list[str] | None = field()
    ms: list[UMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        ms: list[UMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new U_C_Intersection instance."""
        kind = "UMap"
        type_ = "U_C_Intersection"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class U_C_Parallel(UMap):
    kind: Literal["UMap"] = field()
    type_: Literal["U_C_Parallel"] = field()
    labels: list[str] | None = field()
    ms: list[UMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        ms: list[UMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new U_C_Parallel instance."""
        kind = "UMap"
        type_ = "U_C_Parallel"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class U_C_RefineDomain(UMap):
    kind: Literal["UMap"] = field()
    type_: Literal["U_C_RefineDomain"] = field()
    m: UMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        m: UMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U_C_RefineDomain instance."""
        kind = "UMap"
        type_ = "U_C_RefineDomain"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            m=m,
        )


@dataclass(frozen=True)
class U_C_Series(UMap):
    kind: Literal["UMap"] = field()
    type_: Literal["U_C_Series"] = field()
    labels: list[str] | None = field()
    ms: list[UMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        ms: list[UMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new U_C_Series instance."""
        kind = "UMap"
        type_ = "U_C_Series"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class U_C_Trace(UMap):
    kind: Literal["UMap"] = field()
    type_: Literal["U_C_Trace"] = field()
    m: UMap = field()
    m_proj: U1Map = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["m_proj"] = self.m_proj.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        m: UMap,
        m_proj: U1Map,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U_C_Trace instance."""
        kind = "UMap"
        type_ = "U_C_Trace"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            m=m,
            m_proj=m_proj,
        )


@dataclass(frozen=True)
class U_C_Union(UMap):
    kind: Literal["UMap"] = field()
    type_: Literal["U_C_Union"] = field()
    labels: list[str] | None = field()
    ms: list[UMap] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["ms"] = [item.to_data() for item in self.ms]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        ms: list[UMap],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        labels: list[str] | None = None,
    ) -> Self:
        """Create a new U_C_Union instance."""
        kind = "UMap"
        type_ = "U_C_Union"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            labels=labels,
            ms=ms,
        )


@dataclass(frozen=True)
class U_C_WrapUnits(UMap):
    kind: Literal["UMap"] = field()
    type_: Literal["U_C_WrapUnits"] = field()
    kcod_units: Unit = field()
    kdom_units: Unit = field()
    kimp_units: Unit = field()
    m: UMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["kcod_units"] = self.kcod_units.to_data()
        result["kdom_units"] = self.kdom_units.to_data()
        result["kimp_units"] = self.kimp_units.to_data()
        result["m"] = self.m.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        kcod_units: Unit,
        kdom_units: Unit,
        kimp_units: Unit,
        m: UMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U_C_WrapUnits instance."""
        kind = "UMap"
        type_ = "U_C_WrapUnits"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            kcod_units=kcod_units,
            kdom_units=kdom_units,
            kimp_units=kimp_units,
            m=m,
        )


@dataclass(frozen=True)
class U_Catalog(UMap):
    kind: Literal["UMap"] = field()
    type_: Literal["U_Catalog"] = field()
    options: list[U_Catalog_Options] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["options"] = [item.to_data() for item in self.options]
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        options: list[U_Catalog_Options],
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U_Catalog instance."""
        kind = "UMap"
        type_ = "U_Catalog"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            options=options,
        )


@dataclass(frozen=True)
class U_Catalog_Options:
    f: Any = field()
    i: Any = field()
    r: Any = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["f"] = self.f
        result["i"] = self.i
        result["r"] = self.r
        return result

    @classmethod
    def make(cls, *, f: Any, i: Any, r: Any) -> Self:
        """Create a new U_Catalog_Options instance."""
        return cls(
            f=f,
            i=i,
            r=r,
        )


@dataclass(frozen=True)
class U_Constant(UMap):
    kind: Literal["UMap"] = field()
    type_: Literal["U_Constant"] = field()
    value: UpperSet = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["value"] = self.value.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        value: UpperSet,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U_Constant instance."""
        kind = "UMap"
        type_ = "U_Constant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            value=value,
        )


@dataclass(frozen=True)
class U_Identity(UMap):
    kind: Literal["UMap"] = field()
    type_: Literal["U_Identity"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U_Identity instance."""
        kind = "UMap"
        type_ = "U_Identity"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
        )


@dataclass(frozen=True)
class U_L_Lift1_Constant(UMap):
    kind: Literal["UMap"] = field()
    type_: Literal["U_L_Lift1_Constant"] = field()
    m: U1Map = field()
    value: Any = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["value"] = self.value
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        m: U1Map,
        value: Any,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U_L_Lift1_Constant instance."""
        kind = "UMap"
        type_ = "U_L_Lift1_Constant"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            m=m,
            value=value,
        )


@dataclass(frozen=True)
class U_L_Lift1_Transform(UMap):
    kind: Literal["UMap"] = field()
    type_: Literal["U_L_Lift1_Transform"] = field()
    m: U1Map = field()
    transform: MonotoneMap = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["m"] = self.m.to_data()
        result["transform"] = self.transform.to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        m: U1Map,
        transform: MonotoneMap,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U_L_Lift1_Transform instance."""
        kind = "UMap"
        type_ = "U_L_Lift1_Transform"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
            m=m,
            transform=transform,
        )


@dataclass(frozen=True)
class U_Unknown(UMap):
    kind: Literal["UMap"] = field()
    type_: Literal["U_Unknown"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(
        cls,
        *,
        kcod: Poset,
        kdom: Poset,
        kimp: Poset,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
    ) -> Self:
        """Create a new U_Unknown instance."""
        kind = "UMap"
        type_ = "U_Unknown"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            kcod=kcod,
            kdom=kdom,
            kimp=kimp,
            type_=type_,
        )


@dataclass(frozen=True)
class Unit:
    kind: Literal["Unit"] = field()
    type_: Literal["Unit_None", "Unit_Single", "Unit_Vector", "Unit_Wrapped"] = field()
    description: str | None = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        if self.description is not None:
            result["description"] = self.description
        result["kind"] = self.kind
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class Unit_None(Unit):
    type_: Literal["Unit_None"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(cls, *, description: str | None = None) -> Self:
        """Create a new Unit_None instance."""
        kind = "Unit"
        type_ = "Unit_None"
        return cls(
            description=description,
            kind=kind,
            type_=type_,
        )


@dataclass(frozen=True)
class Unit_Single(Unit):
    type_: Literal["Unit_Single"] = field()
    units: str = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["units"] = self.units
        return result

    @classmethod
    def make(cls, *, units: str, description: str | None = None) -> Self:
        """Create a new Unit_Single instance."""
        kind = "Unit"
        type_ = "Unit_Single"
        return cls(
            description=description,
            kind=kind,
            type_=type_,
            units=units,
        )


@dataclass(frozen=True)
class Unit_Vector(Unit):
    type_: Literal["Unit_Vector"] = field()
    labels: list[str] | None = field()
    subs: list[Unit] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.labels is not None:
            result["labels"] = self.labels
        result["subs"] = [item.to_data() for item in self.subs]
        return result

    @classmethod
    def make(cls, *, subs: list[Unit], description: str | None = None, labels: list[str] | None = None) -> Self:
        """Create a new Unit_Vector instance."""
        kind = "Unit"
        type_ = "Unit_Vector"
        return cls(
            description=description,
            kind=kind,
            type_=type_,
            labels=labels,
            subs=subs,
        )


@dataclass(frozen=True)
class Unit_Wrapped(Unit):
    type_: Literal["Unit_Wrapped"] = field()
    inside: list[Unit] = field()
    name: str = field()
    shape: Any = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["inside"] = [item.to_data() for item in self.inside]
        result["name"] = self.name
        result["shape"] = self.shape
        return result

    @classmethod
    def make(cls, *, inside: list[Unit], name: str, shape: Any, description: str | None = None) -> Self:
        """Create a new Unit_Wrapped instance."""
        kind = "Unit"
        type_ = "Unit_Wrapped"
        return cls(
            description=description,
            kind=kind,
            type_=type_,
            inside=inside,
            name=name,
            shape=shape,
        )


@dataclass(frozen=True)
class UpperSet:
    kind: Literal["UpperSet"] = field()
    type_: Literal["UpperSet_Unused", "UpperSet_UpperClosure"] = field()

    def to_data(self) -> dict[str, Any]:
        result: dict[str, Any] = {}
        result["kind"] = self.kind
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class UpperSet_Unused(UpperSet):
    type_: Literal["UpperSet_Unused"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        return result

    @classmethod
    def make(cls) -> Self:
        """Create a new UpperSet_Unused instance."""
        kind = "UpperSet"
        type_ = "UpperSet_Unused"
        return cls(
            kind=kind,
            type_=type_,
        )


@dataclass(frozen=True)
class UpperSet_UpperClosure(UpperSet):
    type_: Literal["UpperSet_UpperClosure"] = field()
    points: list[Any] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["points"] = self.points
        return result

    @classmethod
    def make(cls, *, points: list[Any]) -> Self:
        """Create a new UpperSet_UpperClosure instance."""
        kind = "UpperSet"
        type_ = "UpperSet_UpperClosure"
        return cls(
            kind=kind,
            type_=type_,
            points=points,
        )


@dataclass(frozen=True)
class Value(Root):
    kind: Literal["Value"] = field()
    address: Address | None = field()
    type_: Literal["VU"] = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        if self.address is not None:
            result["address"] = self.address.to_data()
        result["type"] = self.type_
        return result


@dataclass(frozen=True)
class VU(Value):
    kind: Literal["Value"] = field()
    poset: Poset = field()
    value: Any = field()

    def to_data(self) -> dict[str, Any]:
        result = super().to_data()
        result["poset"] = self.poset.to_data()
        result["value"] = self.value
        return result

    @classmethod
    def make(
        cls,
        *,
        poset: Poset,
        value: Any,
        description: str | None = None,
        hash: str | None = None,
        version: str | None = None,
        address: Address | None = None,
    ) -> Self:
        """Create a new VU instance."""
        kind = "Value"
        type_ = "VU"
        return cls(
            description=description,
            hash=hash,
            kind=kind,
            version=version,
            address=address,
            type_=type_,
            poset=poset,
            value=value,
        )


# Test functions for serialization/deserialization


def test_serialization_DP_C_ExplicitApprox_01():
    """Test serialization/deserialization of DP_C_ExplicitApprox example 1."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"F":{"kind":"Poset","type":"P_Decimal"},"R":{"kind":"Poset","type":"P_Decimal"},"kind":"DP","optimistic":[{"F":{'
        '"kind":"Poset","type":"P_Decimal"},"R":{"kind":"Poset","type":"P_Decimal"},"kind":"DP","type":"DP_True",'
        '"value":{"kind":"Value","poset":{"kind":"Poset","naked":[],"ranges":[],"subs":[],"type":"P_C_ProductSmash"},'
        '"type":"VU","value":[]}}],"pessimistic":[{"F":{"kind":"Poset","type":"P_Decimal"},"R":{"kind":"Poset",'
        '"type":"P_Decimal"},"kind":"DP","type":"DP_False"}],"type":"DP_C_ExplicitApprox"}'
    )

    # Create instance from data
    instance = load_DP_C_ExplicitApprox(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_DP_C_ExplicitApprox(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_DP_C_ExplicitApprox_01 passed")


def test_serialization_P_Bool_01():
    """Test serialization/deserialization of P_Bool example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"kind":"Poset","type":"P_Bool"}')

    # Create instance from data
    instance = load_P_Bool(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_Bool(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_Bool_01 passed")


def test_serialization_P_C_Arrow_01():
    """Test serialization/deserialization of P_C_Arrow example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"kind":"Poset","poset":{"kind":"Poset","type":"P_Decimal"},"type":"P_C_Arrow"}')

    # Create instance from data
    instance = load_P_C_Arrow(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_Arrow(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_Arrow_01 passed")


def test_serialization_P_C_Discretized_01():
    """Test serialization/deserialization of P_C_Discretized example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"kind":"Poset","poset":{"kind":"Poset","type":"P_Bool"},"type":"P_C_Discretized"}')

    # Create instance from data
    instance = load_P_C_Discretized(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_Discretized(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_Discretized_01 passed")


def test_serialization_P_C_Lexicographic_01():
    """Test serialization/deserialization of P_C_Lexicographic example 1."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"kind":"Poset","subs":[{"kind":"Poset","type":"P_Decimal"},{"kind":"Poset","type":"P_Bool"}],'
        '"type":"P_C_Lexicographic"}'
    )

    # Create instance from data
    instance = load_P_C_Lexicographic(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_Lexicographic(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_Lexicographic_01 passed")


def test_serialization_P_C_LowerSets_01():
    """Test serialization/deserialization of P_C_LowerSets example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"kind":"Poset","poset":{"kind":"Poset","type":"P_Decimal"},"type":"P_C_LowerSets"}')

    # Create instance from data
    instance = load_P_C_LowerSets(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_LowerSets(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_LowerSets_01 passed")


def test_serialization_P_C_Opposite_01():
    """Test serialization/deserialization of P_C_Opposite example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"kind":"Poset","poset":{"kind":"Poset","type":"P_Decimal"},"type":"P_C_Opposite"}')

    # Create instance from data
    instance = load_P_C_Opposite(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_Opposite(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_Opposite_01 passed")


def test_serialization_P_C_Power_01():
    """Test serialization/deserialization of P_C_Power example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"kind":"Poset","poset":{"kind":"Poset","type":"P_Decimal"},"type":"P_C_Power"}')

    # Create instance from data
    instance = load_P_C_Power(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_Power(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_Power_01 passed")


def test_serialization_P_C_Product_01():
    """Test serialization/deserialization of P_C_Product example 1."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"kind":"Poset","subs":[{"kind":"Poset","type":"P_Decimal"},{"kind":"Poset","type":"P_Bool"}],"type":"P_C_Product"}'
    )

    # Create instance from data
    instance = load_P_C_Product(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_Product(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_Product_01 passed")


def test_serialization_P_C_Product_02():
    """Test serialization/deserialization of P_C_Product example 2."""
    # Test data from OpenAPI schema example
    data = json.loads('{"kind":"Poset","subs":[],"type":"P_C_Product"}')

    # Create instance from data
    instance = load_P_C_Product(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_Product(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_Product_02 passed")


def test_serialization_P_C_ProductSmash_01():
    """Test serialization/deserialization of P_C_ProductSmash example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"kind":"Poset","naked":[],"ranges":[],"subs":[],"type":"P_C_ProductSmash"}')

    # Create instance from data
    instance = load_P_C_ProductSmash(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_ProductSmash(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_ProductSmash_01 passed")


def test_serialization_P_C_ProductSmash_02():
    """Test serialization/deserialization of P_C_ProductSmash example 2."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"kind":"Poset","naked":[true,false,true],"ranges":[{"ntot":4,"start":0,"stop":1,"type":"Range"},{"ntot":4,"start":1,'
        '"stop":3,"type":"Range"},{"ntot":4,"start":3,"stop":4,"type":"Range"}],"subs":[{"kind":"Poset","type":"P_Decimal"},'
        '{"kind":"Poset","naked":[true,true],"ranges":[{"ntot":2,"start":0,"stop":1,"type":"Range"},{"ntot":2,"start":1,'
        '"stop":2,"type":"Range"}],"subs":[{"kind":"Poset","type":"P_Decimal"},{"kind":"Poset","type":"P_Bool"}],'
        '"type":"P_C_ProductSmash"},{"kind":"Poset","type":"P_Decimal"}],"type":"P_C_ProductSmash"}'
    )

    # Create instance from data
    instance = load_P_C_ProductSmash(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_ProductSmash(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_ProductSmash_02 passed")


def test_serialization_P_C_Sum_01():
    """Test serialization/deserialization of P_C_Sum example 1."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"kind":"Poset","subs":[{"kind":"Poset","type":"P_Decimal"},{"kind":"Poset","type":"P_Bool"}],"type":"P_C_Sum"}'
    )

    # Create instance from data
    instance = load_P_C_Sum(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_Sum(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_Sum_01 passed")


def test_serialization_P_C_SumSmash_01():
    """Test serialization/deserialization of P_C_SumSmash example 1."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"kind":"Poset","naked":[true,true],"ranges":[{"ntot":2,"start":0,"stop":1,"type":"Range"},{"ntot":2,"start":0,'
        '"stop":1,"type":"Range"}],"subs":[{"kind":"Poset","type":"P_Decimal"},{"kind":"Poset","type":"P_Bool"}],'
        '"trivial":false,"type":"P_C_SumSmash"}'
    )

    # Create instance from data
    instance = load_P_C_SumSmash(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_SumSmash(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_SumSmash_01 passed")


def test_serialization_P_C_Twisted_01():
    """Test serialization/deserialization of P_C_Twisted example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"kind":"Poset","poset":{"kind":"Poset","type":"P_Decimal"},"type":"P_C_Twisted"}')

    # Create instance from data
    instance = load_P_C_Twisted(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_Twisted(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_Twisted_01 passed")


def test_serialization_P_C_Units_01():
    """Test serialization/deserialization of P_C_Units example 1."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"kind":"Poset","poset":{"kind":"Poset","type":"P_Decimal"},"type":"P_C_Units","units":{"kind":"Unit",'
        '"type":"Unit_Single","units":"m^2/s"}}'
    )

    # Create instance from data
    instance = load_P_C_Units(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_Units(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_Units_01 passed")


def test_serialization_P_C_Units_02():
    """Test serialization/deserialization of P_C_Units example 2."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"kind":"Poset","poset":{"kind":"Poset","subs":[{"kind":"Poset","type":"P_Decimal"},{"kind":"Poset",'
        '"type":"P_Decimal"}],"type":"P_C_Product"},"type":"P_C_Units","units":{"kind":"Unit","subs":[{"kind":"Unit",'
        '"type":"Unit_Single","units":"m"},{"kind":"Unit","type":"Unit_Single","units":"g"}],"type":"Unit_Vector"}}'
    )

    # Create instance from data
    instance = load_P_C_Units(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_Units(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_Units_02 passed")


def test_serialization_P_C_UpperSets_01():
    """Test serialization/deserialization of P_C_UpperSets example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"kind":"Poset","poset":{"kind":"Poset","type":"P_Decimal"},"type":"P_C_UpperSets"}')

    # Create instance from data
    instance = load_P_C_UpperSets(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_C_UpperSets(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_C_UpperSets_01 passed")


def test_serialization_P_Decimal_01():
    """Test serialization/deserialization of P_Decimal example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"kind":"Poset","precision":9,"type":"P_Decimal"}')

    # Create instance from data
    instance = load_P_Decimal(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_Decimal(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_Decimal_01 passed")


def test_serialization_P_F_Bounded_01():
    """Test serialization/deserialization of P_F_Bounded example 1."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"bottom":"0","bound_high":"+inf","bound_low":"0","kind":"Poset","offset":"0","poset":{"kind":"Poset",'
        '"type":"P_Decimal"},"step":"1","top":"+inf","type":"P_F_Bounded"}'
    )

    # Create instance from data
    instance = load_P_F_Bounded(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_F_Bounded(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_F_Bounded_01 passed")


def test_serialization_P_F_Bounded_02():
    """Test serialization/deserialization of P_F_Bounded example 2."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"bottom":"-inf","bound_high":"+inf","bound_low":"-inf","kind":"Poset","offset":"1","poset":{"kind":"Poset",'
        '"type":"P_Decimal"},"step":"2","top":"+inf","type":"P_F_Bounded"}'
    )

    # Create instance from data
    instance = load_P_F_Bounded(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_F_Bounded(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_F_Bounded_02 passed")


def test_serialization_P_F_Bounded_03():
    """Test serialization/deserialization of P_F_Bounded example 3."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"bottom":"-inf","bound_high":"6","bound_low":"0","kind":"Poset","offset":"0","poset":{"kind":"Poset",'
        '"type":"P_Decimal"},"step":"1.5","top":"+inf","type":"P_F_Bounded"}'
    )

    # Create instance from data
    instance = load_P_F_Bounded(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_F_Bounded(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_F_Bounded_03 passed")


def test_serialization_P_F_C_Union_01():
    """Test serialization/deserialization of P_F_C_Union example 1."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"ambient":{"kind":"Poset","type":"P_Decimal"},"kind":"Poset","subs":[{"high":"20","kind":"Poset","low":"10",'
        '"poset":{"kind":"Poset","type":"P_Decimal"},"type":"P_F_Interval"},{"high":"35","kind":"Poset","low":"30",'
        '"poset":{"kind":"Poset","type":"P_Decimal"},"type":"P_F_Interval"}],"type":"P_F_C_Union"}'
    )

    # Create instance from data
    instance = load_P_F_C_Union(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_F_C_Union(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_F_C_Union_01 passed")


def test_serialization_P_F_Interval_01():
    """Test serialization/deserialization of P_F_Interval example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"high":"20","kind":"Poset","low":"10","poset":{"kind":"Poset","type":"P_Decimal"},"type":"P_F_Interval"}')

    # Create instance from data
    instance = load_P_F_Interval(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_F_Interval(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_F_Interval_01 passed")


def test_serialization_P_F_LowerClosure_01():
    """Test serialization/deserialization of P_F_LowerClosure example 1."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"kind":"Poset","ls":{"kind":"LowerSet","points":[["10",true],["20",false]],"type":"LowerSet_LowerClosure"},'
        '"poset":{"kind":"Poset","subs":[{"kind":"Poset","type":"P_Decimal"},{"kind":"Poset","type":"P_Bool"}],'
        '"type":"P_C_Product"},"type":"P_F_LowerClosure"}'
    )

    # Create instance from data
    instance = load_P_F_LowerClosure(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_F_LowerClosure(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_F_LowerClosure_01 passed")


def test_serialization_P_F_Subposet_01():
    """Test serialization/deserialization of P_F_Subposet example 1."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"elements":["0.1","0.2"],"kind":"Poset","poset":{"kind":"Poset","type":"P_Decimal"},"type":"P_F_Subposet"}'
    )

    # Create instance from data
    instance = load_P_F_Subposet(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_F_Subposet(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_F_Subposet_01 passed")


def test_serialization_P_F_Subposet_02():
    """Test serialization/deserialization of P_F_Subposet example 2."""
    # Test data from OpenAPI schema example
    data = json.loads('{"elements":[],"kind":"Poset","poset":{"kind":"Poset","type":"P_Decimal"},"type":"P_F_Subposet"}')

    # Create instance from data
    instance = load_P_F_Subposet(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_F_Subposet(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_F_Subposet_02 passed")


def test_serialization_P_F_UpperClosure_01():
    """Test serialization/deserialization of P_F_UpperClosure example 1."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"kind":"Poset","poset":{"kind":"Poset","subs":[{"kind":"Poset","type":"P_Decimal"},{"kind":"Poset","type":"P_Bool"}],'
        '"type":"P_C_Product"},"type":"P_F_UpperClosure","us":{"kind":"UpperSet","points":[["10",true],["20",false]],'
        '"type":"UpperSet_UpperClosure"}}'
    )

    # Create instance from data
    instance = load_P_F_UpperClosure(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_F_UpperClosure(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_F_UpperClosure_01 passed")


def test_serialization_P_Finite_01():
    """Test serialization/deserialization of P_Finite example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"aliases":{},"elements":[],"kind":"Poset","relations":[],"type":"P_Finite"}')

    # Create instance from data
    instance = load_P_Finite(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_Finite(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_Finite_01 passed")


def test_serialization_P_Finite_02():
    """Test serialization/deserialization of P_Finite example 2."""
    # Test data from OpenAPI schema example
    data = json.loads('{"elements":["a","b"],"kind":"Poset","relations":[],"type":"P_Finite"}')

    # Create instance from data
    instance = load_P_Finite(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_Finite(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_Finite_02 passed")


def test_serialization_P_Finite_03():
    """Test serialization/deserialization of P_Finite example 3."""
    # Test data from OpenAPI schema example
    data = json.loads('{"elements":["a","b"],"kind":"Poset","relations":[["a","b"]],"type":"P_Finite"}')

    # Create instance from data
    instance = load_P_Finite(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_Finite(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_Finite_03 passed")


def test_serialization_P_Finite_04():
    """Test serialization/deserialization of P_Finite example 4."""
    # Test data from OpenAPI schema example
    data = json.loads(
        '{"aliases":{"a":["a1","a2"]},"elements":["a","b","c"],"kind":"Poset","relations":[["a","b"],["b","c"]],'
        '"type":"P_Finite"}'
    )

    # Create instance from data
    instance = load_P_Finite(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_Finite(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_Finite_04 passed")


def test_serialization_P_Float_01():
    """Test serialization/deserialization of P_Float example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"kind":"Poset","size":"f32","type":"P_Float"}')

    # Create instance from data
    instance = load_P_Float(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_Float(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_Float_01 passed")


def test_serialization_P_Fractions_01():
    """Test serialization/deserialization of P_Fractions example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"kind":"Poset","max_abs_denominator":1000,"max_abs_numerator":1000,"size":"i32","type":"P_Fractions"}')

    # Create instance from data
    instance = load_P_Fractions(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_Fractions(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_Fractions_01 passed")


def test_serialization_P_Integer_01():
    """Test serialization/deserialization of P_Integer example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"kind":"Poset","size":"i32","type":"P_Integer"}')

    # Create instance from data
    instance = load_P_Integer(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_Integer(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_Integer_01 passed")


def test_serialization_P_Unknown_01():
    """Test serialization/deserialization of P_Unknown example 1."""
    # Test data from OpenAPI schema example
    data = json.loads('{"kind":"Poset","type":"P_Unknown"}')

    # Create instance from data
    instance = load_P_Unknown(data)
    assert instance is not None

    # Test round-trip serialization
    serialized = instance.to_data()
    instance2 = load_P_Unknown(serialized)
    assert instance2 is not None

    # Test that serialized data matches
    assert instance2.to_data() == serialized
    print(f"✓ test_serialization_P_Unknown_01 passed")


if __name__ == "__main__":
    # Run all test functions
    import sys

    def dummy():
        pass

    test_functions = [
        dummy,
        test_serialization_DP_C_ExplicitApprox_01,
        test_serialization_P_Bool_01,
        test_serialization_P_C_Arrow_01,
        test_serialization_P_C_Discretized_01,
        test_serialization_P_C_Lexicographic_01,
        test_serialization_P_C_LowerSets_01,
        test_serialization_P_C_Opposite_01,
        test_serialization_P_C_Power_01,
        test_serialization_P_C_Product_01,
        test_serialization_P_C_Product_02,
        test_serialization_P_C_ProductSmash_01,
        test_serialization_P_C_ProductSmash_02,
        test_serialization_P_C_Sum_01,
        test_serialization_P_C_SumSmash_01,
        test_serialization_P_C_Twisted_01,
        test_serialization_P_C_Units_01,
        test_serialization_P_C_Units_02,
        test_serialization_P_C_UpperSets_01,
        test_serialization_P_Decimal_01,
        test_serialization_P_F_Bounded_01,
        test_serialization_P_F_Bounded_02,
        test_serialization_P_F_Bounded_03,
        test_serialization_P_F_C_Union_01,
        test_serialization_P_F_Interval_01,
        test_serialization_P_F_LowerClosure_01,
        test_serialization_P_F_Subposet_01,
        test_serialization_P_F_Subposet_02,
        test_serialization_P_F_UpperClosure_01,
        test_serialization_P_Finite_01,
        test_serialization_P_Finite_02,
        test_serialization_P_Finite_03,
        test_serialization_P_Finite_04,
        test_serialization_P_Float_01,
        test_serialization_P_Fractions_01,
        test_serialization_P_Integer_01,
        test_serialization_P_Unknown_01,
    ]

    failed = 0
    for test_func in test_functions:
        try:
            test_func()
        except Exception as e:
            print(f"✗ {test_func.__name__} failed: {e}")
            failed += 1

    if failed > 0:
        sys.exit(1)
    else:
        print(f"\nAll {len(test_functions)} tests passed!")
