# Este archivo ha sido generado automáticamente por tai-sql
# No modifiques este archivo directamente
{% import "macros.jinja2" as macros %}
{{ imports|join('\n') }}

# Logger
logger = Alphi.get_logger_by_name("{{ logger_name }}")

# General Enum class
class EnumModel:

    def __init__(self, name: str, values: List[str]):
        self.name = name
        self.values = values
    
    def find_many(self) -> List[str]:
        """
        Devuelve una lista de los valores del Enum.
        
        Returns:
            List[str]: Lista de valores del Enum
        """
        logger.info(f"Obteniendo valores del Enum '{self.name}' - {len(self.values)} valores disponibles")
        return self.values


{% for model in models %}
{% set all_pk_autoincrement = true %}
{% for column in model.columns %}
    {% if column.args.get('primary_key', False) and not column.args.get('autoincrement', False) %}
        {% set all_pk_autoincrement = false %}
    {% endif %}
{% endfor %}
class {{ model.name }}Read(BaseModel):
    """Data Transfer Object de lectura para {{ model.name }}. Devuelve objetos que existen en la base de datos."""
    {% for column in model.columns %}
    {% if not column.nullable %}
    {{ column.name }}: {{ column.type }}
    {% else %}
    {{ column.name }}: Optional[{{ column.type }}]
    {% endif%}
    {% endfor %}

    {% for relation in model.relations %}
    {% if relation.direction == 'one-to-many' %}
    {{ relation.name }}: Optional[List[{{ relation.target }}Read]] = None
    {% elif relation.direction == 'many-to-one' %}
    {{ relation.name }}: Optional[{{ relation.target }}Read] = None
    {% endif %}
    {% endfor %}

    {{ macros.pydantic_model_config() }}
    
    @classmethod
    def from_instance(
        cls,
        instance: {{ model.name }},
        includes: Optional[List[str]] = None,
        max_depth: int = {{ max_depth }}
    ) -> {{ model.name }}Read:
        """
        Crea un DTO desde una instancia del modelo SQLAlchemy con carga optimizada de relaciones.
        
        Args:
            instance: Instancia del modelo {{ model.name }}
            includes: Lista de relaciones a incluir (formato: 'relation' o 'relation.nested_relation')
            max_depth: Profundidad máxima de anidación para evitar recursión infinita
            
        Returns:
            {{ model.name }}Read: Instancia del DTO
        """

        # Construir DTO base
        dto_data = {
            {% for column in model.columns %}
            '{{ column.name }}': instance.{{ column.name }},
            {% endfor %}
        }

        {% if not model.is_view %}
        # Procesar relaciones con control de profundidad
        if includes is not None and max_depth > 0:
            {% for relation in model.relations %}
            {% if relation.direction == 'one-to-many' %}
            # Relación 1:N - {{ relation.name }}
            if should_include_relation('{{ relation.name }}', includes):
                nested_includes = get_nested_includes('{{ relation.name }}', includes)
                # Este check debería cumplirse siempre, es por seguridad
                if hasattr(instance, '{{ relation.name }}') and instance.{{ relation.name }} is not None:
                    dto_data['{{ relation.name }}'] = [
                        {{ relation.target }}Read.from_instance(
                            reg, 
                            nested_includes, 
                            max_depth - 1
                        ) 
                        for reg in instance.{{ relation.name }}
                    ]

            {% elif relation.direction == 'many-to-one' %}
            # Relación N:1 - {{ relation.name }}
            if should_include_relation('{{ relation.name }}', includes):
                nested_includes = get_nested_includes('{{ relation.name }}', includes)
                # Este check debería cumplirse siempre, es por seguridad
                if hasattr(instance, '{{ relation.name }}') and instance.{{ relation.name }} is not None:
                    dto_data['{{ relation.name }}'] = {{ relation.target }}Read.from_instance(
                        instance.{{ relation.name }}, 
                        nested_includes, 
                        max_depth - 1
                    )

            {% endif %}
            {% endfor %}
        {% endif %}
        return cls(**dto_data)

    {% if not model.is_view %}
    @classmethod
    def from_created_instance(cls, instance: {{ model.name }}, included: set[str], excluded: str=None) -> {{ model.name }}Read:
        """
        Crea un DTO desde una instancia del modelo SQLAlchemy
        
        Args:
            instance: Instancia del modelo {{ model.name }}
            
        Returns:
            {{ model.name }}Create: Instancia del DTO
        """

        # Construir DTO base
        dto_data = {
            {% for column in model.columns %}
            '{{ column.name }}': instance.{{ column.name }},
            {% endfor %}
        }

        {% if model.relations %}

        # Evaluación lazy de relaciones costosas
        {% for relation in model.relations %}
        if '{{ relation.name }}' in included and not '{{ relation.name }}' == excluded and hasattr(instance, '{{ relation.name }}') and getattr(instance, '{{ relation.name }}') is not None:
        {% if relation.direction == 'one-to-many' %}
            dto_data['{{ relation.name }}'] = [
                {{ relation.target }}Read.from_created_instance(reg, included, '{{ relation.backref }}') 
                for reg in instance.{{ relation.name }}
            ]
        {% elif relation.direction == 'many-to-one' %}
            dto_data['{{ relation.name }}'] = {{ relation.target }}Read.from_created_instance(
                instance.{{ relation.name }}, included, '{{ relation.backref }}'
            )
        {% endif %}
        {% endfor %}

        {% endif %}
        return cls(**dto_data)

    {% endif %}
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> {{ model.name }}Read:
        """
        Crea un DTO desde un diccionario
        
        Args:
            data: Diccionario con los datos del DTO
            
        Returns:
            {{ model.name }}Read: Instancia del DTO
        """
        return cls(**data)
    
    def to_dict(self) -> Dict[str, Any]:
        return self.model_dump()


{% if not model.is_view %}
class {{ model.name }}Create(BaseModel):
    """Data Transfer Object de escritura para {{ model.name }}. Define objetos para ser creados en la base de datos."""
    {% for column in model.columns -%}
    {% if not column.args.get('autoincrement', False) and column.default is none and not column.nullable and not column.is_foreign_key %}
    {{ column.name }}: {{ column.type }}
    {% endif %}
    {% endfor %}
    {% for column in model.columns -%}
    {% if column.is_foreign_key %}
    {{ column.name }}: Optional[{{ column.type }}] = None
    {% elif column.default is none and column.nullable %}
    {{ column.name }}: Optional[{{ column.type }}] = None
    {% elif column.default is not none %}
        {% if column.default == "datetime.now" %}
    {{ column.name }}: {{ column.type }} = Field(default_factory=datetime.now)
        {% elif column.default == "datetime.today" %}
    {{ column.name }}: {{ column.type }} = Field(default_factory=datetime.today)
        {% elif column.default in [True, False, None] %}
    {{ column.name }}: {{ column.type }} = {{ column.default }}
        {% elif column.default is string %}
            {% if column.default.isdigit() %}
    {{ column.name }}: {{ column.type }} = {{ column.default }}
            {% elif column.default.replace(" ", "").isalnum() %}
    {{ column.name }}: {{ column.type }} = "{{ column.default }}"
            {% else %}
    {{ column.name }}: {{ column.type }} = "{{ column.default | replace('"', '\\"') }}"
            {% endif %}
        {% else %}
    {{ column.name }}: {{ column.type }} = {{ column.default }}
        {% endif %}
    {% endif %}
    {% endfor %}

    {% for relation in model.relations %}
    {% if relation.direction == 'one-to-many' %}
    {{ relation.name }}: Optional[List[{{ relation.target }}Create]] = None
    {% elif relation.direction == 'many-to-one' %}
    {{ relation.name }}: Optional[{{ relation.target }}Create] = None
    {% endif %}
    {% endfor %}

    {{ macros.pydantic_model_config() }}
    
    def to_instance(self) -> {{ model.name }}:
        """
        Crea una instancia del modelo SQLAlchemy desde el DTO
        
        Returns:
            {{ model.name }}: Instancia del modelo SQLAlchemy
        """

        model = {{ model.name }}(
            {% for column in model.columns %}
            {% if not column.args.get('autoincrement', False) %}
            {{ column.name }}=self.{{ column.name }},
            {% endif %}
            {% endfor %}
        )
        
        # Evaluación lazy de relaciones costosas
        {% for relation in model.relations %}
        if self.{{ relation.name }} is not None:
            {% if relation.direction == 'one-to-many' %}
            {{ relation.name }} = [{{ relation.target }}(**reg.to_dict()) for reg in self.{{ relation.name }}]
            {% elif relation.direction == 'many-to-one' %}
            {{ relation.name }} = {{ relation.target }}(**self.{{ relation.name }}.to_dict())
            {% endif %}
            model.{{ relation.name }} = {{ relation.name }}
        {% endfor %}

        return model
    
    @classmethod
    def from_instance(cls, instance: {{ model.name }}) -> {{ model.name }}Create:
        """
        Crea un DTO desde una instancia del modelo SQLAlchemy
        
        Args:
            instance: Instancia del modelo {{ model.name }}
            
        Returns:
            {{ model.name }}Create: Instancia del DTO
        """

        # Construir DTO base
        dto_data = {
            {% for column in model.columns %}
            '{{ column.name }}': instance.{{ column.name }},
            {% endfor %}
        }

        {% if model.relations %}

        # Evaluación lazy de relaciones costosas
        {% for relation in model.relations %}
        if hasattr(instance, '{{ relation.name }}') and getattr(instance, '{{ relation.name }}') is not None:
        {% if relation.direction == 'one-to-many' %}
            dto_data['{{ relation.name }}'] = [
                {{ relation.target }}Create.from_instance(reg) 
                for reg in instance.{{ relation.name }}
            ]
        {% elif relation.direction == 'many-to-one' %}
            dto_data['{{ relation.name }}'] = {{ relation.target }}Create.from_instance(
                instance.{{ relation.name }}
            )
        {% endif %}
        {% endfor %}

        {% endif %}
        return cls(**dto_data)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> {{ model.name }}Read:
        """
        Crea un DTO desde un diccionario
        
        Args:
            data: Diccionario con los datos del DTO
            
        Returns:
            {{ model.name }}Read: Instancia del DTO
        """
        return cls(**data)

    def to_dict(self) -> Dict[str, Any]:
        return self.model_dump(exclude_none=True)

class {{ model.name }}Filter(BaseModel):
    """Data Transfer Object de actualización para {{ model.name }}.
    Define los filtros que sirven para buscar registros en la DB."""
    {% for column in model.columns -%}
    {% if not column.args.get('autoincrement', False) %}
    {{ column.name }}: {{ column.type }} = None
    {% endif %}
    {% endfor %}

    {{ macros.pydantic_model_config() }}
    
    def to_dict(self) -> Dict[str, Any]:
        return self.model_dump(exclude_unset=True)


class {{ model.name }}UpdateValues(BaseModel):
    """Data Transfer Object de actualización para {{ model.name }}.
    Define los valores que se modificarán en los registros correspondientes."""
    {% for column in model.columns -%}
    {% if not column.args.get('autoincrement', False) %}
    {{ column.name }}: {{ column.type }} = None
    {% endif %}
    {% endfor %}

    {{ macros.pydantic_model_config() }}
    
    def to_dict(self) -> Dict[str, Any]:
        return self.model_dump(exclude_unset=True)


class {{ model.name }}Update(BaseModel):
    """Data Transfer Object de actualización para {{ model.name }}."""
    filter: {{ model.name }}Filter
    values: {{ model.name }}UpdateValues

    {{ macros.pydantic_model_config() }}
{% endif %}


class {{ model.name }}AsyncDAO:
    """
    Clase DAO asíncrona para el modelo {{ model.name }}.
    
    Proporciona operaciones completas de Create, Read, Update y Delete
    para el modelo {{ model.name }} con soporte para gestión automática
    y manual de sesiones SQLAlchemy.
    
    Características principales:
    - Soporte dual: sesiones automáticas o compartidas
    - Type hints completos para mejor experiencia de desarrollo
    - Manejo robusto de errores con rollback automático
    - Operaciones optimizadas con flush para obtener IDs
    - Filtros flexibles en todas las operaciones de búsqueda
    
    Métodos de lectura:
        find(**filters, session=None): Busca un único registro
        find_many(limit, offset, **filters, session=None): Busca múltiples registros
        find_by_id(id, session=None): Busca por clave primaria
        count(**filters, session=None): Cuenta registros

    {% if not model.is_view %}
    Métodos de escritura:
        create(**data, session=None): Crea un nuevo registro
        create_many(records, session=None): Crea múltiples registros
        update(filters, **data, session=None): Actualiza registros existentes
        delete(**filters, session=None): Elimina registros

    {% endif %}
    Parámetros de sesión:
        Todos los métodos aceptan un parámetro opcional 'session':
        - Si session=None: Se crea una sesión automática con commit
        - Si session=AsyncSession: Se usa la sesión proporcionada (para transacciones)
    
    Ejemplos de uso:
        ```python
        # Operaciones simples (sesión automática)
        crud = {{ model.name }}DAO(session_manager)
        {% if model.columns %}
        {% set first_column = model.columns[0] %}
        {% if not first_column.args.get('autoincrement', False) %}
        record = await crud.create({{ first_column.name }}="valor")
        {% endif %}
        {% endif %}
        found = await crud.find_by_id(1)
        
        # Operaciones transaccionales (sesión compartida)
        async with session_manager.transaction() as session:
            record1 = await crud.create(data="valor1", session=session)
            record2 = await crud.create(data="valor2", session=session)
            # Ambos se crean en la misma transacción
        ```
    """
    
    def __init__(self, session_manager: AsyncSessionManager):
        """
        Inicializa el AsyncDAO con un gestor de sesiones.
        
        Args:
            session_manager: Gestor de sesiones asíncronas
        """
        self.session_manager = session_manager
    
    {% if not model.is_view %}
    @error_handler
    async def find(
        self,
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        {{ column.name }}: {{ column.type }},
        {% endif %}
        {% endfor %}
        includes: Optional[List[str]] = None,
        session: Optional[AsyncSession] = None
    ) -> Optional[{{ model.name }}Read]:
        """
        Busca un único registro por primary key con carga optimizada de relaciones.
        
        Args:
            {% for column in model.columns %}
            {% if column.args.get('primary_key', False) %}
            {{ column.name }}: Filtrar por {{ column.name }}
            {% endif %}
            {% endfor %}
            includes: Lista de relaciones a incluir (formato: 'relation' o 'relation.nested')
            session: Sesión existente (opcional)
            
        Returns:
            Instancia del modelo o None si no se encuentra
            
        Examples:
            Incluir relación simple

            await dao.find(id=1, includes=['author'])
            
            Incluir relaciones anidadas

            await dao.find(id=1, includes=['author', 'author.posts'])
            
            Múltiples relaciones

            await dao.find(id=1, includes=['author', 'comments', 'tags'])
        """
        logger.info(f"[{{ schema_name }}] 🔍 Buscando {{ model.name }}:")
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        logger.info(f"[{{ schema_name }}]     {{ column.name }}={{ '{' }}{{ column.name }}{{ '}' }}")
        {% endif %}
        {% endfor %}
        logger.info(f"[{{ schema_name }}]     includes={includes}")
        
        # Construir query base
        query = select({{ model.name }})
        
        # Aplicar filtros de búsqueda
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        query = query.where({{ model.name }}.{{ column.name }} == {{ column.name }})
        {% endif %}
        {% endfor %}
        
        # Aplicar opciones de carga optimizada
        if includes:
            loading_options = get_loading_options({{ model.name }}, includes)
            if loading_options:
                query = query.options(*loading_options)
        
        # Ejecutar query
        async def execute_query(session: AsyncSession) -> Optional[{{ model.name }}Read]:
            result = await session.execute(query)
            instance = result.scalars().first()
            
            if instance:
                logger.info(f"[{{ schema_name }}] ✅ {{ model.name }} encontrado exitosamente")
                return {{ model.name }}Read.from_instance(
                    instance, 
                    includes=includes, 
                    max_depth={{ max_depth }}
                )
            else:
                logger.info(f"[{{ schema_name }}] 📭 {{ model.name }} no encontrado")
                return None
        
        if session is not None:
            return await execute_query(session)
        else:
            async with self.session_manager.get_session() as session:
                return await execute_query(session)
    {% endif %}

    @error_handler
    async def find_many(
        self,
        limit: Optional[int] = None, 
        offset: Optional[int] = None,
        {{ macros.generate_query_parameters(model).rstrip('\n') | indent(8) }}
        includes: Optional[List[str]] = None,
        session: Optional[AsyncSession] = None
    ) -> List[{{ model.name }}Read]:
        """
        Busca múltiples registros con carga optimizada de relaciones.
        
        Args:
            limit: Límite de registros a retornar
            offset: Número de registros a saltar
            {{ macros.generate_query_args(model).rstrip('\n') | indent(12) }}
            includes: Lista de relaciones a incluir (formato: 'relation' o 'relation.nested')
            session: Sesión existente (opcional)
            
        Returns:
            Lista de instancias del modelo
            
        Examples:
            Búsqueda simple con relaciones

            await dao.find_many(limit=10, includes=['author'])
            
            Relaciones anidadas con filtros

            await dao.find_many(
                ..., 
                includes=['author', 'author.profile', 'comments']
            )
        """
        logger.info(f"[{{ schema_name }}] 🔍 Buscando múltiples {{ model.name }}:")
        logger.info(f"[{{ schema_name }}]     limit={limit}")
        logger.info(f"[{{ schema_name }}]     offset={offset}")
        logger.info(f"[{{ schema_name }}]     includes={includes}")
        
        # Construir query base
        query = select({{ model.name }})
        
        # Aplicar filtros de búsqueda
        {{ macros.generate_filter_query(model).rstrip('\n') | indent(8)  }}
        
        # Aplicar opciones de carga optimizada
        if includes:
            loading_options = get_loading_options({{ model.name }}, includes)
            if loading_options:
                query = query.options(*loading_options)
        
        # Aplicar paginación
        if offset is not None:
            query = query.offset(offset)
        if limit is not None:
            query = query.limit(limit)
        
        # Ejecutar query
        async def execute_query(session: AsyncSession) -> List[{{ model.name }}Read]:
            results = await session.execute(query)
            instances = results.scalars().all()
            
            logger.info(f"[{{ schema_name }}] ✅ Encontrados {len(instances)} registros {{ model.name }}")
            
            return [
                {{ model.name }}Read.from_instance(
                    instance, 
                    includes=includes, 
                    max_depth={{ max_depth }}
                ) 
                for instance in instances
            ]
        
        if session is not None:
            return await execute_query(session)
        else:
            async with self.session_manager.get_session() as session:
                return await execute_query(session)
    
    {% if not model.is_view %}
    @error_handler
    async def create(
        self, 
        {{ model.tablename }}: {{ model.name }}Create,
        session: Optional[AsyncSession] = None
    ) -> {{ model.name }}Read:
        """
        Crea un nuevo registro.
        
        Args:
            {{ model.tablename }}: Datos del {{ model.tablename }} a crear
            session: Sesión existente (opcional)
            
        Returns:
            Instancia del modelo creado
        """
        logger.info(f"[{{ schema_name }}] 🆕 Creando nuevo {{ model.name }}")
        
        {% for relation in model.relations %}
        {% if relation.direction == 'many-to-one' %}
        {% set non_nullable_fields = [] %}
        {% for column in model.columns %}
        {% if column.name in relation.fields and not column.nullable %}
        {% set _ = non_nullable_fields.append(column.name) %}
        {% endif %}
        {% endfor %}
        {% if non_nullable_fields %}
        if {{ model.tablename }}.{{ relation.name }} is None:
            if any([{% for fk in relation.fields %}{{ model.tablename }}.{{ fk }} is None,{% endfor %}]):
                raise Exception('Las Foreign Keys no están bien definidas para crear el registro en {{ model.tablename }}')
        {% endif %}
        {% endif %}
        {% endfor %}

        instance = {{ model.tablename }}.to_instance()

        if session is not None:
            session.add(instance)
            await session.flush()  # Asegura que se genere el ID si es autoincrement
            included = await load_relationships_from_dto(session, instance, {{ model.tablename }})
            data = {{ model.name }}Read.from_created_instance(instance, included)
        else:
            async with self.session_manager.get_session() as session:
                session.add(instance)
                await session.flush()  # Asegura que se genere el ID si es autoincrement
                included = await load_relationships_from_dto(session, instance, {{ model.tablename }})
                data = {{ model.name }}Read.from_created_instance(instance, included)
        
        {% set pk_fields = [] %}
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        {% set _ = pk_fields.append(column.name) %}
        {% endif %}
        {% endfor %}
        {% if pk_fields %}
        logger.info(f"[{{ schema_name }}] ✅ {{ model.name }} creado exitosamente con {% for pk in pk_fields %}{{ pk }}={getattr(data, '{{ pk }}', 'N/A')}{% if not loop.last %}, {% endif %}{% endfor %}")
        {% else %}
        logger.info(f"[{{ schema_name }}] ✅ {{ model.name }} creado exitosamente")
        {% endif %}
        return data
    
    @error_handler
    async def create_many(self, records: List[{{ model.name }}Create], session: Optional[AsyncSession] = None) -> int:
        """
        Crea múltiples registros en la tabla {{ model.tablename }}.
        
        Args:
            records: Lista de {{ model.name }}Create con los datos de los registros
            session: Sesión existente (opcional)
            
        Returns:
            Número de registros creados

        """
        logger.info(f"[{{ schema_name }}] 🔢 Creando {len(records)} registros {{ model.name }}")

        instances = []
        for record in records:
            instances.append(record.to_instance())
        
        if session is not None:
            session.add_all(instances)
            await session.flush()  # Asegura que se generen los IDs si son autoincrement
        else:
            async with self.session_manager.get_session() as session:
                session.add_all(instances)
                await session.flush()  # Asegura que se generen los IDs si son autoincrement

        logger.info(f"[{{ schema_name }}] ✅ {len(instances)} registros {{ model.name }} creados exitosamente")

        return len(instances)
    
    @error_handler
    async def update(
        self, 
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        {{ column.name }}: {{ column.type }},
        {% endif -%}
        {% endfor %}
        updated_values: {{ model.name }}UpdateValues,
        session: Optional[AsyncSession] = None
    ) -> int:
        """
        Actualiza registros que coincidan con los filtros.
        
        Args:
            {% for column in model.columns %}
            {% if column.args.get('primary_key', False) %}
            {{ column.name }}: Identificador del registro
            {% endif -%}
            {% endfor %}
            updated_values: Datos a actualizar
            session: Sesión existente (opcional)
            
        Returns:
            Número de registros actualizados
        """
        logger.info(f"[{{ schema_name }}] 🔄 Actualizando {{ model.name }}:")
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        logger.info(f"[{{ schema_name }}]     {{ column.name }}={{ '{' }}{{ column.name }}{{ '}' }}")
        {% endif %}
        {% endfor %}
        logger.info(f"[{{ schema_name }}]     valores={updated_values.to_dict()}")

        query = update({{ model.name }})
        
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        query = query.where({{ model.name }}.{{ column.name }} == {{ column.name }})
        {% endif -%}
        {% endfor %}

        update_data = updated_values.to_dict()

        if not update_data:  # Solo actualizar si hay datos
            return 0
        
        query = query.values(**update_data)

        if session is not None:
            result = await session.execute(query)
        else:
            async with self.session_manager.get_session() as session:
                result = await session.execute(query)
        
        logger.info(f"[{{ schema_name }}]  ✅ {result.rowcount} registros {{ model.name }} actualizados exitosamente")

        return result.rowcount
    
    @error_handler
    async def update_many(
        self,
        payload: {{ model.name }}Update, 
        session: Optional[AsyncSession] = None
    ) -> int:
        """
        Actualiza múltiples registros basándose en campos de coincidencia.
        
        Args:
            payload: Datos de actualización y filtros
            session: Sesión existente (opcional)
            
        Returns:
            Número total de registros actualizados
        """
        logger.info(f"[{{ schema_name }}] 🔄 Actualizando múltiples {{ model.name }} con filtros: {payload.filter.to_dict()}, valores: {payload.values.to_dict()}")
            
        filters = payload.filter.to_dict()
        values = payload.values.to_dict()
        
        if not filters and not values:  # Solo actualizar si hay filtros y valores
            return 0

        query = update({{ model.name }})
        
        for key, value in filters.items():
            query = query.where(getattr({{ model.name }}, key) == value)
        
        query = query.values(**values)
                
        if session is not None:
            result = await session.execute(query)
        else:
            async with self.session_manager.get_session() as session:
                result = await session.execute(query)
        
        logger.info(f"[{{ schema_name }}] ✅ {result.rowcount} registros {{ model.name }} actualizados masivamente exitosamente")

        return result.rowcount
    
    {% if not all_pk_autoincrement %}
    @error_handler
    async def upsert(
        self,
        {{ model.tablename }}: {{ model.name }}Create,
        match_fields: List[str] = [
            {% for column in model.columns %}
            {% if column.args.get('primary_key', False) %}
            '{{ column.name }}'{{ ', ' if not loop.last }}
            {% endif %}
            {% endfor %}
        ],
        session: Optional[AsyncSession] = None
    ) -> {{ model.name }}Read:
        """
        Inserta o actualiza un registro (upsert).
        
        Args:
            {{ model.tablename }}: Datos del registro a insertar o actualizar
            match_fields: Campos a usar para verificar si el registro existe. 
                         Por defecto usa las claves primarias.
            session: Sesión existente (opcional)
            
        Returns:
            Instancia del modelo (creada o actualizada)
        """
        logger.info(f"[{{ schema_name }}] 🔄 Upsert {{ model.name }} con campos de coincidencia: {match_fields}, datos: {{ "{" }}{{ model.tablename }}.to_dict(){{ "}" }}")
        
        record_dict = {{ model.tablename }}.to_dict()

        # Buscar registro existente usando los campos de coincidencia
        if not match_fields:
            raise ValueError("match_fields no puede estar vacío. Debe contener al menos un campo para identificar registros.")

        for field in match_fields:
            if not field in record_dict:
                raise ValueError(f"El campo '{field}' debe estar presente en '{{ model.tablename }}' para upsert.")
            if record_dict[field] is None:
                raise ValueError(f"El campo '{field}' no puede ser None. Debe tener un valor para upsert.")

        filters = {field: getattr({{ model.tablename }}, field) for field in match_fields}

        async def execute_query(session: AsyncSession) -> Optional[{{ model.name }}]:

            query = select({{ model.name }})

            for key, value in filters.items():
                query = query.where(getattr({{ model.name }}, key) == value)
            
            result = await session.execute(query)
            existing = result.scalars().first()
            
            if existing:
                # Actualizar registro existente usando la instancia de SQLAlchemy
                update_data = {k: v for k, v in record_dict.items() if k not in match_fields}
                
                if update_data:
                    # Actualizar atributos directamente en la instancia
                    for key, value in update_data.items():
                        if hasattr(existing, key):
                            setattr(existing, key, value)
                    
                    await session.flush()  # Aplicar cambios a la base de datos
                return existing
            else:
                # Crear nuevo registro
                instance = {{ model.name }}(**record_dict)
                session.add(instance)
                await session.flush()
                return instance

        if session is not None:
            instance = await execute_query(session)
            result = {{ model.name }}Read.from_instance(instance)
            logger.info(f"[{{ schema_name }}] ✅ Upsert {{ model.name }} completado exitosamente")
            return result
        else:
            async with self.session_manager.get_session() as session:
                instance = await execute_query(session)
                result = {{ model.name }}Read.from_instance(instance)
                logger.info(f"[{{ schema_name }}] ✅ Upsert {{ model.name }} completado exitosamente")
                return result
    
    @error_handler
    async def upsert_many(
        self,
        records: List[{{ model.name }}Create],
        match_fields: List[str] = [
            {% for column in model.columns %}
            {% if column.args.get('primary_key', False) %}
            '{{ column.name }}'{{ ', ' if not loop.last }}
            {% endif %}
            {% endfor %}
        ],
        session: Optional[AsyncSession] = None
    ) -> int:
        """
        Inserta o actualiza múltiples registros.
        
        Args:
            {{ model.tablename }}: Lista de registros a insertar o actualizar
            match_fields: Campos a usar para verificar si los registros existen
            session: Sesión existente (opcional)
            
        Returns:
            Número de registros creados o actualizados
        """
        logger.info(f"[{{ schema_name }}] 🔄 Upsert masivo {{ model.name }} con {len(records)} registros, campos de coincidencia: {match_fields}")
        
        results = []

        if session is not None:
            for record in records:
                result = await self.upsert(record, match_fields, session)
                results.append(result)
        else:
            async with self.session_manager.get_session() as session:
                for record in records:
                    result = await self.upsert(record, match_fields, session)
                    results.append(result)

        logger.info(f"[{{ schema_name }}] ✅ Upsert masivo {{ model.name }} completado: {len(results)} registros procesados")

        return len(results)

    {% endif %}
    @error_handler
    async def delete(
        self, 
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        {{ column.name }}: {{ column.type }},
        {% endif %}
        {% endfor %}
        session: Optional[AsyncSession] = None
    ) -> int:
        """
        Elimina un registro atentiendo a su primary key.
        
        Args:
            {% for column in model.columns %}
            {% if column.args.get('primary_key', False) %}
            {{ column.name }}: Filtrar por {{ column.name }} para eliminar
            {% endif %}
            {% endfor %}
            session: Sesión existente (opcional)
            
        Returns:
            Número de registros eliminados
        """
        logger.info(f"[{{ schema_name }}] 🗑️ Eliminando {{ model.name }}:")
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        logger.info(f"[{{ schema_name }}]    {{ column.name }}={{ '{' }}{{ column.name }}{{ '}' }}")
        {% endif %}
        {% endfor %}

        query = delete({{ model.name }})
        
        {% for column in model.columns %}
        {% if column.args.get('primary_key', False) %}
        query = query.where({{ model.name }}.{{ column.name }} == {{ column.name }})
        {% endif %}
        {% endfor %}

        if session is not None:
            result = await session.execute(query)
        else:
            async with self.session_manager.get_session() as session:
                result = await session.execute(query)

        logger.info(f"[{{ schema_name }}] ✅ {result.rowcount} registros {{ model.name }} eliminados exitosamente")

        return result.rowcount
    
    @error_handler
    async def delete_many(self, filters_list: List[Dict[str, Any]]) -> int:
        """
        Elimina múltiples registros basándose en una lista de filtros.
        
        Args:
            filters_list: Lista de diccionarios con filtros para cada eliminación
            
        Returns:
            Número total de registros eliminados
        """
        logger.info(f"[{{ schema_name }}] 🗑️ Eliminando múltiples {{ model.name }} con {len(filters_list)} filtros")

        total_deleted = 0
        async def execute_query(session: AsyncSession) -> int:
            for filters in filters_list:
                query = delete({{ model.name }})
                
                for key, value in filters.items():
                    if hasattr({{ model.name }}, key):
                        query = query.where(getattr({{ model.name }}, key) == value)
                
                result = await session.execute(query)
                total_deleted += result.rowcount
        
        if session is not None:
            await execute_query(session)
        else:
            async with self.session_manager.get_session() as session:
                await execute_query(session)
        
        logger.info(f"[{{ schema_name }}] ✅ {total_deleted} registros {{ model.name }} eliminados masivamente exitosamente")
        
        return total_deleted
    
    @error_handler
    async def count(
        self,
        {{ macros.generate_query_parameters(model).rstrip('\n') | indent(8) }}
        session: Optional[AsyncSession] = None
    ) -> int:
        """
        Cuenta registros que coincidan con los filtros.
        
        Args:
            {{ macros.generate_query_args(model).rstrip('\n') | indent(12) }}
            session: Sesión existente (opcional)
            
        Returns:
            Número de registros que coinciden con los filtros
        """
        logger.info(f"[{{ schema_name }}] 🔢 Contando registros {{ model.name }} con filtros aplicados")
        
        query = select(func.count()).select_from({{ model.name }})
        
        {{ macros.generate_filter_query(model).rstrip('\n') | indent(8) }}

        if session is not None:
            result = await session.execute(query)
        else:
            async with self.session_manager.get_session() as session:
                result = await session.execute(query)

        count_result = result.scalar() or 0
        logger.info(f"[{{ schema_name }}] ✅ Conteo {{ model.name }} completado: {count_result} registros")
        return count_result
    
    @error_handler
    async def exists(
        self,
        {{ macros.generate_query_parameters(model).rstrip('\n') | indent(8) }}
        session: Optional[AsyncSession] = None
    ) -> bool:
        """
        Verifica si existe al menos un registro que coincida con los filtros.
        
        Args:
            {{ macros.generate_query_args(model).rstrip('\n') | indent(12) }}
            session: Sesión existente (opcional)
            
        Returns:
            True si existe al menos un registro, False en caso contrario
        """
        logger.info(f"[{{ schema_name }}] ❓ Verificando existencia de registros {{ model.name }}")
        
        records = await self.count(
            {{ macros.asing_parameters(model).rstrip('\n') | indent(12) }}
            session=session
        )
        exists_result = records > 0
        logger.info(f"[{{ schema_name }}] ✅ Verificación {{ model.name }} completada: {'existe' if exists_result else 'no existe'}")
        return exists_result

    {% endif %}

{% endfor %}

