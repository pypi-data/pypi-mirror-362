{
  "id": "model_context_protocol_standards",
  "name": "Model Context Protocol Standards",
  "category": "mcp",
  "tags": [
    "best-practices",
    "security",
    "performance",
    "monitoring"
  ],
  "description": "**Version:** 1.0.0",
  "sections": [
    "ðŸŽ¯ Micro Summary (100 tokens)",
    "Table of Contents",
    "Overview",
    "Core Principles",
    "MCP Architecture Standards",
    "Server Implementation Standards",
    "Client Integration Standards",
    "Tool Development Standards",
    "Resource Management Standards",
    "Security and Privacy Standards"
  ],
  "version": "1.0.0",
  "content": "# Model Context Protocol Standards\n\n**Version:** 1.0.0\n**Last Updated:** 2025-07-02\n**Status:** Active\n**Standard Code:** MCP\n\n## ðŸŽ¯ Micro Summary (100 tokens)\n\nMCP enables AI assistants to interact with external services through:\n- **Servers**: Expose tools/resources via standard protocol\n- **Clients**: Connect to servers with retry/caching\n- **Tools**: Executable functions with validated parameters\n- **Resources**: Data providers with URI-based access\n- **Security**: JWT auth + input validation + privacy filters\n\nKey pattern: `Server â†’ Transport â†’ Client â†’ Tool/Resource â†’ Response`\n\n---\n\n## Table of Contents\n\n1. [Overview](#overview)\n2. [Core Principles](#core-principles)\n3. [MCP Architecture Standards](#mcp-architecture-standards)\n4. [Server Implementation Standards](#server-implementation-standards)\n5. [Client Integration Standards](#client-integration-standards)\n6. [Tool Development Standards](#tool-development-standards)\n7. [Resource Management Standards](#resource-management-standards)\n8. [Security and Privacy Standards](#security-and-privacy-standards)\n9. [Testing and Validation](#testing--validation)\n10. [Performance Guidelines](#performance-guidelines)\n11. [Implementation Checklist](#implementation-checklist)\n\n---\n\n## Overview\n\nThe Model Context Protocol (MCP) is an open standard that enables seamless integration between AI assistants and external data sources, tools, and services. This standard defines best practices for implementing MCP servers, clients, and tools within the comprehensive standards framework.\n\n### Quick Start\n\n```bash\n# Install MCP SDK\nnpm install @modelcontextprotocol/sdk\n\n# Create basic server\nmcp-server init my-server\n\n# Test connection\nmcp-client test --server localhost:3000\n```\n\n### When to Use This Standard\n\n- Building MCP servers to expose data or functionality to AI assistants\n- Integrating MCP clients into applications\n- Developing tools that AI assistants can invoke\n- Creating resource providers for AI context\n- Implementing secure AI-to-service communications\n\n### Prerequisites\n\n- Understanding of [CLAUDE.md](../core/CLAUDE.md) for LLM optimization\n- Familiarity with [CS:api](CODING_STANDARDS.md#14-api-design) standards\n- Knowledge of [SEC:auth](MODERN_SECURITY_STANDARDS.md#api-authentication-and-authorization) patterns\n- Background in event-driven architectures ([EVT:*](EVENT_DRIVEN_STANDARDS.md))\n\n### ðŸš€ Quick Reference\n\n| Component | Key Requirements | Priority |\n|-----------|------------------|----------|\n| Server | Base class, error handling, transport | Critical |\n| Client | Retry logic, caching, connection pool | High |\n| Tools | Parameter validation, execution monitoring | High |\n| Resources | URI validation, caching strategy | Medium |\n| Security | JWT auth, input validation, privacy filters | Critical |\n\n### ðŸ“Œ Common MCP Patterns\n\n```python\n# Quick Server Setup\nserver = MCPServer(\"my-server\", StdioTransport())\nserver.register_tool(MyTool())\nawait server.start()\n\n# Quick Client Connection\nclient = StandardMCPClient({})\nawait client.connect(\"server-uri\")\nresult = await client.callTool(\"tool-name\", params)\n\n# Quick Tool Definition\nclass MyTool(MCPTool):\n    def __init__(self):\n        super().__init__(\"my_tool\", \"Tool description\")\n        self.add_parameter(MCPToolParameter(\n            name=\"param\", type=\"string\", description=\"Param desc\"\n        ))\n```\n\n---\n\n## Core Principles\n\n### 1. Context Efficiency\n\n**Summary:** Minimize token usage while preserving essential context\n**Priority:** Critical\n**Token Estimate:** ~200\n\nOptimize for minimal token usage while maintaining comprehensive context:\n\n```python\n# Good: Efficient context structure\nclass MCPContext:\n    \"\"\"Minimal context with progressive disclosure.\"\"\"\n\n    def __init__(self):\n        self.summary = {}  # Quick access data\n        self.detailed = {}  # Load on demand\n        self.metadata = {\n            \"token_estimate\": 0,\n            \"priority\": \"high\",\n            \"cacheable\": True\n        }\n\n    def get_context(self, level=\"summary\"):\n        \"\"\"Return context at requested detail level.\"\"\"\n        if level == \"summary\":\n            return self.summary\n        return {**self.summary, **self.detailed}\n```\n\n### 2. Standardized Communication\n\n**Summary:** Use consistent message formats across all MCP interactions\n**Priority:** Critical\n**Token Estimate:** ~150\n\nFollow consistent patterns for all MCP communications:\n\n```typescript\n// Standard message structure\ninterface MCPMessage {\n  id: string;\n  method: string;\n  params?: any;\n  meta: {\n    timestamp: number;\n    version: string;\n    tokenEstimate?: number;\n  };\n}\n\n// Standard response structure\ninterface MCPResponse {\n  id: string;\n  result?: any;\n  error?: MCPError;\n  meta: {\n    processingTime: number;\n    tokensUsed?: number;\n  };\n}\n```\n\n### 3. Progressive Loading\n\n**Summary:** Load data incrementally based on detail level requirements\n**Priority:** High\n**Token Estimate:** ~150\n\nImplement progressive loading patterns aligned with [KM:progressive-disclosure](KNOWLEDGE_MANAGEMENT_STANDARDS.md#progressive-disclosure-system):\n\n```python\nclass ProgressiveResource:\n    \"\"\"Resource with progressive loading capabilities.\"\"\"\n\n    def __init__(self, resource_id: str):\n        self.id = resource_id\n        self.levels = [\"micro\", \"summary\", \"detailed\", \"complete\"]\n\n    async def load(self, level: str = \"summary\"):\n        \"\"\"Load resource at specified detail level.\"\"\"\n        if level not in self.levels:\n            raise ValueError(f\"Invalid level: {level}\")\n\n        # Load only what's needed\n        data = await self._fetch_data(level)\n        return self._optimize_tokens(data, level)\n```\n\n---\n\n## MCP Architecture Standards\n\n**Section Summary:** Define modular server structure, manifest requirements, and transport options\n**Tokens:** ~1500 | **Priority:** High\n\n### [REQUIRED] Server Architecture\n\nMCP servers must follow a modular, extensible architecture:\n\n```\nmcp-server/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ server.py           # Main server implementation\nâ”‚   â”œâ”€â”€ handlers/           # Request handlers\nâ”‚   â”‚   â”œâ”€â”€ tools.py       # Tool execution\nâ”‚   â”‚   â”œâ”€â”€ resources.py   # Resource management\nâ”‚   â”‚   â””â”€â”€ prompts.py     # Prompt handling\nâ”‚   â”œâ”€â”€ security/          # Security implementations\nâ”‚   â”‚   â”œâ”€â”€ auth.py        # Authentication\nâ”‚   â”‚   â””â”€â”€ validation.py  # Input validation\nâ”‚   â”œâ”€â”€ utils/             # Utilities\nâ”‚   â””â”€â”€ config/            # Configuration\nâ”œâ”€â”€ tests/                 # Test suite (85%+ coverage)\nâ”œâ”€â”€ docs/                  # Documentation\nâ””â”€â”€ mcp.json              # MCP manifest\n```\n\n### [REQUIRED] MCP Manifest\n\nEvery MCP server must include a manifest:\n\n```json\n{\n  \"name\": \"my-mcp-server\",\n  \"version\": \"1.0.0\",\n  \"description\": \"MCP server for X functionality\",\n  \"author\": \"Your Name\",\n  \"license\": \"MIT\",\n  \"capabilities\": {\n    \"tools\": true,\n    \"resources\": true,\n    \"prompts\": false,\n    \"sampling\": false\n  },\n  \"requirements\": {\n    \"mcp\": \">=1.0.0\",\n    \"python\": \">=3.9\"\n  },\n  \"security\": {\n    \"authentication\": \"bearer\",\n    \"rateLimit\": {\n      \"requests\": 1000,\n      \"window\": \"1h\"\n    }\n  }\n}\n```\n\n### [RECOMMENDED] Transport Layer\n\nImplement multiple transport options:\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass MCPTransport(ABC):\n    \"\"\"Base transport interface.\"\"\"\n\n    @abstractmethod\n    async def send(self, message: dict) -> dict:\n        \"\"\"Send message and await response.\"\"\"\n        pass\n\n    @abstractmethod\n    async def connect(self) -> None:\n        \"\"\"Establish connection.\"\"\"\n        pass\n\nclass StdioTransport(MCPTransport):\n    \"\"\"Standard I/O transport for local communication.\"\"\"\n\n    async def send(self, message: dict) -> dict:\n        # Implementation for stdio\n        pass\n\nclass HTTPTransport(MCPTransport):\n    \"\"\"HTTP/WebSocket transport for remote communication.\"\"\"\n\n    def __init__(self, endpoint: str, auth_token: str = None):\n        self.endpoint = endpoint\n        self.auth_token = auth_token\n\n    async def send(self, message: dict) -> dict:\n        # Implementation for HTTP\n        pass\n```\n\n---\n\n## Server Implementation Standards\n\n**Section Summary:** Base server class, error handling patterns, and implementation examples\n**Tokens:** ~2500 | **Priority:** High\n\n### [REQUIRED] Base Server Class\n\nAll MCP servers must extend a common base class:\n\n```python\nfrom typing import Dict, List, Optional\nimport asyncio\nimport logging\n\nclass MCPServer:\n    \"\"\"Base MCP server implementation.\"\"\"\n\n    def __init__(self, name: str, transport: MCPTransport):\n        self.name = name\n        self.transport = transport\n        self.handlers = {}\n        self.resources = {}\n        self.tools = {}\n        self.logger = logging.getLogger(name)\n\n        # Register standard handlers\n        self._register_standard_handlers()\n\n    def _register_standard_handlers(self):\n        \"\"\"Register required MCP handlers.\"\"\"\n        self.register_handler(\"initialize\", self._handle_initialize)\n        self.register_handler(\"list_tools\", self._handle_list_tools)\n        self.register_handler(\"list_resources\", self._handle_list_resources)\n        self.register_handler(\"call_tool\", self._handle_call_tool)\n        self.register_handler(\"read_resource\", self._handle_read_resource)\n\n    async def start(self):\n        \"\"\"Start the MCP server.\"\"\"\n        self.logger.info(f\"Starting MCP server: {self.name}\")\n        await self.transport.connect()\n        await self._run_event_loop()\n\n    def register_tool(self, tool: 'MCPTool'):\n        \"\"\"Register a tool with the server.\"\"\"\n        # Validate tool\n        tool.validate()\n        self.tools[tool.name] = tool\n        self.logger.info(f\"Registered tool: {tool.name}\")\n\n    def register_resource(self, resource: 'MCPResource'):\n        \"\"\"Register a resource with the server.\"\"\"\n        # Validate resource\n        resource.validate()\n        self.resources[resource.uri] = resource\n        self.logger.info(f\"Registered resource: {resource.uri}\")\n```\n\n### [REQUIRED] Error Handling\n\nImplement comprehensive error handling following [CS:error-handling](CODING_STANDARDS.md#6-error-handling):\n\n```python\nclass MCPError(Exception):\n    \"\"\"Base MCP error class.\"\"\"\n\n    def __init__(self, code: int, message: str, details: dict = None):\n        self.code = code\n        self.message = message\n        self.details = details or {}\n        super().__init__(message)\n\n    def to_dict(self) -> dict:\n        return {\n            \"code\": self.code,\n            \"message\": self.message,\n            \"details\": self.details\n        }\n\nclass MCPValidationError(MCPError):\n    \"\"\"Validation error for invalid requests.\"\"\"\n\n    def __init__(self, message: str, field: str = None):\n        details = {\"field\": field} if field else {}\n        super().__init__(400, message, details)\n\nclass MCPAuthenticationError(MCPError):\n    \"\"\"Authentication error.\"\"\"\n\n    def __init__(self, message: str = \"Authentication required\"):\n        super().__init__(401, message)\n\nclass MCPRateLimitError(MCPError):\n    \"\"\"Rate limit exceeded error.\"\"\"\n\n    def __init__(self, retry_after: int):\n        super().__init__(429, \"Rate limit exceeded\", {\"retry_after\": retry_after})\n```\n\n---\n\n## Client Integration Standards\n\n**Section Summary:** Client interface, connection management, and intelligent caching\n**Tokens:** ~2000 | **Priority:** High\n\n### [REQUIRED] Client Implementation\n\nMCP clients must implement a standard interface:\n\n```typescript\ninterface MCPClient {\n  // Connection management\n  connect(serverUri: string, options?: ConnectionOptions): Promise<void>;\n  disconnect(): Promise<void>;\n  isConnected(): boolean;\n\n  // Tool operations\n  listTools(): Promise<Tool[]>;\n  callTool(name: string, params: any): Promise<any>;\n\n  // Resource operations\n  listResources(): Promise<Resource[]>;\n  readResource(uri: string): Promise<any>;\n  subscribeToResource(uri: string, callback: (data: any) => void): Subscription;\n\n  // Event handling\n  on(event: string, handler: Function): void;\n  off(event: string, handler: Function): void;\n}\n\nclass StandardMCPClient implements MCPClient {\n  private connection: MCPConnection;\n  private subscriptions: Map<string, Subscription>;\n\n  constructor(private config: ClientConfig) {\n    this.subscriptions = new Map();\n  }\n\n  async connect(serverUri: string, options?: ConnectionOptions): Promise<void> {\n    // Implement connection with retry logic\n    const maxRetries = options?.maxRetries || 3;\n    let attempt = 0;\n\n    while (attempt < maxRetries) {\n      try {\n        this.connection = await this.createConnection(serverUri, options);\n        await this.initialize();\n        break;\n      } catch (error) {\n        attempt++;\n        if (attempt === maxRetries) throw error;\n        await this.delay(Math.pow(2, attempt) * 1000); // Exponential backoff\n      }\n    }\n  }\n}\n```\n\n### [RECOMMENDED] Client Caching\n\nImplement intelligent caching aligned with [CLAUDE.md cache management](../core/CLAUDE.md#cache-management):\n\n```python\nfrom functools import lru_cache\nfrom datetime import datetime, timedelta\n\nclass MCPClientCache:\n    \"\"\"Intelligent caching for MCP clients.\"\"\"\n\n    def __init__(self, default_ttl: int = 3600):\n        self.default_ttl = default_ttl\n        self.cache = {}\n        self.metadata = {}\n\n    def get(self, key: str) -> Optional[any]:\n        \"\"\"Get cached value if not expired.\"\"\"\n        if key in self.cache:\n            meta = self.metadata[key]\n            if datetime.now() < meta[\"expires\"]:\n                meta[\"hits\"] += 1\n                return self.cache[key]\n            else:\n                # Expired, remove\n                del self.cache[key]\n                del self.metadata[key]\n        return None\n\n    def set(self, key: str, value: any, ttl: int = None):\n        \"\"\"Cache value with TTL.\"\"\"\n        ttl = ttl or self.default_ttl\n        self.cache[key] = value\n        self.metadata[key] = {\n            \"expires\": datetime.now() + timedelta(seconds=ttl),\n            \"hits\": 0,\n            \"size\": self._estimate_size(value)\n        }\n\n    @lru_cache(maxsize=100)\n    def _estimate_size(self, value: any) -> int:\n        \"\"\"Estimate memory size of cached value.\"\"\"\n        # Implementation for size estimation\n        pass\n```\n\n---\n\n## Tool Development Standards\n\n**Section Summary:** Tool structure, parameter validation, and concrete examples\n**Tokens:** ~2200 | **Priority:** High\n\n### [REQUIRED] Tool Structure\n\nAll MCP tools must follow this structure:\n\n```python\nfrom typing import Dict, Any, List\nfrom pydantic import BaseModel, Field\n\nclass MCPToolParameter(BaseModel):\n    \"\"\"Tool parameter definition.\"\"\"\n    name: str\n    type: str\n    description: str\n    required: bool = True\n    default: Any = None\n    enum: List[str] = None\n\nclass MCPTool:\n    \"\"\"Base class for MCP tools.\"\"\"\n\n    def __init__(self, name: str, description: str):\n        self.name = name\n        self.description = description\n        self.parameters: List[MCPToolParameter] = []\n        self._validator = None\n\n    def add_parameter(self, param: MCPToolParameter):\n        \"\"\"Add parameter to tool.\"\"\"\n        self.parameters.append(param)\n        self._rebuild_validator()\n\n    def validate(self):\n        \"\"\"Validate tool configuration.\"\"\"\n        if not self.name:\n            raise ValueError(\"Tool name is required\")\n        if not self.description:\n            raise ValueError(\"Tool description is required\")\n        # Additional validation\n\n    async def execute(self, params: Dict[str, Any]) -> Any:\n        \"\"\"Execute the tool with given parameters.\"\"\"\n        # Validate parameters\n        validated = self._validate_params(params)\n\n        # Execute with monitoring\n        start_time = time.time()\n        try:\n            result = await self._execute_impl(validated)\n            self._record_success(time.time() - start_time)\n            return result\n        except Exception as e:\n            self._record_failure(time.time() - start_time, e)\n            raise\n\n    async def _execute_impl(self, params: Dict[str, Any]) -> Any:\n        \"\"\"Actual tool implementation - override in subclasses.\"\"\"\n        raise NotImplementedError\n```\n\n### [REQUIRED] Tool Examples\n\nProvide concrete tool implementations:\n\n```python\nclass DatabaseQueryTool(MCPTool):\n    \"\"\"Tool for executing database queries.\"\"\"\n\n    def __init__(self, connection_string: str):\n        super().__init__(\n            name=\"database_query\",\n            description=\"Execute SQL queries with safety checks\"\n        )\n        self.connection_string = connection_string\n\n        # Define parameters\n        self.add_parameter(MCPToolParameter(\n            name=\"query\",\n            type=\"string\",\n            description=\"SQL query to execute\"\n        ))\n        self.add_parameter(MCPToolParameter(\n            name=\"params\",\n            type=\"object\",\n            description=\"Query parameters for safe execution\",\n            required=False,\n            default={}\n        ))\n\n    async def _execute_impl(self, params: Dict[str, Any]) -> Any:\n        \"\"\"Execute database query safely.\"\"\"\n        query = params[\"query\"]\n        query_params = params.get(\"params\", {})\n\n        # Validate query (prevent SQL injection)\n        if not self._is_safe_query(query):\n            raise MCPValidationError(\"Unsafe query detected\")\n\n        # Execute with connection pooling\n        async with self._get_connection() as conn:\n            result = await conn.fetch(query, **query_params)\n            return [dict(row) for row in result]\n\n    def _is_safe_query(self, query: str) -> bool:\n        \"\"\"Check if query is safe to execute.\"\"\"\n        # Implement safety checks\n        dangerous_keywords = [\"DROP\", \"DELETE\", \"TRUNCATE\", \"ALTER\"]\n        query_upper = query.upper()\n        return not any(kw in query_upper for kw in dangerous_keywords)\n```\n\n---\n\n## Resource Management Standards\n\n**Section Summary:** Resource contracts, caching strategies, and common resource types\n**Tokens:** ~1800 | **Priority:** Medium\n\n### [REQUIRED] Resource Definition\n\nDefine resources with clear contracts:\n\n```python\nclass MCPResource:\n    \"\"\"Base class for MCP resources.\"\"\"\n\n    def __init__(self, uri: str, name: str, mime_type: str = \"application/json\"):\n        self.uri = uri\n        self.name = name\n        self.mime_type = mime_type\n        self.metadata = {\n            \"created\": datetime.now(),\n            \"version\": \"1.0.0\",\n            \"cacheable\": True,\n            \"ttl\": 3600\n        }\n\n    def validate(self):\n        \"\"\"Validate resource configuration.\"\"\"\n        if not self.uri:\n            raise ValueError(\"Resource URI is required\")\n        if not self.uri.startswith((\"file://\", \"http://\", \"https://\", \"data:\")):\n            raise ValueError(\"Invalid URI scheme\")\n\n    async def read(self, options: Dict[str, Any] = None) -> Any:\n        \"\"\"Read resource data.\"\"\"\n        # Check cache first\n        cached = await self._check_cache()\n        if cached:\n            return cached\n\n        # Load data\n        data = await self._load_data(options)\n\n        # Cache if appropriate\n        if self.metadata.get(\"cacheable\"):\n            await self._cache_data(data)\n\n        return data\n\n    async def subscribe(self, callback: Callable) -> 'Subscription':\n        \"\"\"Subscribe to resource changes.\"\"\"\n        return Subscription(self, callback)\n```\n\n### [RECOMMENDED] Resource Types\n\nImplement common resource types:\n\n```python\nclass FileResource(MCPResource):\n    \"\"\"File-based resource.\"\"\"\n\n    def __init__(self, file_path: str):\n        uri = f\"file://{os.path.abspath(file_path)}\"\n        name = os.path.basename(file_path)\n        mime_type = self._detect_mime_type(file_path)\n        super().__init__(uri, name, mime_type)\n        self.file_path = file_path\n\n    async def _load_data(self, options: Dict[str, Any] = None) -> Any:\n        \"\"\"Load file data.\"\"\"\n        async with aiofiles.open(self.file_path, 'r') as f:\n            content = await f.read()\n\n        if self.mime_type == \"application/json\":\n            return json.loads(content)\n        return content\n\nclass APIResource(MCPResource):\n    \"\"\"API-based resource.\"\"\"\n\n    def __init__(self, endpoint: str, auth_token: str = None):\n        super().__init__(endpoint, endpoint.split('/')[-1])\n        self.endpoint = endpoint\n        self.auth_token = auth_token\n\n    async def _load_data(self, options: Dict[str, Any] = None) -> Any:\n        \"\"\"Load data from API.\"\"\"\n        headers = {}\n        if self.auth_token:\n            headers[\"Authorization\"] = f\"Bearer {self.auth_token}\"\n\n        async with aiohttp.ClientSession() as session:\n            async with session.get(self.endpoint, headers=headers) as response:\n                response.raise_for_status()\n                return await response.json()\n```\n\n---\n\n## Security and Privacy Standards\n\n**Section Summary:** Authentication, input validation, and privacy controls\n**Tokens:** ~2500 | **Priority:** Critical\n\n### [REQUIRED] Authentication\n\nImplement authentication following [SEC:auth](MODERN_SECURITY_STANDARDS.md#api-authentication-and-authorization):\n\n```python\nfrom abc import ABC, abstractmethod\nimport jwt\nimport secrets\n\nclass MCPAuthenticator(ABC):\n    \"\"\"Base authenticator for MCP servers.\"\"\"\n\n    @abstractmethod\n    async def authenticate(self, credentials: Dict[str, Any]) -> bool:\n        \"\"\"Authenticate request.\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_permissions(self, identity: str) -> List[str]:\n        \"\"\"Get permissions for authenticated identity.\"\"\"\n        pass\n\nclass JWTAuthenticator(MCPAuthenticator):\n    \"\"\"JWT-based authentication.\"\"\"\n\n    def __init__(self, secret_key: str, algorithm: str = \"HS256\"):\n        self.secret_key = secret_key\n        self.algorithm = algorithm\n\n    async def authenticate(self, credentials: Dict[str, Any]) -> bool:\n        \"\"\"Validate JWT token.\"\"\"\n        token = credentials.get(\"token\")\n        if not token:\n            return False\n\n        try:\n            payload = jwt.decode(\n                token,\n                self.secret_key,\n                algorithms=[self.algorithm]\n            )\n            # Additional validation\n            return self._validate_claims(payload)\n        except jwt.InvalidTokenError:\n            return False\n\n    def _validate_claims(self, payload: dict) -> bool:\n        \"\"\"Validate JWT claims.\"\"\"\n        # Check expiration\n        if \"exp\" in payload and payload[\"exp\"] < time.time():\n            return False\n\n        # Check required claims\n        required_claims = [\"sub\", \"iat\"]\n        return all(claim in payload for claim in required_claims)\n```\n\n### [REQUIRED] Input Validation\n\nValidate all inputs following [SEC:validation](MODERN_SECURITY_STANDARDS.md#4-api-security):\n\n```python\nclass MCPValidator:\n    \"\"\"Input validation for MCP requests.\"\"\"\n\n    @staticmethod\n    def validate_tool_params(tool: MCPTool, params: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Validate tool parameters.\"\"\"\n        validated = {}\n\n        for param in tool.parameters:\n            value = params.get(param.name)\n\n            # Check required\n            if param.required and value is None:\n                raise MCPValidationError(\n                    f\"Required parameter missing: {param.name}\",\n                    field=param.name\n                )\n\n            # Type validation\n            if value is not None:\n                validated[param.name] = MCPValidator._validate_type(\n                    value, param.type, param.name\n                )\n\n            # Enum validation\n            if param.enum and value not in param.enum:\n                raise MCPValidationError(\n                    f\"Invalid value for {param.name}. Must be one of: {param.enum}\",\n                    field=param.name\n                )\n\n        return validated\n\n    @staticmethod\n    def _validate_type(value: Any, expected_type: str, field: str) -> Any:\n        \"\"\"Validate parameter type.\"\"\"\n        type_map = {\n            \"string\": str,\n            \"number\": (int, float),\n            \"boolean\": bool,\n            \"object\": dict,\n            \"array\": list\n        }\n\n        expected = type_map.get(expected_type)\n        if expected and not isinstance(value, expected):\n            raise MCPValidationError(\n                f\"Invalid type for {field}. Expected {expected_type}\",\n                field=field\n            )\n\n        # Additional validation for strings\n        if expected_type == \"string\" and isinstance(value, str):\n            # Prevent injection attacks\n            if any(char in value for char in [\"<\", \">\", \"&\", '\"', \"'\"]):\n                value = html.escape(value)\n\n        return value\n```\n\n### [RECOMMENDED] Privacy Controls\n\nImplement privacy controls for sensitive data:\n\n```python\nclass MCPPrivacyFilter:\n    \"\"\"Filter sensitive data from MCP responses.\"\"\"\n\n    def __init__(self, rules: List[Dict[str, Any]]):\n        self.rules = rules\n        self.redaction_patterns = self._compile_patterns()\n\n    def filter(self, data: Any) -> Any:\n        \"\"\"Apply privacy filters to data.\"\"\"\n        if isinstance(data, dict):\n            return {k: self._filter_value(k, v) for k, v in data.items()}\n        elif isinstance(data, list):\n            return [self.filter(item) for item in data]\n        else:\n            return self._filter_value(\"\", data)\n\n    def _filter_value(self, key: str, value: Any) -> Any:\n        \"\"\"Filter individual value.\"\"\"\n        # Check rules\n        for rule in self.rules:\n            if self._matches_rule(key, value, rule):\n                return self._apply_rule(value, rule)\n\n        # Recursively filter nested structures\n        if isinstance(value, (dict, list)):\n            return self.filter(value)\n\n        return value\n\n    def _apply_rule(self, value: Any, rule: Dict[str, Any]) -> Any:\n        \"\"\"Apply privacy rule to value.\"\"\"\n        action = rule.get(\"action\", \"redact\")\n\n        if action == \"redact\":\n            return \"[REDACTED]\"\n        elif action == \"hash\":\n            return hashlib.sha256(str(value).encode()).hexdigest()[:8]\n        elif action == \"mask\":\n            if isinstance(value, str):\n                return value[:2] + \"*\" * (len(value) - 4) + value[-2:]\n            return \"[MASKED]\"\n\n        return value\n```\n\n---\n\n## Testing and Validation\n\n**Section Summary:** Test patterns, integration tests, and performance benchmarks\n**Tokens:** ~2000 | **Priority:** High\n\n### [REQUIRED] Test Suite Structure\n\nFollow [TS:*](TESTING_STANDARDS.md) with MCP-specific tests:\n\n```python\nimport pytest\nimport asyncio\nfrom unittest.mock import Mock, AsyncMock\n\nclass TestMCPServer:\n    \"\"\"Test suite for MCP server.\"\"\"\n\n    @pytest.fixture\n    async def server(self):\n        \"\"\"Create test server instance.\"\"\"\n        transport = Mock(spec=MCPTransport)\n        server = MCPServer(\"test-server\", transport)\n        yield server\n        # Cleanup\n\n    @pytest.fixture\n    async def authenticated_request(self):\n        \"\"\"Create authenticated request.\"\"\"\n        return {\n            \"id\": \"test-123\",\n            \"method\": \"call_tool\",\n            \"params\": {\n                \"name\": \"test_tool\",\n                \"arguments\": {}\n            },\n            \"auth\": {\n                \"token\": \"valid-jwt-token\"\n            }\n        }\n\n    async def test_server_initialization(self, server):\n        \"\"\"Test server initializes correctly.\"\"\"\n        assert server.name == \"test-server\"\n        assert len(server.handlers) > 0\n        assert \"initialize\" in server.handlers\n        assert \"list_tools\" in server.handlers\n\n    async def test_tool_registration(self, server):\n        \"\"\"Test tool registration.\"\"\"\n        tool = Mock(spec=MCPTool)\n        tool.name = \"test_tool\"\n        tool.validate = Mock()\n\n        server.register_tool(tool)\n\n        assert \"test_tool\" in server.tools\n        tool.validate.assert_called_once()\n\n    async def test_authentication_required(self, server):\n        \"\"\"Test authentication is enforced.\"\"\"\n        # Configure server to require auth\n        server.authenticator = Mock(spec=MCPAuthenticator)\n        server.authenticator.authenticate = AsyncMock(return_value=False)\n\n        request = {\n            \"id\": \"test-123\",\n            \"method\": \"call_tool\",\n            \"params\": {}\n        }\n\n        response = await server.handle_request(request)\n        assert response[\"error\"][\"code\"] == 401\n```\n\n### [REQUIRED] Integration Tests\n\nTest MCP server/client integration:\n\n```python\nclass TestMCPIntegration:\n    \"\"\"Integration tests for MCP.\"\"\"\n\n    @pytest.fixture\n    async def running_server(self):\n        \"\"\"Start actual MCP server.\"\"\"\n        server = await create_test_server()\n        yield server\n        await server.shutdown()\n\n    @pytest.fixture\n    async def client(self, running_server):\n        \"\"\"Create connected client.\"\"\"\n        client = StandardMCPClient({})\n        await client.connect(running_server.uri)\n        yield client\n        await client.disconnect()\n\n    async def test_end_to_end_tool_call(self, client):\n        \"\"\"Test complete tool call flow.\"\"\"\n        # List tools\n        tools = await client.listTools()\n        assert len(tools) > 0\n\n        # Call tool\n        result = await client.callTool(\"echo\", {\"message\": \"Hello MCP\"})\n        assert result == {\"echo\": \"Hello MCP\"}\n\n    async def test_resource_subscription(self, client):\n        \"\"\"Test resource subscription.\"\"\"\n        updates = []\n\n        subscription = await client.subscribeToResource(\n            \"data://test/counter\",\n            lambda data: updates.append(data)\n        )\n\n        # Wait for updates\n        await asyncio.sleep(2)\n\n        assert len(updates) > 0\n        await subscription.unsubscribe()\n```\n\n### [RECOMMENDED] Performance Tests\n\nBenchmark MCP operations:\n\n```python\nimport time\nimport statistics\n\nclass TestMCPPerformance:\n    \"\"\"Performance benchmarks for MCP.\"\"\"\n\n    @pytest.mark.benchmark\n    async def test_tool_call_performance(self, client, benchmark_tool):\n        \"\"\"Benchmark tool call performance.\"\"\"\n        timings = []\n\n        for _ in range(100):\n            start = time.time()\n            await client.callTool(benchmark_tool, {\"n\": 1000})\n            timings.append(time.time() - start)\n\n        avg_time = statistics.mean(timings)\n        p95_time = statistics.quantiles(timings, n=20)[18]  # 95th percentile\n\n        assert avg_time < 0.1  # Average under 100ms\n        assert p95_time < 0.2  # 95th percentile under 200ms\n\n    @pytest.mark.benchmark\n    async def test_concurrent_operations(self, client):\n        \"\"\"Test concurrent operation handling.\"\"\"\n        async def call_tool(n):\n            return await client.callTool(\"compute\", {\"n\": n})\n\n        start = time.time()\n        results = await asyncio.gather(*[\n            call_tool(i) for i in range(50)\n        ])\n        total_time = time.time() - start\n\n        assert len(results) == 50\n        assert total_time < 5.0  # All complete within 5 seconds\n```\n\n---\n\n## Performance Guidelines\n\n**Section Summary:** Performance targets and optimization strategies\n**Tokens:** ~1200 | **Priority:** Medium\n\n### Performance Targets\n\n| Operation                | Target | Maximum |\n| ------------------------ | ------ | ------- |\n| Tool call latency        | <50ms  | 200ms   |\n| Resource read            | <100ms | 500ms   |\n| Connection establishment | <500ms | 2s      |\n| Message parsing          | <5ms   | 20ms    |\n| Token estimation         | <1ms   | 5ms     |\n\n### Optimization Strategies\n\n1. **Connection Pooling**\n   ```python\n   class MCPConnectionPool:\n       \"\"\"Reusable connection pool.\"\"\"\n\n       def __init__(self, max_connections: int = 10):\n           self.pool = asyncio.Queue(maxsize=max_connections)\n           self.semaphore = asyncio.Semaphore(max_connections)\n   ```\n\n2. **Message Batching**\n   ```python\n   class MCPBatcher:\n       \"\"\"Batch multiple operations.\"\"\"\n\n       async def batch_call_tools(self, calls: List[Dict]) -> List[Any]:\n           \"\"\"Execute multiple tool calls efficiently.\"\"\"\n           return await asyncio.gather(*[\n               self._call_tool(**call) for call in calls\n           ])\n   ```\n\n3. **Resource Caching**\n   - Cache frequently accessed resources\n   - Implement cache warming on startup\n   - Use cache invalidation strategies\n\n---\n\n## Implementation Checklist\n\n### Phase 1: Foundation (Week 1)\n- [ ] Set up MCP server structure\n- [ ] Implement base server class\n- [ ] Add authentication mechanism\n- [ ] Create first tool implementation\n- [ ] Write basic test suite\n\n### Phase 2: Core Features (Week 2-3)\n- [ ] Implement resource management\n- [ ] Add multiple transport options\n- [ ] Create client library\n- [ ] Implement caching layer\n- [ ] Add comprehensive error handling\n- [ ] Reach 85% test coverage\n\n### Phase 3: Advanced Features (Week 4+)\n- [ ] Add resource subscriptions\n- [ ] Implement privacy filters\n- [ ] Create performance monitoring\n- [ ] Add tool composition\n- [ ] Build admin interface\n- [ ] Complete documentation\n\n### Validation Checklist\n- [ ] All [REQUIRED] standards implemented\n- [ ] Security measures in place\n- [ ] Test coverage â‰¥85%\n- [ ] Performance targets met\n- [ ] Documentation complete\n- [ ] Examples provided\n\n---\n\n## References\n\n- [Model Context Protocol Specification](https://modelcontextprotocol.io)\n- [CLAUDE.md](../core/CLAUDE.md) - LLM optimization patterns\n- [CODING_STANDARDS.md](CODING_STANDARDS.md) - General coding standards\n- [MODERN_SECURITY_STANDARDS.md](MODERN_SECURITY_STANDARDS.md) - Security requirements\n- [TESTING_STANDARDS.md](TESTING_STANDARDS.md) - Testing requirements\n- [EVENT_DRIVEN_STANDARDS.md](EVENT_DRIVEN_STANDARDS.md) - Event patterns\n\n---\n\n## Appendix: Quick Reference\n\n### MCP Commands\n```bash\n# Start server\nmcp-server start --config mcp.json\n\n# Test connection\nmcp-client test --server localhost:3000\n\n# List available tools\nmcp-client tools --list\n\n# Call tool\nmcp-client call --tool database_query --params '{\"query\": \"SELECT * FROM users\"}'\n```\n\n### Common Patterns\n```python\n# Progressive loading\n@load MCP:overview  # Quick overview\n@load MCP:server-implementation  # Server details\n@load MCP:security  # Security specifics\n\n# Task-based loading\n@task \"build MCP server\" â†’ [MCP:server + CS:python + SEC:auth]\n@task \"integrate MCP client\" â†’ [MCP:client + CS:javascript + TS:integration]\n```\n\n### Error Codes Quick Reference\n| Code | Error | Action |\n|------|-------|--------|\n| 400 | Validation Error | Check parameters |\n| 401 | Authentication Error | Verify credentials |\n| 429 | Rate Limit | Retry after delay |\n| 500 | Server Error | Check server logs |\n\n---\n\n**Note:** This standard is a living document. Updates and improvements are welcome via pull requests to the [standards repository](https://github.com/williamzujkowski/standards).\n\n## Related Standards\n\n- [Knowledge Management Standards](KNOWLEDGE_MANAGEMENT_STANDARDS.md) - Progressive disclosure patterns\n- [Event-Driven Architecture Standards](EVENT_DRIVEN_STANDARDS.md) - Event handling patterns\n- [API Standards](CODING_STANDARDS.md#14-api-design) - API design principles\n- [Security Standards](MODERN_SECURITY_STANDARDS.md) - Security requirements\n"
}