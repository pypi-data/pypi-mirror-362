"""Trace Analysis Utilities for Playwright Crawling Sessions.

This module provides tools to inspect and summarize a `.zip` trace archive
generated by Playwright's tracing system. It parses console logs, network
resource errors, JavaScript exceptions, and user actions to help debug
or profile crawling behavior.

Main Function:
- log_trace_events(trace_path): Extracts key statistics from a Playwright
  trace archive and logs a high-level summary of what happened during the session.

Helper Functions:
- _handle_console_event
- _handle_resource_event
- _handle_action_event

These are invoked automatically when parsing events from a trace file.

"""

from collections import Counter, defaultdict
import json
import logging
from typing import Any
from urllib.parse import urlparse
import zipfile

logger = logging.getLogger(__name__)


def log_trace_events(trace_path: str) -> None:
    """Parses and logs a high-level summary of a Playwright trace archive (.zip).

    This includes:
    - Total event counts by type (e.g., console, resource, action)
    - Console errors and warning messages
    - Resource request failures grouped by domain
    - Console error frequencies
    - Click/fill/assertion failures from user action logs

    Args:
        trace_path (str): Path to a `.zip` trace archive generated by Playwright.

    Logs:
        - Event type counts
        - Console logs (including errors and warnings)
        - Resource errors (status >= 400)
        - Actions and failed assertions

    """
    event_counts: Counter = Counter()
    resource_errors: Counter = Counter()
    failed_console_resources: Counter = Counter()
    console_summary: defaultdict = defaultdict(int)
    last_console_errors: list[str] = []
    action_summary: list[str] = []

    try:
        with zipfile.ZipFile(trace_path, "r") as z:
            trace_file = next(
                (n for n in z.namelist() if n.endswith("trace.trace")), None
            )
            if not trace_file:
                logger.warning("📭 No trace file found in archive!")
                return

            with z.open(trace_file) as tf:
                for line in tf:
                    try:
                        event = json.loads(line.decode("utf-8", errors="replace"))
                        t = event.get("type")
                        event_counts[t] += 1

                        if t == "console":
                            _handle_console_event(
                                event,
                                console_summary,
                                failed_console_resources,
                                last_console_errors,
                            )
                        elif t == "pageerror":
                            last_console_errors.append(event.get("error", "").strip())
                        elif t == "resource":
                            _handle_resource_event(event, resource_errors)
                        elif t == "action":
                            _handle_action_event(
                                event, action_summary, last_console_errors
                            )
                    except Exception as err:
                        logger.warning(f"Error processing line: {err}", exc_info=True)

    except Exception as err:
        logger.warning(f"❌ Failed to parse trace archive: {err}", exc_info=True)

    logger.info("\n📊 TRACE ANALYSIS SUMMARY")
    for k, v in event_counts.items():
        logger.info(f"   • {k}: {v}")
    for domain, count in resource_errors.items():
        logger.info(f"❌ {domain}: {count} error(s)")
    for domain, count in failed_console_resources.items():
        logger.info(f"📉 {domain}: {count} console error(s)")
    for msg, count in sorted(console_summary.items(), key=lambda x: -x[1])[:10]:
        logger.info(f"🗣️ {count}x — {msg[:500]}")
    for err in last_console_errors[-10:]:
        logger.info(f"❗ {err}")
    for act in action_summary[-10:]:
        logger.info(f"🎯 {act}")


def _handle_console_event(
    event: dict[str, Any],
    summary: defaultdict,
    failed_resources: Counter,
    error_list: list[str],
) -> None:
    """Processes a single 'console' event from the trace.

    Tracks:
    - Message frequency for aggregation
    - Resource-related errors (404s, failed requests)
    - Errors and warnings for error reporting

    Args:
        event: The console event from trace.
        summary: Counts of unique console messages.
        failed_resources: Resource domains that triggered console errors.
        error_list: List of errors encountered.
    """
    level = event.get("level", "log").lower()
    text = event.get("text", "").strip()
    args = event.get("args", [])
    url_hint = next(
        (a.get("value", "").strip() for a in args if "http" in a.get("value", "")), ""
    )
    key = (text + url_hint).lower()

    summary[key] += 1

    if "404" in text or "ERR_FAILED" in text:
        if url_hint:
            domain = urlparse(url_hint).netloc
            failed_resources[domain] += 1

    if level in {"error", "warning"}:
        error_list.append(text)


def _handle_resource_event(event: dict[str, Any], resource_errors: Counter) -> None:
    """Tracks network resource failures (e.g., 404, 500) by domain.

    Args:
        event: A 'resource' event from the trace.
        resource_errors: Aggregated count of failing domains.
    """
    response = event.get("response", {})
    status = response.get("status", 0)
    if status >= 400:
        url = event.get("url", "")
        domain = urlparse(url).netloc
        resource_errors[domain] += 1


def _handle_action_event(
    event: dict[str, Any], action_list: list[str], error_list: list[str]
) -> None:
    """Logs user actions (clicks, fills) and their failures (e.g., missing elements).

    Args:
        event: A Playwright action event (type = "action").
        action_list: Human-readable summaries of the actions.
        error_list: List of errors encountered.
    """
    action = event.get("action", {})
    name = action.get("name", "")
    selector = action.get("selector", "")
    value = action.get("value", "")
    error = event.get("error")

    if name == "click":
        action_list.append(f"Click: {selector}")
    elif name == "fill":
        action_list.append(f"Fill: {selector} = {value[:20]}...")
    elif name == "assert" and error:
        error_list.append(f"Assertion failed: {error}")


def _handle_console_message(msg) -> None:
    """Logs console messages from a Playwright session with severity-aware routing.

    This version does not filter based on content — it logs all messages.
    Use external log aggregators or structured logging filters if needed.

    Args:
        msg: The console message emitted by Playwright (type, text, location, etc.).
    """
    msg_type = msg.type
    text = msg.text.strip()

    if msg_type == "error":
        logger.debug(f"🌐 Console ERROR: {text}")
    elif msg_type == "warning":
        logger.warning(f"🌐 Console WARNING: {text}")
    elif msg_type == "info":
        logger.info(f"🌐 Console INFO: {text}")
    else:
        logger.debug(f"📟 Console {msg_type.upper()}: {text}")


def setup_tracing(context, screenshots: bool = True, snapshots: bool = True) -> str:
    """Set up Playwright tracing for the given context.

    Args:
        context: The Playwright context to trace.
        screenshots: Whether to capture screenshots during tracing.
        snapshots: Whether to capture DOM snapshots during tracing.

    Returns:
        The path to the trace file that will be created.
    """
    import time

    trace_path = f"trace_{int(time.time())}.zip"
    # Note: Actual tracing setup would happen here
    # This is a stub implementation
    return trace_path


def stop_tracing(context, trace_path: str | None = None) -> None:
    """Stop tracing and save the trace file.

    Args:
        context: The Playwright context being traced.
        trace_path: Path where the trace should be saved.
    """
    # Note: Actual tracing stop would happen here
    # This is a stub implementation
    pass


def save_trace(context, destination: str) -> None:
    """Save the current trace to a specific destination.

    Args:
        context: The Playwright context with active tracing.
        destination: Destination path for saving the trace.
    """
    # Note: Actual trace saving would happen here
    # This is a stub implementation
    pass
