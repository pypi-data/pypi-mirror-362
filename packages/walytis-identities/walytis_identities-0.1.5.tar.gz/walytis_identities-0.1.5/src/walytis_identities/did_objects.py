from brenthy_tools_beta.utils import (
    bytes_to_string, time_to_string, string_to_time
)
from datetime import datetime
from dataclasses import dataclass
from typing import Type, TypeVar
from multi_crypt import Crypt
from decorate_all import decorate_all_functions
from strict_typing import strictly_typed

_Service = TypeVar('_Service', bound='Service')


@dataclass
class Service:
    """Represents a DID service.

    DID services are applications/operations registered in a DID document that
    use specific cryptographic keys also published in the DID document.
    """

    service_id: str
    family: str
    # example: 'messenger://user_id/chatroom'
    service_endpoint: str | list | dict

    @classmethod
    def from_service_spec(cls: Type[_Service], service_spec: dict) -> _Service:
        """Initialise a Service from a DID service spec from a DID document."""
        return cls(
            service_id=service_spec['id'].strip("#"),
            family=service_spec['family'],
            service_endpoint=['serviceEndpoint']
        )

    def generate_service_spec(self) -> dict:
        """Generate a service spec for a DID document."""
        return {
            "id": f"#{self.service_id}",
            "family": self.family,
            "serviceEndpoint": self.service_endpoint
        }


_Key = TypeVar('_Key', bound='Key')


@dataclass
class Key(Crypt):
    """Represents a set of cryptographic keys, compatible with DID specs."""

    family: str
    public_key: bytes
    private_key: bytes | None
    creation_time: datetime

    def __init__(
        self,
        family: str,
        public_key: bytes | str,
        private_key: bytes | str | None,
        creation_time: datetime,
    ):
        """Create a Key object."""
        if isinstance(public_key, str):
            public_key = bytes.fromhex(public_key)

        if isinstance(private_key, str):
            private_key = bytes.fromhex(private_key)
        self.family = family
        self.public_key = public_key
        self.private_key = private_key
        self.creation_time = creation_time
        super().__init__(family=self.family,
                         private_key=self.private_key, public_key=self.public_key)

    @classmethod
    def create(cls: Type[_Key], family: str) -> _Key:
        """Initialise a Key from a DID key spec from a DID document."""
        crypt = Crypt.new(family)

        return cls(
            family=crypt.family,
            public_key=crypt.public_key,
            private_key=crypt.private_key,
            creation_time=datetime.utcnow()
        )

    @classmethod
    def from_crypt(
        cls: Type[_Key],
        crypt: Crypt,
        creation_time: datetime
    ) -> _Key:
        """Create a Key object from a Crypt object."""
        return cls(
            family=crypt.family,
            public_key=crypt.public_key,
            private_key=crypt.private_key,
            creation_time=creation_time,
        )

    @classmethod
    def from_key_spec(cls: Type[_Key], key_spec: dict) -> _Key:
        """Initialise a Key from a DID key spec from a DID document."""
        key = cls(
            family=key_spec['type'],
            public_key=key_spec['publicKeyMultibase'],
            private_key=None,
            creation_time=string_to_time(key_spec['creation_time']),
        )
        if key_spec['id'].strip("#") != key.get_key_id():
            raise ValueError(
                "The key-spec's key ID doesn't match our convention"
            )
        return key

    @classmethod
    def from_key_id(cls: Type[_Key], key_id: str) -> _Key:
        """Initialise a Key from a key ID generated by this class."""
        data = key_id.split(":")
        public_key = data[-1]
        timestamp = data[-2]
        family = ":".join(data[0:-2])
        key = cls(
            family=family,
            public_key=public_key,
            private_key=None,
            creation_time=string_to_time(timestamp),
        )
        return key

    def generate_key_spec(self, controller: str) -> dict:
        """Generate a key spec for a DID document."""
        return {
            "id": f"#{self.get_key_id()}",
            "type": self.family,
            "publicKeyMultibase": self.public_key.hex(),
            "creation_time": time_to_string(self.creation_time),
            "controller": controller,
        }

    def serialise(self, crypt: Crypt, allow_missing_private_key: bool = False) -> dict:
        """Serialise this key's data, including the private key encrypted."""
        if not allow_missing_private_key and not self.private_key:
            raise ValueError(
                "Private Key is not set!\n"
                "You can use the `allow_missing_private_key` parameter to "
                "ignore this."
            )

        if not (self.family and self.public_key and self.creation_time):
            error_message = ("Not all of this objects' fields are set!"
                             "\n".join([
                                 f"family: {type(self.family)}",
                                 f"public_key: {type(self.public_key)}",
                                 f"creation_time: {type(self.creation_time)}",
                             ])
                             )
            raise ValueError(error_message)

        private_key = crypt.encrypt(
            self.private_key).hex() if self.private_key else None
        return {
            "family": self.family,
            "public_key": self.public_key.hex(),
            "private_key": private_key,
            "creation_time": time_to_string(self.creation_time),
        }

    @classmethod
    def deserialise(cls: Type[_Key], data: dict, crypt: Crypt) -> _Key:
        """Deserialise data with encrypted private key."""
        private_key = crypt.decrypt(bytes.fromhex(
            data["private_key"]))if data["private_key"] else None
        return cls(
            family=data["family"],
            public_key=data["public_key"],
            private_key=private_key,
            creation_time=string_to_time(data["creation_time"])
        )

    def get_public_key(self) -> str:
        return self.public_key.hex()

    def get_private_key(self) -> str:
        if not self.private_key:
            raise ValueError("This key's private key hasn't been defined")
        return self.private_key.hex()

    def get_key_id(self) -> str:
        if not (self.family and self.public_key and self.creation_time):
            raise ValueError("Not all of this objects' fields are set.")
        return f"{self.family}:{time_to_string(self.creation_time)}:{self.get_public_key()}"

    def __str__(self):
        return self.get_key_id()


decorate_all_functions(strictly_typed, __name__)
