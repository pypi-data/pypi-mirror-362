# coding: utf-8

"""
    API Docs

    API Documentation to interact with

    The version of the OpenAPI document: 0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional
from pydantic import BaseModel
from odin_sdk.models.aggregation import Aggregation
from odin_sdk.models.chart_type import ChartType
from odin_sdk.models.column import Column
from odin_sdk.models.compare_last_period import CompareLastPeriod
from odin_sdk.models.condition import Condition
from odin_sdk.models.count_type1 import CountType1
from odin_sdk.models.data_source import DataSource
from odin_sdk.models.date_grouping import DateGrouping
from odin_sdk.models.filters1 import Filters1
from odin_sdk.models.group_by import GroupBy
from odin_sdk.models.group_by_columns import GroupByColumns
from odin_sdk.models.inherit_dashboard_period import InheritDashboardPeriod
from odin_sdk.models.math_enabled import MathEnabled
from odin_sdk.models.math_operation import MathOperation
from odin_sdk.models.operation import Operation
from odin_sdk.models.second_filters import SecondFilters
from odin_sdk.models.second_value_column import SecondValueColumn
from odin_sdk.models.second_value_fixed import SecondValueFixed
from odin_sdk.models.second_value_operation import SecondValueOperation
from odin_sdk.models.second_value_source import SecondValueSource
from odin_sdk.models.second_value_widget_id import SecondValueWidgetId
from odin_sdk.models.series import Series
from odin_sdk.models.text_content import TextContent
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class DashboardWidgetConfig(BaseModel):
    """
    DashboardWidgetConfig
    """ # noqa: E501
    column: Optional[Column] = None
    chart_type: Optional[ChartType] = None
    group_by: Optional[GroupBy] = None
    group_by_columns: Optional[GroupByColumns] = None
    aggregation: Optional[Aggregation] = None
    series: Optional[Series] = None
    text_content: Optional[TextContent] = None
    filters: Optional[Filters1] = None
    operation: Optional[Operation] = None
    count_type: Optional[CountType1] = None
    condition: Optional[Condition] = None
    math_enabled: Optional[MathEnabled] = None
    math_operation: Optional[MathOperation] = None
    second_value_source: Optional[SecondValueSource] = None
    second_value_fixed: Optional[SecondValueFixed] = None
    second_value_column: Optional[SecondValueColumn] = None
    second_value_operation: Optional[SecondValueOperation] = None
    second_value_widget_id: Optional[SecondValueWidgetId] = None
    second_filters: Optional[SecondFilters] = None
    data_source: Optional[DataSource] = None
    date_grouping: Optional[DateGrouping] = None
    inherit_dashboard_period: Optional[InheritDashboardPeriod] = None
    compare_last_period: Optional[CompareLastPeriod] = None
    __properties: ClassVar[List[str]] = ["column", "chart_type", "group_by", "group_by_columns", "aggregation", "series", "text_content", "filters", "operation", "count_type", "condition", "math_enabled", "math_operation", "second_value_source", "second_value_fixed", "second_value_column", "second_value_operation", "second_value_widget_id", "second_filters", "data_source", "date_grouping", "inherit_dashboard_period", "compare_last_period"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of DashboardWidgetConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of column
        if self.column:
            _dict['column'] = self.column.to_dict()
        # override the default output from pydantic by calling `to_dict()` of chart_type
        if self.chart_type:
            _dict['chart_type'] = self.chart_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of group_by
        if self.group_by:
            _dict['group_by'] = self.group_by.to_dict()
        # override the default output from pydantic by calling `to_dict()` of group_by_columns
        if self.group_by_columns:
            _dict['group_by_columns'] = self.group_by_columns.to_dict()
        # override the default output from pydantic by calling `to_dict()` of aggregation
        if self.aggregation:
            _dict['aggregation'] = self.aggregation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of series
        if self.series:
            _dict['series'] = self.series.to_dict()
        # override the default output from pydantic by calling `to_dict()` of text_content
        if self.text_content:
            _dict['text_content'] = self.text_content.to_dict()
        # override the default output from pydantic by calling `to_dict()` of filters
        if self.filters:
            _dict['filters'] = self.filters.to_dict()
        # override the default output from pydantic by calling `to_dict()` of operation
        if self.operation:
            _dict['operation'] = self.operation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of count_type
        if self.count_type:
            _dict['count_type'] = self.count_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of condition
        if self.condition:
            _dict['condition'] = self.condition.to_dict()
        # override the default output from pydantic by calling `to_dict()` of math_enabled
        if self.math_enabled:
            _dict['math_enabled'] = self.math_enabled.to_dict()
        # override the default output from pydantic by calling `to_dict()` of math_operation
        if self.math_operation:
            _dict['math_operation'] = self.math_operation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of second_value_source
        if self.second_value_source:
            _dict['second_value_source'] = self.second_value_source.to_dict()
        # override the default output from pydantic by calling `to_dict()` of second_value_fixed
        if self.second_value_fixed:
            _dict['second_value_fixed'] = self.second_value_fixed.to_dict()
        # override the default output from pydantic by calling `to_dict()` of second_value_column
        if self.second_value_column:
            _dict['second_value_column'] = self.second_value_column.to_dict()
        # override the default output from pydantic by calling `to_dict()` of second_value_operation
        if self.second_value_operation:
            _dict['second_value_operation'] = self.second_value_operation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of second_value_widget_id
        if self.second_value_widget_id:
            _dict['second_value_widget_id'] = self.second_value_widget_id.to_dict()
        # override the default output from pydantic by calling `to_dict()` of second_filters
        if self.second_filters:
            _dict['second_filters'] = self.second_filters.to_dict()
        # override the default output from pydantic by calling `to_dict()` of data_source
        if self.data_source:
            _dict['data_source'] = self.data_source.to_dict()
        # override the default output from pydantic by calling `to_dict()` of date_grouping
        if self.date_grouping:
            _dict['date_grouping'] = self.date_grouping.to_dict()
        # override the default output from pydantic by calling `to_dict()` of inherit_dashboard_period
        if self.inherit_dashboard_period:
            _dict['inherit_dashboard_period'] = self.inherit_dashboard_period.to_dict()
        # override the default output from pydantic by calling `to_dict()` of compare_last_period
        if self.compare_last_period:
            _dict['compare_last_period'] = self.compare_last_period.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of DashboardWidgetConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "column": Column.from_dict(obj.get("column")) if obj.get("column") is not None else None,
            "chart_type": ChartType.from_dict(obj.get("chart_type")) if obj.get("chart_type") is not None else None,
            "group_by": GroupBy.from_dict(obj.get("group_by")) if obj.get("group_by") is not None else None,
            "group_by_columns": GroupByColumns.from_dict(obj.get("group_by_columns")) if obj.get("group_by_columns") is not None else None,
            "aggregation": Aggregation.from_dict(obj.get("aggregation")) if obj.get("aggregation") is not None else None,
            "series": Series.from_dict(obj.get("series")) if obj.get("series") is not None else None,
            "text_content": TextContent.from_dict(obj.get("text_content")) if obj.get("text_content") is not None else None,
            "filters": Filters1.from_dict(obj.get("filters")) if obj.get("filters") is not None else None,
            "operation": Operation.from_dict(obj.get("operation")) if obj.get("operation") is not None else None,
            "count_type": CountType1.from_dict(obj.get("count_type")) if obj.get("count_type") is not None else None,
            "condition": Condition.from_dict(obj.get("condition")) if obj.get("condition") is not None else None,
            "math_enabled": MathEnabled.from_dict(obj.get("math_enabled")) if obj.get("math_enabled") is not None else None,
            "math_operation": MathOperation.from_dict(obj.get("math_operation")) if obj.get("math_operation") is not None else None,
            "second_value_source": SecondValueSource.from_dict(obj.get("second_value_source")) if obj.get("second_value_source") is not None else None,
            "second_value_fixed": SecondValueFixed.from_dict(obj.get("second_value_fixed")) if obj.get("second_value_fixed") is not None else None,
            "second_value_column": SecondValueColumn.from_dict(obj.get("second_value_column")) if obj.get("second_value_column") is not None else None,
            "second_value_operation": SecondValueOperation.from_dict(obj.get("second_value_operation")) if obj.get("second_value_operation") is not None else None,
            "second_value_widget_id": SecondValueWidgetId.from_dict(obj.get("second_value_widget_id")) if obj.get("second_value_widget_id") is not None else None,
            "second_filters": SecondFilters.from_dict(obj.get("second_filters")) if obj.get("second_filters") is not None else None,
            "data_source": DataSource.from_dict(obj.get("data_source")) if obj.get("data_source") is not None else None,
            "date_grouping": DateGrouping.from_dict(obj.get("date_grouping")) if obj.get("date_grouping") is not None else None,
            "inherit_dashboard_period": InheritDashboardPeriod.from_dict(obj.get("inherit_dashboard_period")) if obj.get("inherit_dashboard_period") is not None else None,
            "compare_last_period": CompareLastPeriod.from_dict(obj.get("compare_last_period")) if obj.get("compare_last_period") is not None else None
        })
        return _obj


