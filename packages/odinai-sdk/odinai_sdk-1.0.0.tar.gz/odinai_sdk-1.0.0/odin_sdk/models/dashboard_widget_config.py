# coding: utf-8

"""
    API Docs

    API Documentation to interact with

    The version of the OpenAPI document: 0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from odin_sdk.models.chart_series import ChartSeries
from odin_sdk.models.date_grouping_config import DateGroupingConfig
from typing import Optional, Set
from typing_extensions import Self

class DashboardWidgetConfig(BaseModel):
    """
    DashboardWidgetConfig
    """ # noqa: E501
    column: Optional[StrictStr] = None
    chart_type: Optional[StrictStr] = None
    group_by: Optional[StrictStr] = None
    group_by_columns: Optional[List[StrictStr]] = None
    aggregation: Optional[StrictStr] = None
    series: Optional[List[ChartSeries]] = None
    text_content: Optional[StrictStr] = None
    filters: Optional[List[Dict[str, Any]]] = None
    operation: Optional[StrictStr] = None
    count_type: Optional[StrictStr] = None
    condition: Optional[Dict[str, Any]] = None
    math_enabled: Optional[StrictBool] = None
    math_operation: Optional[StrictStr] = None
    second_value_source: Optional[StrictStr] = None
    second_value_fixed: Optional[Union[StrictFloat, StrictInt]] = None
    second_value_column: Optional[StrictStr] = None
    second_value_operation: Optional[StrictStr] = None
    second_value_widget_id: Optional[StrictStr] = None
    second_filters: Optional[List[Dict[str, Any]]] = None
    data_source: Optional[StrictStr] = None
    date_grouping: Optional[Dict[str, DateGroupingConfig]] = None
    inherit_dashboard_period: Optional[StrictBool] = None
    compare_last_period: Optional[StrictBool] = None
    __properties: ClassVar[List[str]] = ["column", "chart_type", "group_by", "group_by_columns", "aggregation", "series", "text_content", "filters", "operation", "count_type", "condition", "math_enabled", "math_operation", "second_value_source", "second_value_fixed", "second_value_column", "second_value_operation", "second_value_widget_id", "second_filters", "data_source", "date_grouping", "inherit_dashboard_period", "compare_last_period"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DashboardWidgetConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in series (list)
        _items = []
        if self.series:
            for _item_series in self.series:
                if _item_series:
                    _items.append(_item_series.to_dict())
            _dict['series'] = _items
        # override the default output from pydantic by calling `to_dict()` of each value in date_grouping (dict)
        _field_dict = {}
        if self.date_grouping:
            for _key_date_grouping in self.date_grouping:
                if self.date_grouping[_key_date_grouping]:
                    _field_dict[_key_date_grouping] = self.date_grouping[_key_date_grouping].to_dict()
            _dict['date_grouping'] = _field_dict
        # set to None if column (nullable) is None
        # and model_fields_set contains the field
        if self.column is None and "column" in self.model_fields_set:
            _dict['column'] = None

        # set to None if chart_type (nullable) is None
        # and model_fields_set contains the field
        if self.chart_type is None and "chart_type" in self.model_fields_set:
            _dict['chart_type'] = None

        # set to None if group_by (nullable) is None
        # and model_fields_set contains the field
        if self.group_by is None and "group_by" in self.model_fields_set:
            _dict['group_by'] = None

        # set to None if group_by_columns (nullable) is None
        # and model_fields_set contains the field
        if self.group_by_columns is None and "group_by_columns" in self.model_fields_set:
            _dict['group_by_columns'] = None

        # set to None if aggregation (nullable) is None
        # and model_fields_set contains the field
        if self.aggregation is None and "aggregation" in self.model_fields_set:
            _dict['aggregation'] = None

        # set to None if series (nullable) is None
        # and model_fields_set contains the field
        if self.series is None and "series" in self.model_fields_set:
            _dict['series'] = None

        # set to None if text_content (nullable) is None
        # and model_fields_set contains the field
        if self.text_content is None and "text_content" in self.model_fields_set:
            _dict['text_content'] = None

        # set to None if filters (nullable) is None
        # and model_fields_set contains the field
        if self.filters is None and "filters" in self.model_fields_set:
            _dict['filters'] = None

        # set to None if operation (nullable) is None
        # and model_fields_set contains the field
        if self.operation is None and "operation" in self.model_fields_set:
            _dict['operation'] = None

        # set to None if count_type (nullable) is None
        # and model_fields_set contains the field
        if self.count_type is None and "count_type" in self.model_fields_set:
            _dict['count_type'] = None

        # set to None if condition (nullable) is None
        # and model_fields_set contains the field
        if self.condition is None and "condition" in self.model_fields_set:
            _dict['condition'] = None

        # set to None if math_enabled (nullable) is None
        # and model_fields_set contains the field
        if self.math_enabled is None and "math_enabled" in self.model_fields_set:
            _dict['math_enabled'] = None

        # set to None if math_operation (nullable) is None
        # and model_fields_set contains the field
        if self.math_operation is None and "math_operation" in self.model_fields_set:
            _dict['math_operation'] = None

        # set to None if second_value_source (nullable) is None
        # and model_fields_set contains the field
        if self.second_value_source is None and "second_value_source" in self.model_fields_set:
            _dict['second_value_source'] = None

        # set to None if second_value_fixed (nullable) is None
        # and model_fields_set contains the field
        if self.second_value_fixed is None and "second_value_fixed" in self.model_fields_set:
            _dict['second_value_fixed'] = None

        # set to None if second_value_column (nullable) is None
        # and model_fields_set contains the field
        if self.second_value_column is None and "second_value_column" in self.model_fields_set:
            _dict['second_value_column'] = None

        # set to None if second_value_operation (nullable) is None
        # and model_fields_set contains the field
        if self.second_value_operation is None and "second_value_operation" in self.model_fields_set:
            _dict['second_value_operation'] = None

        # set to None if second_value_widget_id (nullable) is None
        # and model_fields_set contains the field
        if self.second_value_widget_id is None and "second_value_widget_id" in self.model_fields_set:
            _dict['second_value_widget_id'] = None

        # set to None if second_filters (nullable) is None
        # and model_fields_set contains the field
        if self.second_filters is None and "second_filters" in self.model_fields_set:
            _dict['second_filters'] = None

        # set to None if data_source (nullable) is None
        # and model_fields_set contains the field
        if self.data_source is None and "data_source" in self.model_fields_set:
            _dict['data_source'] = None

        # set to None if date_grouping (nullable) is None
        # and model_fields_set contains the field
        if self.date_grouping is None and "date_grouping" in self.model_fields_set:
            _dict['date_grouping'] = None

        # set to None if inherit_dashboard_period (nullable) is None
        # and model_fields_set contains the field
        if self.inherit_dashboard_period is None and "inherit_dashboard_period" in self.model_fields_set:
            _dict['inherit_dashboard_period'] = None

        # set to None if compare_last_period (nullable) is None
        # and model_fields_set contains the field
        if self.compare_last_period is None and "compare_last_period" in self.model_fields_set:
            _dict['compare_last_period'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DashboardWidgetConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "column": obj.get("column"),
            "chart_type": obj.get("chart_type"),
            "group_by": obj.get("group_by"),
            "group_by_columns": obj.get("group_by_columns"),
            "aggregation": obj.get("aggregation"),
            "series": [ChartSeries.from_dict(_item) for _item in obj["series"]] if obj.get("series") is not None else None,
            "text_content": obj.get("text_content"),
            "filters": obj.get("filters"),
            "operation": obj.get("operation"),
            "count_type": obj.get("count_type"),
            "condition": obj.get("condition"),
            "math_enabled": obj.get("math_enabled"),
            "math_operation": obj.get("math_operation"),
            "second_value_source": obj.get("second_value_source"),
            "second_value_fixed": obj.get("second_value_fixed"),
            "second_value_column": obj.get("second_value_column"),
            "second_value_operation": obj.get("second_value_operation"),
            "second_value_widget_id": obj.get("second_value_widget_id"),
            "second_filters": obj.get("second_filters"),
            "data_source": obj.get("data_source"),
            "date_grouping": dict(
                (_k, DateGroupingConfig.from_dict(_v))
                for _k, _v in obj["date_grouping"].items()
            )
            if obj.get("date_grouping") is not None
            else None,
            "inherit_dashboard_period": obj.get("inherit_dashboard_period"),
            "compare_last_period": obj.get("compare_last_period")
        })
        return _obj


