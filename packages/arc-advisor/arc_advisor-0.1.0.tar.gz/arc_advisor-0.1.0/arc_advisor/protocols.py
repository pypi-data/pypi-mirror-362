"""A2A-compliant protocol implementation for Arc multi-agent learning.

This module implements the standard A2A protocol (v0.2.5) with Arc-specific extensions
for learning and advisory capabilities. It follows the A2A specification for
agent-to-agent communication using JSON-RPC 2.0 over HTTP(S).
"""

from typing import Any, Dict, List, Optional, Literal, Union
from pydantic import BaseModel, Field
from datetime import datetime
import uuid


# ===== CORE A2A PROTOCOL COMPONENTS =====
# Following official A2A specification v0.2.5

# JSON-RPC 2.0 Base Types
class JSONRPCMessage(BaseModel):
    """Base interface for any JSON-RPC 2.0 request or response."""
    jsonrpc: Literal["2.0"] = "2.0"
    id: Optional[Union[str, int]] = None


class JSONRPCRequest(JSONRPCMessage):
    """Represents a JSON-RPC 2.0 Request object."""
    method: str
    params: Optional[Dict[str, Any]] = None


class JSONRPCSuccessResponse(JSONRPCMessage):
    """Represents a JSON-RPC 2.0 Success Response object."""
    result: Any


class JSONRPCError(BaseModel):
    """Represents a JSON-RPC 2.0 Error object."""
    code: int
    message: str
    data: Optional[Any] = None


class JSONRPCErrorResponse(JSONRPCMessage):
    """Represents a JSON-RPC 2.0 Error Response object."""
    error: JSONRPCError


# ===== A2A MESSAGE PARTS =====
# Exactly as specified in A2A protocol

class TextPart(BaseModel):
    """Represents a text segment within parts."""
    kind: Literal["text"] = "text"
    text: str
    metadata: Optional[Dict[str, Any]] = None


class FileWithBytes(BaseModel):
    """File data with base64 encoded bytes."""
    name: Optional[str] = None
    mimeType: Optional[str] = None
    bytes: str  # Base64 encoded


class FileWithUri(BaseModel):
    """File data with URI reference."""
    name: Optional[str] = None
    mimeType: Optional[str] = None
    uri: str


class FilePart(BaseModel):
    """Represents a File segment within parts."""
    kind: Literal["file"] = "file"
    file: Union[FileWithBytes, FileWithUri]
    metadata: Optional[Dict[str, Any]] = None


class DataPart(BaseModel):
    """Represents a structured data segment within a message part."""
    kind: Literal["data"] = "data"
    data: Dict[str, Any]
    metadata: Optional[Dict[str, Any]] = None


Part = Union[TextPart, FilePart, DataPart]


# ===== A2A CORE OBJECTS =====

class Message(BaseModel):
    """Represents a single message exchanged between user and agent."""
    kind: Literal["message"] = "message"
    messageId: str = Field(default_factory=lambda: str(uuid.uuid4()))
    role: Literal["user", "agent"]
    parts: List[Part]
    taskId: Optional[str] = None
    contextId: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None
    extensions: Optional[List[str]] = None
    referenceTaskIds: Optional[List[str]] = None


class TaskState:
    """Possible lifecycle states of a Task."""
    SUBMITTED = "submitted"
    WORKING = "working"
    INPUT_REQUIRED = "input-required"
    COMPLETED = "completed"
    CANCELED = "canceled"
    FAILED = "failed"
    REJECTED = "rejected"
    AUTH_REQUIRED = "auth-required"
    UNKNOWN = "unknown"


class TaskStatus(BaseModel):
    """Current state and context of a Task."""
    state: str  # TaskState value
    message: Optional[Message] = None
    timestamp: Optional[str] = None  # ISO 8601


class Artifact(BaseModel):
    """Tangible output generated by the agent during a task."""
    artifactId: str
    name: Optional[str] = None
    description: Optional[str] = None
    parts: List[Part]
    metadata: Optional[Dict[str, Any]] = None
    extensions: Optional[List[str]] = None


class Task(BaseModel):
    """Stateful unit of work being processed by the A2A Server."""
    kind: Literal["task"] = "task"
    id: str
    contextId: str
    status: TaskStatus
    artifacts: Optional[List[Artifact]] = None
    history: Optional[List[Message]] = None
    metadata: Optional[Dict[str, Any]] = None


# ===== A2A AGENT DISCOVERY =====

class AgentProvider(BaseModel):
    """Information about the agent's provider."""
    organization: str
    url: str


class AgentExtension(BaseModel):
    """A declaration of an extension supported by an Agent."""
    uri: str
    required: Optional[bool] = False
    description: Optional[str] = None
    params: Optional[Dict[str, Any]] = None


class AgentCapabilities(BaseModel):
    """Optional A2A protocol features supported by the agent."""
    streaming: Optional[bool] = False
    pushNotifications: Optional[bool] = False
    stateTransitionHistory: Optional[bool] = False
    extensions: Optional[List[AgentExtension]] = None


class AgentSkill(BaseModel):
    """Specific capability the agent can perform."""
    id: str
    name: str
    description: str
    tags: List[str]
    examples: Optional[List[str]] = None
    inputModes: Optional[List[str]] = None
    outputModes: Optional[List[str]] = None


class SecurityScheme(BaseModel):
    """Base for security scheme definitions."""
    type: str
    description: Optional[str] = None


class AgentInterface(BaseModel):
    """Declaration of target url and supported transport."""
    url: str
    transport: str  # JSONRPC, GRPC, HTTP+JSON


class AgentCard(BaseModel):
    """Agent metadata for discovery and interaction."""
    protocolVersion: str = "0.2.5"
    name: str
    description: str
    url: str
    version: str
    skills: List[AgentSkill]
    defaultInputModes: List[str]
    defaultOutputModes: List[str]
    capabilities: AgentCapabilities
    
    # Optional fields
    preferredTransport: Optional[str] = "JSONRPC"
    additionalInterfaces: Optional[List[AgentInterface]] = None
    provider: Optional[AgentProvider] = None
    iconUrl: Optional[str] = None
    documentationUrl: Optional[str] = None
    securitySchemes: Optional[Dict[str, SecurityScheme]] = None
    security: Optional[List[Dict[str, List[str]]]] = None
    supportsAuthenticatedExtendedCard: Optional[bool] = False


# ===== A2A METHOD PARAMETERS =====

class MessageSendConfiguration(BaseModel):
    """Configuration for message send requests."""
    acceptedOutputModes: List[str]
    blocking: Optional[bool] = None
    historyLength: Optional[int] = None
    pushNotificationConfig: Optional[Dict[str, Any]] = None  # PushNotificationConfig


class MessageSendParams(BaseModel):
    """Parameters for message/send method."""
    message: Message
    configuration: Optional[MessageSendConfiguration] = None
    metadata: Optional[Dict[str, Any]] = None


class TaskQueryParams(BaseModel):
    """Parameters for tasks/get method."""
    id: str
    historyLength: Optional[int] = None
    metadata: Optional[Dict[str, Any]] = None


class TaskIdParams(BaseModel):
    """Parameters for simple task operations."""
    id: str
    metadata: Optional[Dict[str, Any]] = None


# ===== A2A ERROR CODES =====

class A2AErrorCodes:
    """Standard and A2A-specific error codes."""
    # Standard JSON-RPC errors
    PARSE_ERROR = -32700
    INVALID_REQUEST = -32600
    METHOD_NOT_FOUND = -32601
    INVALID_PARAMS = -32602
    INTERNAL_ERROR = -32603
    
    # A2A-specific errors
    TASK_NOT_FOUND = -32001
    TASK_NOT_CANCELABLE = -32002
    PUSH_NOTIFICATION_NOT_SUPPORTED = -32003
    UNSUPPORTED_OPERATION = -32004
    CONTENT_TYPE_NOT_SUPPORTED = -32005
    INVALID_AGENT_RESPONSE = -32006


# ===== ARC EXTENSIONS TO A2A =====
# These are Arc-specific extensions that extend the A2A protocol

class ArcExtension(AgentExtension):
    """Arc-specific extension declaration."""
    uri: str = "https://arc.computer/extensions/learning/v1"
    description: str = "Arc learning infrastructure for agent improvement"
    required: bool = False
    params: Dict[str, Any] = Field(default_factory=lambda: {
        "version": "0.1.0",
        "capabilities": ["advice", "learning", "semantic_search", "multi_agent"]
    })


# Arc-enhanced Agent Card
class ArcAgentCard(AgentCard):
    """Extended AgentCard for Arc-enabled agents."""
    # Additional Arc-specific fields
    arcEnabled: bool = True
    arcAdvisorEndpoint: Optional[str] = None
    arcProtocolVersion: str = "0.1.0"
    
    def __init__(self, **data):
        # Ensure Arc extension is included
        if "capabilities" in data and "extensions" in data["capabilities"]:
            arc_ext = ArcExtension()
            # Handle both dict and object extensions
            extensions = data["capabilities"]["extensions"]
            arc_uri = arc_ext.uri
            has_arc = False
            
            for ext in extensions:
                # Check if ext is a dict or an object
                ext_uri = ext.get("uri") if isinstance(ext, dict) else getattr(ext, "uri", None)
                if ext_uri == arc_uri:
                    has_arc = True
                    break
            
            if not has_arc:
                data["capabilities"]["extensions"].append(arc_ext)
        super().__init__(**data)


# ===== ARC-SPECIFIC MESSAGES (A2A-compliant) =====

class ArcAdviceMessage(Message):
    """Request advice from Arc advisor (sent as A2A message)."""
    def __init__(self, agent_id: str, task_description: str, 
                 context: Dict[str, Any], **kwargs):
        parts = [
            DataPart(
                data={
                    "type": "ArcAdviceRequest",
                    "agent_id": agent_id,
                    "task_description": task_description,
                    "context": context,
                    "timestamp": datetime.utcnow().isoformat() + "Z"
                },
                metadata={"arc:request_type": "advice"}
            )
        ]
        super().__init__(
            role="user",
            parts=parts,
            extensions=["https://arc.computer/extensions/learning/v1"],
            **kwargs
        )


class ArcLearningReportMessage(Message):
    """Report task outcome to Arc (sent as A2A message)."""
    def __init__(self, agent_id: str, trace_id: str, 
                 outcome: Dict[str, Any], **kwargs):
        parts = [
            DataPart(
                data={
                    "type": "ArcLearningReport",
                    "agent_id": agent_id,
                    "trace_id": trace_id,
                    "timestamp": datetime.utcnow().isoformat() + "Z",
                    "outcome": outcome
                },
                metadata={"arc:report_type": "learning"}
            )
        ]
        super().__init__(
            role="agent",
            parts=parts,
            extensions=["https://arc.computer/extensions/learning/v1"],
            **kwargs
        )


class ArcImprovementRequestMessage(Message):
    """Request improvement based on failure (sent as A2A message)."""
    def __init__(self, agent_id: str, trace_id: str,
                 failure_category: str, failure_context: Dict[str, Any], **kwargs):
        parts = [
            DataPart(
                data={
                    "type": "ArcImprovementRequest",
                    "agent_id": agent_id,
                    "trace_id": trace_id,
                    "timestamp": datetime.utcnow().isoformat() + "Z",
                    "failure_category": failure_category,
                    "failure_context": failure_context
                },
                metadata={"arc:request_type": "improvement"}
            )
        ]
        super().__init__(
            role="agent",
            parts=parts,
            extensions=["https://arc.computer/extensions/learning/v1"],
            **kwargs
        )


# ===== ARC TASK EXTENSIONS =====

class ArcTask(Task):
    """Extended Task with Arc learning metadata."""
    def __init__(self, **data):
        # Add Arc extension to metadata
        if "metadata" not in data:
            data["metadata"] = {}
        data["metadata"]["arc:enabled"] = True
        data["metadata"]["arc:learning_trace_id"] = str(uuid.uuid4())
        super().__init__(**data)


# ===== ARC-SPECIFIC ARTIFACTS =====

class ArcAdviceArtifact(Artifact):
    """Artifact containing Arc advisor response."""
    def __init__(self, strategy: str, confidence: float, 
                 patterns: List[Dict[str, Any]], **kwargs):
        parts = [
            DataPart(
                data={
                    "type": "ArcAdvice",
                    "strategy": strategy,
                    "confidence_score": confidence,
                    "relevant_patterns": patterns,
                    "timestamp": datetime.utcnow().isoformat() + "Z"
                },
                metadata={"arc:artifact_type": "advice"}
            )
        ]
        super().__init__(
            artifactId=str(uuid.uuid4()),
            name="Arc Strategic Advice",
            description="AI-generated strategic guidance based on learned patterns",
            parts=parts,
            extensions=["https://arc.computer/extensions/learning/v1"],
            **kwargs
        )


# ===== STREAMING EVENTS (A2A-compliant) =====

class TaskStatusUpdateEvent(BaseModel):
    """Status update event for streaming."""
    kind: Literal["status-update"] = "status-update"
    taskId: str
    contextId: str
    status: TaskStatus
    final: Optional[bool] = False
    metadata: Optional[Dict[str, Any]] = None


class TaskArtifactUpdateEvent(BaseModel):
    """Artifact update event for streaming."""
    kind: Literal["artifact-update"] = "artifact-update"
    taskId: str
    contextId: str
    artifact: Artifact
    append: Optional[bool] = False
    lastChunk: Optional[bool] = False
    metadata: Optional[Dict[str, Any]] = None


# ===== HELPER FUNCTIONS =====

def create_arc_error_response(
    request_id: Optional[Union[str, int]], 
    code: int, 
    message: str,
    data: Optional[Any] = None
) -> JSONRPCErrorResponse:
    """Create an A2A-compliant error response."""
    return JSONRPCErrorResponse(
        id=request_id,
        error=JSONRPCError(
            code=code,
            message=message,
            data=data
        )
    )


def is_arc_message(message: Message) -> bool:
    """Check if a message contains Arc learning extensions."""
    return (
        message.extensions is not None and
        "https://arc.computer/extensions/learning/v1" in message.extensions
    )