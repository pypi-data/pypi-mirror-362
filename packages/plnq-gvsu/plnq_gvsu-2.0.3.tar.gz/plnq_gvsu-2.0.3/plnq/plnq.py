###############################################################################
#
# plnq --- PrairieLearn Notebook Quiz
#
# plnq generates a complete auto-graded, notebook-based PrairieLearn question
# using only configuration information contained in a single .ipynb file.
#
# (c) 2023-2025 Anna Carvalho and Zachary Kurmas
#
###############################################################################

import argparse
import json 
from pathlib import Path
import os
import io
import uuid
import re
import sys
import shutil
import copy
import nbformat
import types
import math
import importlib.resources
import textwrap

from .answer.answer import Answer

PLNQ_VERSION = "2.0.3"

PLNQ_PASS_THROUGH = 'PLNQ.PassThrough'
PLNQ_PASS_THROUGH_MARKER = f'!!!{PLNQ_PASS_THROUGH}!!!'

PLNQ_IGNORE = 'PLNQ.Ignore'
PLNQ_IGNORE_MARKER = f"!!!{PLNQ_IGNORE}!!!"

# Here is an idea:When you refer to the template files,
# Assume the template directory is in the same directory
# as this file. That way the setup can be run from anywhere.

# https://docs.python.org/3/library/argparse.html

def is_directory_protected(directory):
    protected_file_path = os.path.join(directory, "do_not_overwrite")
    return os.path.exists(protected_file_path)

# Removes an existing target directory so it can be replaced
# by new content. However, to prevent catastrophe if the target
# directory is mis-typed (e.g., if the parent directory is listed
# instead of the desired target), we verify that the target directory
# contains a file named .plnq

def destroy_existing_target(directory):
    path = Path(directory)
    if not (path / '.plnq').is_file():
      print(f'Cannot destroy/overwrite {directory}')
      print(f"It does not contain a file named .plnq, and, therefore might not be a file you want to overwrite.")
      print(f'If this is the correct target directory, remove it "by hand" and run plnq again.')
      exit(1)

    observed_contents = sorted([i.name for i in list(path.iterdir())])
    expected_contents = ['.plnq', 'info.json', 'question.html', 'server.py', 'tests', 'workspace']
    extras = [item for item in observed_contents if item not in expected_contents ]

    # If there is exactly one extra file, and it is an ipynb file, assume it is a copy of the source
    # notebook and remove it from the extras list (thereby allowing the directory to be destroyed).
    if len(extras) == 1:
        _, ext = os.path.splitext(extras[0])
        if ext == '.ipynb':
            extras = []

    if len(extras) > 0:
        # TODO: Ask "Are you sure" instead of simply quitting.
        print(f'Cannot destroy/overwrite {directory}')
        print(f'It contains files that may not have been generated by plnq: {extras}')
        print(f'If this is the correct target directory, remove it "by hand" and run plnq again.')
        exit(1)
    shutil.rmtree(directory)

def open_template(*parts):
    # The ability to pass multiple parts to joinpath was not added until
    # Python 3.11. Also, this line fails for Python 3.8 or lower because
    # importlib.resources does not have an attribute 'files'
    path = importlib.resources.files('plnq.quiz_template').joinpath(parts[0])
    for part in parts[1:]:
        path = path.joinpath(part)
    return open(path, 'r')

def copy_template(destination, *parts):
    # The ability to pass multiple parts to joinpath was not added until
    # Python 3.11. Also, this line fails for Python 3.8 or lower because
    # importlib.resources does not have an attribute 'files'
    path = importlib.resources.files('plnq.quiz_template').joinpath(parts[0])
    for part in parts[1:]:
        path = path.joinpath(part)

    shutil.copy(path, destination)

def copy_template_dir(destination, source):
    path = importlib.resources.files('plnq.quiz_template').joinpath(source)
    shutil.copytree(path, destination, dirs_exist_ok=True)

##############################################################################
#
# determine_absolute_output_dir
#
# Determine the absolute path of the output dir. This includes
# * Defaulting to the cwd
# * Expanding '-' to be the basename of the input file.
#
##############################################################################
def determine_absolute_output_dir(dir_in, description_filename):
    if not description_filename.endswith('.ipynb'):
        raise ValueError(
            "Parameter description_filename to determine_absolute_output must end with .ipynb")

    if dir_in.endswith('/-'):
        if '/' in description_filename:
            # TODO: This should probably be replaced with a path library
            # so that it works on windows (with it's \ instead of /)
            parts = re.findall(r"\/([^\/]+).ipynb$", description_filename)
            # TODO: Make sure there is a match
            basename = parts[0]
        else:
            parts = re.findall(r"^(.+).ipynb$", description_filename)
            # TODO: Make sure there is a match
            basename = parts[0]
        return re.sub(r"\/-$", f'/{basename}', dir_in)
    else:
        return dir_in

##############################################################################
#
# strip_plnq_passthrough_comments
#
# IMPORTANT! This function simply looks for # to begin a comment.
# It will not work correctly on strings that contain a # used for 
# purposes other than the beginning of a comment.
#
# Remove any comments that contain string_to_match
#
##############################################################################
def strip_plnq_passthrough_comments(code: str, string_to_match: str) -> str:
    cleaned_lines = []
    for line in code.splitlines():
        if "#" in line:
            code_part, comment_part = line.split("#", 1)
            if string_to_match in comment_part:
                cleaned_lines.append(code_part.rstrip())
                continue
        cleaned_lines.append(line)
    return "\n".join(cleaned_lines)


##############################################################################
#
# PLNQData
#
# Encapsulates the data needed to build the Notebook
##############################################################################

class PLNQData:

    def __init__(self):
        self.exported_functions = {}

    def add_function(self, name, desc, displayed_examples, test_cases, cast=None):
        # print(f'Adding {name}')
        function_data = types.SimpleNamespace(description=desc, displayed_examples=displayed_examples, test_cases=test_cases, cast=cast)
        self.exported_functions[name] = function_data


##############################################################################
#
# main
#
##############################################################################

def main():

    found_test_error = False

    #
    # Startup / argument parsing
    #
    print(f"plnq v{PLNQ_VERSION}")

    parser = argparse.ArgumentParser(prog='plnq',
                                     description='Generates PrairieLearn questions')
    parser.add_argument('-v', '--verbose', action='store_true')
    parser.add_argument('--destroy', action='store_true',
                        help='overwrite the contents of the output directory (if present)')
    parser.add_argument('--uuid', type=str, help='specify uuid for question')
    parser.add_argument('--show-notebook-output', action='store_true',
                        help='show the output generated by code blocks')
    parser.add_argument('--share', action='store_true',
                        help='include "sharePublicly" and "shareSourcePublicly" in info.json')
    parser.add_argument('--include-source', action='store_true', 
                        help='include a copy of the source notebook in the output directory')
    parser.add_argument('description', metavar='filename', type=str, nargs=1,
                        help='the problem description file')
    parser.add_argument('output_dir', metavar='dir_name', type=str, nargs='?',
                        help='the output directory', default='./-')

    args = parser.parse_args()

    description_loc = args.description[0]
    output_dir_name = args.output_dir

    if (not os.path.exists(description_loc)):
        print(f"Input '{description_loc}' doesn't exist.", file=sys.stderr, flush=True)
        exit(1)

    location_is_dir = os.path.isdir(description_loc)
    if location_is_dir:
        files = [f for f in os.listdir(
            description_loc) if f.endswith('.ipynb')]
        if len(files) == 1:
            description_file_name = f'{description_loc}/{files[0]}'
        else:
            print("Location directories may only contain one .ipynb file.")
            print("(Otherwise, I don't know which file is the template file.")
            exit(1)
    else:
        description_file_name = description_loc

    # description_folder = os.path.dirname(description_file_name)

    output_dir_name = determine_absolute_output_dir(
        output_dir_name, description_file_name)

    # Note: The --destroy flag should *not* override a do_not_overwrite file.
    if is_directory_protected(output_dir_name):
        print("Cannot write to output directory because it contains a 'do_not_overwrite' file.")
        sys.exit(1)

    # TODO Make sure file exists, is a file, and is readable, or complain and quit.
    if args.verbose:
        print(f"Using template: {description_file_name}")
        print(f"Placing output in {output_dir_name}")

    other_graded_files = []
    if location_is_dir:
        description_base_name = os.path.basename(description_file_name)
        other_graded_files = [f for f in os.listdir(
            description_loc) if f != description_base_name and not f.startswith('plnq_ignore_')]

    #
    # Load description and execute code blocks
    #

    nb = nbformat.read(description_file_name, as_version=4)
    nbformat.validate(nb)

    # Blocks run in their own namespace. We need to specifically inject
    # objects into that namespace, if desired.
    plnq_d = PLNQData()
    # I forget why I needed this: "plnq_description_folder": description_folder,
    description = {'plnq_d': plnq_d, "config": {}}
    
    stdout_buffer = io.StringIO()
    original_stdout = sys.stdout
    sys.stdout = stdout_buffer
    for cell in nb.cells:
        if not cell.cell_type == 'code':
            continue
        code = cell.source.strip()
        if not code:
            continue

        # Do not execute code blocks marked PassThrough
        if PLNQ_PASS_THROUGH_MARKER in cell.source:
            continue

        try:
            exec(code, description)
        except Exception as e:
            sys.stdout = original_stdout
            print(f"Error occurred while executing the following code: {e}\n")
            print(code)
            print('---------------------')
            buffer_contents = stdout_buffer.getvalue()
            if len(buffer_contents) > 0:
                print("\nOutput from Notebook:")
                print(buffer_contents)
            
            sys.stdout.flush()
            sys.stderr.flush()
            # TODO: Should we just exit() here instead of re-raising?
            raise  # re-raises the original exception so traceback is preserved

    # TODO: Test Me
    sys.stdout = original_stdout
    buffer_contents = stdout_buffer.getvalue()
    if len(buffer_contents) > 0 and args.show_notebook_output:
        print("\nOutput from Notebook:")
        print(buffer_contents)
        print()
    elif len(buffer_contents) > 0:
        print("Notebook code blocks generated output. Use --show-notebook-output flag to display.") 

    # TODO: I don't think we're using these anymore.
    # default_config = {"ignore": [], "pass_through": [], "execute": []}
    config = description['config']

    if (args.verbose):
        print("Config:")
        print(config)
    

    ##########################################################
    #
    # Create output
    #
    ############################################################

    #
    # Create directory
    #

    # TODO Make sure output can be created
    if args.destroy and (Path(output_dir_name)).exists():
        destroy_existing_target(output_dir_name)
    elif (Path(output_dir_name)).exists():

        print(f"Output path {output_dir_name} exists. Do you want to", file=sys.stderr)
        print("  (Q) quit", file=sys.stderr)
        print("  (D) destroy the current directory and replace it with the newly generated question", file=sys.stderr)
        print("  (M) move the current directory to a backup location", file=sys.stderr, flush=True)

        choice = input().upper()
        if choice.startswith('Q'):
            print('Good bye', file=sys.stderr, flush=True)
            exit(2)
        elif choice.startswith('D'):
            destroy_existing_target(output_dir_name)
        elif choice.startswith('M'):
            print("Not implemented yet.", file=sys.stderr, flush=True)
            exit(1)
        else:
            print(f"Don't recognize option '{choice}'", file=sys.stderr, flush=True)
            exit(1)

    Path(output_dir_name).mkdir(parents=False, exist_ok=False)

    # Create a file named .plnq. When plnq sees this file 
    # (without "do_not_overwrite") it assumes that this directory can 
    # be destroyed (e.g., when re-running plnq after updates)
    with open(f'{output_dir_name}/.plnq', "a", encoding="utf-8") as f:
        f.write(f"Version: {PLNQ_VERSION}\n")
        
        f.write(textwrap.dedent("""
        # This file marks the current directory as having been generated by plnq.
        # plnq will not automatically overwrite or remove a directory unless that
        # directory contains a file named ".plnq" (so as to reduce the chances of a 
        # user accidentally overwriting a directory not generated by plnq).
        """))


    #
    # info.json
    #
    info_json_file = open_template("info.json")
    info_json = json.load(info_json_file)
    info_json["uuid"] = str(uuid.uuid4()) if args.uuid == None else args.uuid

    # TODO complain if expected info is missing.
    info_json['title'] = plnq_d.info["title"]
    info_json["topic"] = plnq_d.info["topic"]
    info_json["tags"] =  plnq_d.info["tags"]

    # TODO:Test me
    if args.share:
        info_json['sharePublicly'] = True
        info_json['shareSourcePublicly'] = True

    for file in other_graded_files:
        info_json['workspaceOptions']['gradedFiles'].append(file)
    
    # This is not important for the overall operation of plnq, 
    # it just ensures that the resulting info.json file is identical 
    # on both Windows and Mac for purposes of regression testing.
    info_json['workspaceOptions']['gradedFiles'].sort()

    output_json_file = open(f"{output_dir_name}/info.json", "w")
    json.dump(info_json, output_json_file, indent=2)
    output_json_file.close()

    # TODO: Test Me
    if args.include_source:
        # Copy the source notebook to the output directory
        source_notebook = Path(description_file_name).name
        shutil.copy(description_file_name, f"{output_dir_name}/{source_notebook}")

    #
    # question.html
    #

    question_file = open_template("question.html")
    question_file_contents = question_file.read()
    new_question_file_contents = question_file_contents.replace(
        'zzDESCRIPTIONzz', plnq_d.info["title"])

    output_question_file = open(f"{output_dir_name}/question.html", "w")
    output_question_file.write(new_question_file_contents)
    output_question_file.close()

    #
    # server.py
    #

    server_file = open_template(f"server.py")
    server_file_contents = server_file.read()

    functions = [
        {"name": name, "description": data.description, "type": "function"}
        for name, data in plnq_d.exported_functions.items()
    ]

    functions_json = json.dumps(functions, indent=2)
    update = server_file_contents.replace('\'zzFUNC_INFOzz\'', functions_json)

    output_server_file = open(f"{output_dir_name}/server.py", "w")
    output_server_file.write(update)
    output_question_file.close()

    #
    # workspace
    #

    workspace_pathname = f'{output_dir_name}/workspace'
    Path(workspace_pathname).mkdir(parents=False, exist_ok=False)
    copy_template(f'{output_dir_name}/workspace', 'workspace', 'playspace.ipynb', )

    # If template location is a directory, copy any additional files into the workspace
    for file in other_graded_files:
        shutil.copy(os.path.join(description_loc, file), workspace_pathname)

    lt_file = open_template(f"workspace", "learning_target.ipynb")
    learning_target = json.load(lt_file)

    #
    # Process Markdown blocks (and passed-through code blocks)
    #
    for cell_index, cell in enumerate(nb.cells):

        block_content = cell.source.strip()
        if not block_content:
            continue

        #
        # Ignore marked blocks
        #
        if PLNQ_IGNORE_MARKER in block_content:
            if (args.verbose):
                print(f'Ignoring cell {cell_index}')
            continue  

        re_match = re.search(PLNQ_IGNORE, block_content, re.IGNORECASE)
        if re_match:
            found_string = re_match.group(0)
            print(f"WARNING: Found '{found_string}', which is a close, but inexact match for '{PLNQ_IGNORE_MARKER}' in cell {cell_index}.")
            print(f"         Make corrections if you want this cell ignored.")

        #
        # Pass through marked blocks without processing
        # (Other than to remove the passthrough marker)
        #
        if PLNQ_PASS_THROUGH_MARKER in block_content:
            if (args.verbose):
                print(f'Passing cell {cell_index} through without processing.', file=sys.stdout, flush=True)

            if cell.cell_type == 'markdown':    
                cell.source = cell.source.replace(PLNQ_PASS_THROUGH_MARKER, '')
            else:
                cell.source = strip_plnq_passthrough_comments(cell.source, PLNQ_PASS_THROUGH_MARKER)
            learning_target['cells'].extend([cell])
            continue    

        re_match = re.search(PLNQ_PASS_THROUGH, block_content, re.IGNORECASE)
        if re_match:
            found_string = re_match.group(0)
            print(f"WARNING: Found '{found_string}', which is a close, but inexact match for '{PLNQ_PASS_THROUGH_MARKER}' in cell {cell_index}.")
            print(f"         Make corrections if you want this cell passed through without processing.")

        #
        # At this point code blocks should either have been passed through, or they are data blocks
        # that shouldn't be included in the output. In other words, don't do any further processing
        # on blocks that aren't markdown blocks. 
        #
        if not cell.cell_type == 'markdown':
            continue

        #
        # If the block isn't marked as pass-through or ignore, then it should contain a marked-up
        # method signature.
        #
        functions = re.findall(r"!!!`([^`]+)`!!!", block_content)    
        if len(functions) > 1:
            print("ERROR: Found more than one marked method signature:", functions)
        elif len(functions) == 0:
            print(
                f"WARNING: Did not find a method signature in cell {cell_index}. Using a generic 'your_function'")
            functions = ["your_function()"]

        function_signature = functions[0]

        block_content = block_content.replace(f'!!!`{function_signature}`!!!',f'`{function_signature}`')

        possible_names = re.findall(r"^([^(]+)\(", function_signature)
        if (len(possible_names) != 1):
            print(
                f"ERROR: Expected exactly 1 name in {function_signature}.  Found {possible_names}")
            print("(Make sure you have a complete signature, not just a name.)")
        function_name = possible_names[0]

        displayed_examples = plnq_d.exported_functions[function_name].displayed_examples

        if len(displayed_examples) > 0:
            block_content += "\n\nFor example:\n"
            for example in displayed_examples:
                num_params = len(example) - 1
                params = json.dumps(example[:num_params])[1:-1]
                params = params.replace("true,", "True,")
                params = params.replace("false,", "False,")
                answer = Answer.make(example[num_params])
                block_content += f"  * `{function_name}({params})` should {answer.display_expected_string()}\n"

        text_cell = {
            "cell_type": "markdown",
            "metadata": {"collapsed": False},
            "source": block_content
        }

        source_text = ["#grade IMPORTANT: Do not remove or modify this line\n"]
        source_text += [f'def {function_signature}:\n']
        source_text += ['    pass']

        code_cell = {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {"collapsed": False},
            "outputs": [],
            "source": source_text
        }

        learning_target['cells'].extend([text_cell, code_cell])

    output_lt_file = open(
        f"{output_dir_name}/workspace/learning_target.ipynb", "w")
    json.dump(learning_target, output_lt_file, indent=2)
    output_lt_file.close()

    #
    # tests
    #

    Path(f"{output_dir_name}/tests").mkdir(parents=False, exist_ok=False)
    copy_template_dir(f'{output_dir_name}/tests', 'tests')
    # tests should contain the answer module. But, Windows doesn't support symlinks,
    # so we need to copy it separately. 
    path = importlib.resources.files('plnq.answer')
    shutil.copytree(path, f'{output_dir_name}/tests/answer', dirs_exist_ok=True)

    test_code_template_file = open_template(f"tests", "test.py")
    test_code = test_code_template_file.read()
    # Blank line in case the we loose the newline at the end of the template test.py
    test_code += '\n'
    # test_code += f"\n  student_code_file = 'learning_target.ipynb'\n\n"

    i = 0
    for func_name, function_desc in plnq_d.exported_functions.items():
        all_tests = function_desc.displayed_examples + function_desc.test_cases

        # The default has to be None rather than lambda x: x, because the cast
        # has to be serializable (i.e., writable to test.py)
        cast = function_desc.cast.__name__ if function_desc.cast else None

        for test in (all_tests):
            num_params = len(test) - 1
            expected = test[num_params]

            if isinstance(expected, Answer):
                expected_str = Answer.make(expected).constructor_string()
                param_index = expected.param_index
            else:
                expected_str = Answer.value_to_literal(expected)
                param_index = -1
            params = json.dumps(test[:num_params])

            test_code += f'  @points(1)\n'
            test_code += f'  @name("test {i + 1}: {func_name}")\n'
            # Using a leading 0 ensures they run in numeric order
            test_code += f'  def test_{(i + 1):02d}(self):\n'
            test_code += f"      self.verify('{func_name}', {expected_str}, {repr(params)}, {param_index}, {cast})\n"
            test_code += '\n'

            i += 1

    output_test_file = open(f"{output_dir_name}/tests/test.py", "w")
    output_test_file.write(test_code)

    #
    # Verify correctness of test cases
    #
    # Make sure the reference solution produces the same answer as the test cases!

    for func_name, function_desc in plnq_d.exported_functions.items():
        # print(f"------- {func_name} -------")
        if func_name not in description:
            print(f"WARNING: No reference solution for {func_name}")
            continue
        reference_function = description[func_name]

        # clone the parameters so that one test can't affect another
        orig_tests = function_desc.displayed_examples + function_desc.test_cases
        all_tests = [copy.deepcopy(item) for item in orig_tests]

        # Modify cwd to dir containing data files
        original_cwd = os.getcwd()
        description_dir = os.path.dirname(description_file_name)
        if len(description_dir) > 0:
            os.chdir(description_dir)

        for index, test in enumerate(all_tests):
            num_params = len(test) - 1
            given_answer = test[num_params]
            verifier = Answer.make(given_answer)

            cast = function_desc.cast if function_desc.cast else lambda x :x
            return_value = cast(reference_function(*test[:num_params]))

            if verifier.param_index == -1:
                computed_answer = return_value
                secondary_verifier = None
            else:
                computed_answer = test[verifier.param_index]
                secondary_verifier = Answer.make(verifier.expected_return_value)

            # print(f"{test[:num_params]} --- {computed_answer}")
            if (not verifier.verify(computed_answer)):
                found_test_error = True
                if (num_params == 1):
                    print(f"!!! Test {index} {func_name}({test[0]}): {verifier.message()}")
                else:
                    print(f"!!! Test {index} ({func_name})({test[0]}, ...): {verifier.message()}")
                if args.verbose:
                    print(f"    {test}")

            # When using InlineAnswer, also check the actual return value.
            if secondary_verifier and not secondary_verifier.verify(return_value):
                found_test_error = True
                if (num_params == 1):
                    print(f"!!! Test {index} {func_name}({test[0]}) return value: {secondary_verifier.message()}")
                else:
                    print(f"!!! Test {index} ({func_name})({test[0]}, ...) return value: {secondary_verifier.message()}")
                if args.verbose:
                    print(f"    {test}")


        # Restore original cwd
        os.chdir(original_cwd)

    if found_test_error:
        sys.stdout.flush()
        print("Found inconsistent test cases.", file=sys.stderr, flush=True)
        exit(3)
    else:
        exit(0)


if __name__ == '__main__':
    main()
