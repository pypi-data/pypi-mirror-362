# SPDX-FileCopyrightText: 2025-present deepset GmbH <info@deepset.ai>
#
# SPDX-License-Identifier: Apache-2.0

"""
Tokonomics: Explorable and Referenceable Tools.

===============================================

A library that equips LLM‑agents with:

* TTL‑based object storage
* Rich object exploration & reference passing
* Smart decorators for explorable outputs and referenceable inputs
* Strict typing / signature preservation (incl. *async* callables)
* ReST‑style docstring enhancement
* Configurable preview truncation (`max_bytes`) and a user‑supplied
  `preview_callback` for custom renderings (e.g. pandas.DataFrame)
"""

from __future__ import annotations

import re
import time
from typing import (
    Any,
    Generic,
    TypeVar,
)

# =============================================================================
# 1 · Generic return‑value wrapper
# =============================================================================

_T = TypeVar("_T")


class Explorable(Generic[_T]):
    """
    Wrapper returned by ``@explorable`` decorated tools.

    Attributes
    ----------
    obj_id :
        The internal identifier of the stored object.
    value :
        The original, *unmodified* object returned by the wrapped tool.
    preview :
        Rich‑rendered string generated by the explorer.
    """

    __slots__ = ("obj_id", "value", "_preview")

    def __init__(self, obj_id: str, value: _T, preview: str) -> None:
        """Initialize Explorable wrapper with object ID, value, and preview."""
        self.obj_id = obj_id
        self.value: _T = value
        self._preview = preview

    # ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    # Representations
    # ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    def __str__(self) -> str:
        """Return the preview string representation."""
        return self._preview

    __repr__ = __str__

    # ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    # Convenience for notebooks / REPLs
    # ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    _ipython_display_ = __str__  # Jupyter friendly


# =============================================================================
# 2 · Time‑to‑live based object store
# =============================================================================


class ObjectStore:
    """
    Very small in‑memory store with TTL‑based eviction.

    Parameters
    ----------
    ttl :
        Default time‑to‑live in **seconds** for every stored entry.  The TTL is
        evaluated lazily on every ``get`` / ``put``.  A value of ``0`` disables
        expiry (mainly for tests).
    """

    def __init__(self, ttl: float = 3_600.0) -> None:
        """Initialize ObjectStore with TTL in seconds."""
        self._ttl: float = float(ttl)
        self._objects: dict[str, tuple[Any, float]] = {}
        self._counter: int = 0

    # ––––––––––––––––––––––––––––––––––––––––––––––––––––––
    # Internal helpers
    # ––––––––––––––––––––––––––––––––––––––––––––––––––––––

    def _now(self) -> float:
        return time.time()

    def _evict_expired(self) -> None:
        if self._ttl == 0:
            return
        expiry_threshold = self._now() - self._ttl
        expired = [k for k, (_, ts) in self._objects.items() if ts < expiry_threshold]
        for k in expired:
            del self._objects[k]

    # ––––––––––––––––––––––––––––––––––––––––––––––––––––––
    # Public API
    # ––––––––––––––––––––––––––––––––––––––––––––––––––––––

    def put(self, obj: Any) -> str:
        """Store *obj* and return its new reference id (``obj_001`` …)."""
        self._evict_expired()
        self._counter += 1
        obj_id = f"obj_{self._counter:03d}"
        self._objects[obj_id] = (obj, self._now())
        return obj_id

    def get(self, obj_id: str) -> Any | None:
        """Retrieve *obj* by id.

        Returns ``None`` if the object does not exist or has expired.
        """
        self._evict_expired()
        entry = self._objects.get(obj_id)
        return None if entry is None else entry[0]

    def delete(self, obj_id: str) -> bool:
        """Remove object from the store.

        Returns ``True`` if the object was present.
        """
        self._evict_expired()
        return self._objects.pop(obj_id, None) is not None


# =============================================================================
# 3 · Object references
# =============================================================================


class ObjectRef:
    """Lightweight parser for reference strings of the form.

    Examples::

        @obj_042.settings.theme
        @obj_123["settings"]["theme"]
    """

    _PATTERN = re.compile(r"^@(\w+)(.*)$")

    def __init__(self, obj_id: str, path: str = "") -> None:
        """Initialize ObjectRef with object ID and optional path."""
        self.obj_id = obj_id
        self.path = path

    # --------------------------------------------------------------------- #
    # Factory
    # --------------------------------------------------------------------- #

    @classmethod
    def parse(cls, ref: str | Any) -> ObjectRef | None:
        """Parse a reference string into an ObjectRef instance."""
        if not isinstance(ref, str):
            return None
        m = cls._PATTERN.match(ref)
        if m is None:
            return None
        obj_id, path = m.group(1), m.group(2) or ""
        if path.startswith("."):
            path = path[1:]
        return cls(obj_id, path)
