"""
Base class for quantum kernels.
"""

from abc import ABC, abstractmethod
from typing import Any, List, Optional
import numpy as np
from ..licensing import validate_license_for_class


class BaseKernel(ABC):
    """
    Abstract base class for quantum kernels.
    
    Quantum kernels compute similarity between data points by comparing
    the quantum states generated by embedding the data.
    
    Parameters
    ----------
    embedding : BaseEmbedding
        Quantum embedding to use for feature mapping
    backend : BaseBackend
        Backend for quantum circuit execution
    """
    
    def __init__(self, embedding: Any, backend: Any):
        # License validation for all kernel classes
        validate_license_for_class(self.__class__)
        
        self.embedding = embedding
        self.backend = backend
    
    @abstractmethod
    def compute_kernel_element(self, x1: np.ndarray, x2: np.ndarray) -> float:
        """
        Compute kernel element K(x1, x2) between two data points.
        
        Parameters
        ----------
        x1, x2 : array-like
            Data points to compute kernel between
            
        Returns
        -------
        kernel_value : float
            Kernel value between x1 and x2
        """
        pass
    
    def compute_kernel_matrix(
        self, 
        X: np.ndarray, 
        Y: Optional[np.ndarray] = None
    ) -> np.ndarray:
        """
        Compute kernel matrix between sets of data points.
        
        Parameters
        ----------
        X : array-like of shape (n_samples_X, n_features)
            First set of data points
        Y : array-like of shape (n_samples_Y, n_features), optional
            Second set of data points (defaults to X)
            
        Returns
        -------
        K : ndarray of shape (n_samples_X, n_samples_Y)
            Kernel matrix
        """
        X = np.asarray(X)
        if Y is None:
            Y = X
        else:
            Y = np.asarray(Y)
        
        n_x, n_y = len(X), len(Y)
        K = np.zeros((n_x, n_y))
        
        for i in range(n_x):
            for j in range(n_y):
                K[i, j] = self.compute_kernel_element(X[i], Y[j])
        
        return K
    
    def compute_kernel_matrix_symmetric(self, X: np.ndarray) -> np.ndarray:
        """
        Compute symmetric kernel matrix for a single dataset.
        
        This method can be more efficient than compute_kernel_matrix
        when computing K(X, X) due to symmetry.
        
        Parameters
        ----------
        X : array-like of shape (n_samples, n_features)
            Data points
            
        Returns
        -------
        K : ndarray of shape (n_samples, n_samples)
            Symmetric kernel matrix
        """
        X = np.asarray(X)
        n = len(X)
        K = np.zeros((n, n))
        
        # Compute upper triangle (including diagonal)
        for i in range(n):
            for j in range(i, n):
                K[i, j] = self.compute_kernel_element(X[i], X[j])
                if i != j:
                    K[j, i] = K[i, j]  # Use symmetry
        
        return K
    
    def is_positive_definite(self, K: np.ndarray, tol: float = 1e-8) -> bool:
        """
        Check if kernel matrix is positive definite.
        
        Parameters
        ----------
        K : array-like
            Kernel matrix
        tol : float, default=1e-8
            Tolerance for eigenvalue check
            
        Returns
        -------
        is_pd : bool
            Whether the matrix is positive definite
        """
        try:
            eigenvals = np.linalg.eigvals(K)
            return np.all(eigenvals > -tol)
        except np.linalg.LinAlgError:
            return False
    
    def compute_kernel_alignment(
        self, 
        K1: np.ndarray, 
        K2: np.ndarray
    ) -> float:
        """
        Compute kernel alignment between two kernel matrices.
        
        Kernel alignment measures the similarity between two kernels:
        A(K1, K2) = <K1, K2>_F / (||K1||_F * ||K2||_F)
        
        Parameters
        ----------
        K1, K2 : array-like
            Kernel matrices to compare
            
        Returns
        -------
        alignment : float
            Kernel alignment score between 0 and 1
        """
        K1 = np.asarray(K1)
        K2 = np.asarray(K2)
        
        if K1.shape != K2.shape:
            raise ValueError("Kernel matrices must have the same shape")
        
        # Frobenius inner product
        inner_product = np.sum(K1 * K2)
        
        # Frobenius norms
        norm1 = np.sqrt(np.sum(K1 * K1))
        norm2 = np.sqrt(np.sum(K2 * K2))
        
        if norm1 == 0 or norm2 == 0:
            return 0.0
        
        alignment = inner_product / (norm1 * norm2)
        return float(alignment)
    
    def compute_effective_dimension(
        self, 
        K: np.ndarray, 
        threshold: float = 0.95
    ) -> int:
        """
        Compute effective dimension of the kernel matrix.
        
        The effective dimension is the number of eigenvalues needed
        to capture a certain fraction of the total variance.
        
        Parameters
        ----------
        K : array-like
            Kernel matrix
        threshold : float, default=0.95
            Variance threshold (between 0 and 1)
            
        Returns
        -------
        eff_dim : int
            Effective dimension
        """
        try:
            eigenvals = np.linalg.eigvals(K)
            eigenvals = np.real(eigenvals)
            eigenvals = np.sort(eigenvals)[::-1]  # Sort in descending order
            eigenvals = np.maximum(eigenvals, 0)  # Remove negative eigenvalues
            
            if np.sum(eigenvals) == 0:
                return 0
            
            cumsum = np.cumsum(eigenvals)
            total_variance = cumsum[-1]
            
            # Find number of eigenvalues needed for threshold
            normalized_cumsum = cumsum / total_variance
            eff_dim = np.searchsorted(normalized_cumsum, threshold) + 1
            
            return min(eff_dim, len(eigenvals))
        except np.linalg.LinAlgError:
            return len(K)
    
    def add_regularization(
        self, 
        K: np.ndarray, 
        reg_param: float = 1e-8
    ) -> np.ndarray:
        """
        Add regularization to kernel matrix.
        
        Parameters
        ----------
        K : array-like
            Kernel matrix
        reg_param : float, default=1e-8
            Regularization parameter
            
        Returns
        -------
        K_reg : ndarray
            Regularized kernel matrix
        """
        K = np.asarray(K)
        return K + reg_param * np.eye(len(K))
    
    def normalize_kernel(self, K: np.ndarray) -> np.ndarray:
        """
        Normalize kernel matrix to have unit diagonal.
        
        Parameters
        ----------
        K : array-like
            Kernel matrix
            
        Returns
        -------
        K_norm : ndarray
            Normalized kernel matrix
        """
        K = np.asarray(K)
        diag_sqrt = np.sqrt(np.diag(K))
        
        # Avoid division by zero
        diag_sqrt = np.where(diag_sqrt == 0, 1.0, diag_sqrt)
        
        # Normalize: K_norm[i,j] = K[i,j] / sqrt(K[i,i] * K[j,j])
        K_norm = K / np.outer(diag_sqrt, diag_sqrt)
        
        return K_norm
