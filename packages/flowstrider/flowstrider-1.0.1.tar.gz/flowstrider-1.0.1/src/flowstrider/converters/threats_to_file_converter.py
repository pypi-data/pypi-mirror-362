# SPDX-FileCopyrightText: 2025 German Aerospace Center (DLR)
#
# SPDX-License-Identifier: BSD-3-Clause

import os
from datetime import date
from typing import List

from fpdf import FPDF
from PIL import Image

from flowstrider import settings
from flowstrider.models import dataflowdiagram, threat, threat_management
from flowstrider.rules.collections import all_collections

# Constants:
FONT_SIZE_HEADER1 = 20
FONT_SIZE_HEADER2 = 16
FONT_SIZE_HEADER3 = 14
FONT_SIZE_NORMAL = 12
# Default A4 (210 * 297) measurements
WIDTH = 210
HEIGHT = 297
IMAGE_BORDER = 12
IMAGE_Y_START = 70
TABLE_LEFT_WIDTH = 40
LINE_HEIGHT = 8


class PDF(FPDF):
    def footer(self):
        self.set_y(-15)
        self.set_font("Arial", "", FONT_SIZE_NORMAL)
        if self.page_no() > 1:
            self.cell(0, 10, str(self.page_no()), align="C")

    # Returns number of lines a given string would need to be displayed in a column
    # ...of given width
    def get_string_line_count(self, input: str, width: int) -> int:
        line_count = 1
        words = input.split(" ")
        current_line = words[0]

        i = 1
        while i <= len(words):
            if self.get_string_width(current_line) > width:
                line_count += 1
                if len(current_line.split(" ")) == 1:
                    j = 0
                    for j in range(len(current_line)):
                        if self.get_string_width(current_line[:j]) > width:
                            break
                    current_line = current_line[j - 1 :]
                else:
                    current_line = words[i - 1]
            else:
                if i < len(words):
                    current_line += " " + words[i]
                i += 1
        return line_count

    # Helper method to add two cells next to each other with content dependent sizing
    def add_row(
        self,
        left_value: str,
        right_value: str,
        left_width: int = TABLE_LEFT_WIDTH,
        border: str = "",
    ):
        # Get needed y-space for left column to insert new page preventatively
        # ...if necessary because it's being cut off otherwise
        lines = self.get_string_line_count(left_value, TABLE_LEFT_WIDTH)
        if self.get_y() + (lines * LINE_HEIGHT) > HEIGHT - 20:
            self.add_page()

        x = self.get_x()
        y = self.get_y()
        p = self.page
        self.multi_cell(left_width, LINE_HEIGHT, left_value, border=border)
        y_left_new = self.get_y()
        page_left_new = self.page
        self.page = p
        self.set_xy(x + left_width, y)
        self.multi_cell(0, LINE_HEIGHT, right_value, border=border)
        if y_left_new > self.get_y() and page_left_new >= self.page:
            self.set_xy(self.get_x(), y_left_new)


def create_threats_pdf(
    threats: List[threat.Threat],
    dfd: dataflowdiagram.DataflowDiagram,
    threat_management_database: threat_management.ThreatManagementDatabase,
):
    """Generates a pdf report with all generated threats for a dfd
        and the graphviz visualisation if apllicable

    Args:
        threats: a list of threats generated by the elicit command
        dfd: the dataflowdiagram for which the threats were generated

    """
    # Define output language
    _ = settings.lang_out.gettext

    # Creating the PDF
    pdf = PDF()
    pdf.alias_nb_pages()
    pdf.set_margins(20, 20, 20)
    pdf.add_page()

    # First page w header and title
    pdf.set_font("Arial", "B", FONT_SIZE_HEADER1)
    pdf.ln(10)
    pdf.cell(0, 5, _("Automated Threat Modeling Results"), 0, 1, "C")
    pdf.ln(10)
    pdf.set_font("", "", FONT_SIZE_HEADER3)
    pdf.cell(0, 5, _("Project: {name}").format(name=dfd.id), 0, 1, "C")
    pdf.ln(2)
    pdf.cell(
        0,
        5,
        _("Generated on: {today}").format(today=date.today().strftime("%d.%m.%Y")),
        0,
        1,
        "C",
    )

    # Add dfd image
    visualization_file = "output/visualization/visualization.png"
    if os.path.exists(visualization_file):
        visualization_png = Image.open(visualization_file)
        visualization_width, visualization_height = visualization_png.size
        visualization_ratio = visualization_width / visualization_height
        area_width = WIDTH - (2 * IMAGE_BORDER)
        area_height = HEIGHT - IMAGE_Y_START - IMAGE_BORDER
        area_ratio = area_width / area_height
        # Fit to either height or width of image area depending on ratio of png
        if visualization_ratio > area_ratio:
            # Fit to width of image area
            image_height = area_width / visualization_ratio
            center_position = IMAGE_Y_START + (area_height / 2) - (image_height / 2)
            pdf.image(visualization_file, IMAGE_BORDER, center_position, area_width, 0)
        else:
            # Fit to height of image area
            image_width = area_height * visualization_ratio
            center_position = (WIDTH / 2) - (image_width / 2)
            pdf.image(
                visualization_file, center_position, IMAGE_Y_START, 0, area_height
            )

    # Group sources for better overview
    threats_by_source = {}
    threats_involved_locations = []
    for threat_ in threats:
        source = threat_.source
        location = threat.location_str(threat_.location, dfd)
        if source not in threats_by_source:
            threats_by_source[source] = []
        threats_by_source[source].append(threat_)
        if location not in threats_involved_locations:
            threats_involved_locations.append(location)

    # Add threats starting on second page
    pdf.add_page()

    if len(threats) == 0:
        pdf.set_font("", "B", FONT_SIZE_HEADER2)
        pdf.cell(0, 5, _("There were no threats found."), 0, 1, "")
    else:
        pdf.set_font("", "BU", FONT_SIZE_HEADER2)
        pdf.cell(0, 5, _("The following threats were elicited:"), 0, 1, "")
        pdf.ln(10)

        # Used rule collections:
        pdf.set_font("", "I", FONT_SIZE_NORMAL)
        pdf.cell(0, 5, _("Used rule collections:"), 0, 1, "")

        collection_names_list = []
        for collection in all_collections:
            for tag in collection.tags:
                if tag in dfd.tags:
                    collection_names_list.append(collection.name)
                    break
        collection_names = ", ".join(collection_names_list)
        pdf.cell(0, 5, collection_names, 0, 1, "")

        # Number of threats:
        pdf.ln(10)
        pdf.cell(
            0,
            5,
            settings.lang_out.ngettext(
                "One threat has been found.",
                "{count} threats have been found.",
                len(threats),
            ).format(count=len(threats))
            + " ("
            + settings.lang_out.ngettext(
                "One different threat",
                "{count} different threats",
                len(threats_by_source),
            ).format(count=len(threats_by_source))
            + " "
            + settings.lang_out.ngettext(
                "and a total of one involved location",
                "and a total of {count} involved locations",
                len(threats_involved_locations),
            ).format(count=len(threats_involved_locations))
            + ")"
            + "\n",
            0,
            1,
            "",
        )

        pdf.set_font("", "", FONT_SIZE_NORMAL)
        pdf.ln(10)

    # Add each unique threat and the list of locations where it occurs
    for i, (source, threats_) in enumerate(threats_by_source.items()):
        pdf.set_font("", "B", FONT_SIZE_HEADER3)
        pdf.cell(
            150, 5, _("#{number} Threat source: {src}").format(number=i + 1, src=source)
        )
        pdf.set_font("", "", FONT_SIZE_NORMAL)
        pdf.ln(10)

        pdf.add_row(_("Description:"), threats_[0].short_description, border="T")

        pdf.add_row(_("Long Description:"), threats_[0].long_description, border="T")

        for mitigation_option in threats_[0].mitigation_options:
            pdf.add_row(_("Mitigation Option:"), mitigation_option, border="T")
        if threats_[0].requirement != "":
            pdf.add_row(_("Requirement:"), threats_[0].requirement, border="T")

        for j in range(len(threats_)):
            if j == 0:
                pdf.add_row(
                    _("Locations:"), threats_[j].location_str(dfd) + ":", border="T"
                )
            else:
                pdf.add_row("", threats_[j].location_str(dfd) + ":")
            if threats_[j].req_status != "":
                pdf.add_row("", threats_[j].req_status, left_width=TABLE_LEFT_WIDTH + 5)

            threat_management_item = threat_management_database.get(threats_[j], dfd)
            pdf.add_row(
                "",
                _("Management State:")
                + " {content}".format(content=threat_management_item.management_state),
                left_width=TABLE_LEFT_WIDTH,
            )
            if len(threat_management_item.explanation) > 0:
                pdf.add_row(
                    "",
                    _("Management Explanation:")
                    + " "
                    + threat_management_item.explanation,
                    left_width=TABLE_LEFT_WIDTH,
                )

            if j != len(threats_) - 1:
                pdf.add_row("", "\n", left_width=TABLE_LEFT_WIDTH)

        pdf.cell(TABLE_LEFT_WIDTH, 0, "", border="T")
        pdf.multi_cell(0, 0, "", border="T")

        pdf.ln(20)

    is_bsi_elicit = False
    for tag in all_collections[0].tags:
        if tag in dfd.tags:
            is_bsi_elicit = True

    # Add references:
    if is_bsi_elicit and len(threats) > 0:
        # Add BSI reference if dfd was evaluated for BSI rules
        pdf.set_font("", "BU", FONT_SIZE_HEADER2)
        pdf.write(5, _("References:"))
        pdf.ln(10)
        pdf.set_font("", "", FONT_SIZE_NORMAL)
        pdf.write(5, _("BSI IT-Grundschutzkompendium checklist:"))
        pdf.write(
            5,
            "https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Grundschutz/IT-GS-"
            + "Kompendium/checklisten_2023.html",
            "https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Grundschutz/IT-GS-"
            + "Kompendium/checklisten_2023.html",
        )

    if not os.path.exists("output"):
        os.mkdir("output")

    pdf.output("output/" + dfd.id + "_threats.pdf")
