# coding: utf-8

"""
    Talon.One API

    Use the Talon.One API to integrate with your application and to manage applications and campaigns:  - Use the operations in the [Integration API section](#integration-api) are used to integrate with our platform - Use the operation in the [Management API section](#management-api) to manage applications and campaigns.  ## Determining the base URL of the endpoints  The API is available at the same hostname as your Campaign Manager deployment. For example, if you access the Campaign Manager at `https://yourbaseurl.talon.one/`, the URL for the [updateCustomerSessionV2](https://docs.talon.one/integration-api#operation/updateCustomerSessionV2) endpoint is `https://yourbaseurl.talon.one/v2/customer_sessions/{Id}`   # noqa: E501

    The version of the OpenAPI document: 
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from talon_one.configuration import Configuration


class NewPriceAdjustment(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'price_type': 'str',
        'price': 'float',
        'reference_id': 'str',
        'calculated_at': 'datetime',
        'effective_from': 'datetime',
        'effective_until': 'datetime'
    }

    attribute_map = {
        'price_type': 'priceType',
        'price': 'price',
        'reference_id': 'referenceId',
        'calculated_at': 'calculatedAt',
        'effective_from': 'effectiveFrom',
        'effective_until': 'effectiveUntil'
    }

    def __init__(self, price_type=None, price=None, reference_id=None, calculated_at=None, effective_from=None, effective_until=None, local_vars_configuration=None):  # noqa: E501
        """NewPriceAdjustment - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._price_type = None
        self._price = None
        self._reference_id = None
        self._calculated_at = None
        self._effective_from = None
        self._effective_until = None
        self.discriminator = None

        self.price_type = price_type
        self.price = price
        self.reference_id = reference_id
        if calculated_at is not None:
            self.calculated_at = calculated_at
        if effective_from is not None:
            self.effective_from = effective_from
        if effective_until is not None:
            self.effective_until = effective_until

    @property
    def price_type(self):
        """Gets the price_type of this NewPriceAdjustment.  # noqa: E501

        The price type (e.g. the price for members only) to apply to a given SKU.  # noqa: E501

        :return: The price_type of this NewPriceAdjustment.  # noqa: E501
        :rtype: str
        """
        return self._price_type

    @price_type.setter
    def price_type(self, price_type):
        """Sets the price_type of this NewPriceAdjustment.

        The price type (e.g. the price for members only) to apply to a given SKU.  # noqa: E501

        :param price_type: The price_type of this NewPriceAdjustment.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and price_type is None:  # noqa: E501
            raise ValueError("Invalid value for `price_type`, must not be `None`")  # noqa: E501

        self._price_type = price_type

    @property
    def price(self):
        """Gets the price of this NewPriceAdjustment.  # noqa: E501

        The value of the price type applied to the SKU. When set to `null`, the defined price type no longer applies to the SKU.  # noqa: E501

        :return: The price of this NewPriceAdjustment.  # noqa: E501
        :rtype: float
        """
        return self._price

    @price.setter
    def price(self, price):
        """Sets the price of this NewPriceAdjustment.

        The value of the price type applied to the SKU. When set to `null`, the defined price type no longer applies to the SKU.  # noqa: E501

        :param price: The price of this NewPriceAdjustment.  # noqa: E501
        :type: float
        """

        self._price = price

    @property
    def reference_id(self):
        """Gets the reference_id of this NewPriceAdjustment.  # noqa: E501

        A unique reference identifier, e.g. a UUID.  # noqa: E501

        :return: The reference_id of this NewPriceAdjustment.  # noqa: E501
        :rtype: str
        """
        return self._reference_id

    @reference_id.setter
    def reference_id(self, reference_id):
        """Sets the reference_id of this NewPriceAdjustment.

        A unique reference identifier, e.g. a UUID.  # noqa: E501

        :param reference_id: The reference_id of this NewPriceAdjustment.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and reference_id is None:  # noqa: E501
            raise ValueError("Invalid value for `reference_id`, must not be `None`")  # noqa: E501

        self._reference_id = reference_id

    @property
    def calculated_at(self):
        """Gets the calculated_at of this NewPriceAdjustment.  # noqa: E501

        The time at which this price was calculated. If provided, this is used to determine the most recent price adjustment to choose if price adjustments overlap. Defaults to internal creation time if not provided.  # noqa: E501

        :return: The calculated_at of this NewPriceAdjustment.  # noqa: E501
        :rtype: datetime
        """
        return self._calculated_at

    @calculated_at.setter
    def calculated_at(self, calculated_at):
        """Sets the calculated_at of this NewPriceAdjustment.

        The time at which this price was calculated. If provided, this is used to determine the most recent price adjustment to choose if price adjustments overlap. Defaults to internal creation time if not provided.  # noqa: E501

        :param calculated_at: The calculated_at of this NewPriceAdjustment.  # noqa: E501
        :type: datetime
        """

        self._calculated_at = calculated_at

    @property
    def effective_from(self):
        """Gets the effective_from of this NewPriceAdjustment.  # noqa: E501

        The date and time from which the price adjustment is effective.  # noqa: E501

        :return: The effective_from of this NewPriceAdjustment.  # noqa: E501
        :rtype: datetime
        """
        return self._effective_from

    @effective_from.setter
    def effective_from(self, effective_from):
        """Sets the effective_from of this NewPriceAdjustment.

        The date and time from which the price adjustment is effective.  # noqa: E501

        :param effective_from: The effective_from of this NewPriceAdjustment.  # noqa: E501
        :type: datetime
        """

        self._effective_from = effective_from

    @property
    def effective_until(self):
        """Gets the effective_until of this NewPriceAdjustment.  # noqa: E501

        The date and time until which the price adjustment is effective.  # noqa: E501

        :return: The effective_until of this NewPriceAdjustment.  # noqa: E501
        :rtype: datetime
        """
        return self._effective_until

    @effective_until.setter
    def effective_until(self, effective_until):
        """Sets the effective_until of this NewPriceAdjustment.

        The date and time until which the price adjustment is effective.  # noqa: E501

        :param effective_until: The effective_until of this NewPriceAdjustment.  # noqa: E501
        :type: datetime
        """

        self._effective_until = effective_until

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, NewPriceAdjustment):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, NewPriceAdjustment):
            return True

        return self.to_dict() != other.to_dict()
