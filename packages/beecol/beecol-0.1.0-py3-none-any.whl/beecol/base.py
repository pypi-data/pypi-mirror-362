import numpy as np
from typing import Tuple, Callable


class ArtificialBeeColony:

    def __init__(
        self,
        fit_func: Callable[[np.ndarray], float],
        dim: int,
        bounds: tuple[float, float],
        n_bees: int,
        random_state: int = 42,
    ) -> None:
        """
        Implements the Artificial Bee Colony (ABC) optimization algorithm for continuous optimization problems.

        The ABC algorithm is inspired by the foraging behavior of honey bees and is used to find the global minimum or maximum of a given objective function. This implementation supports maximization by default.

        Args:
            fit_func (Callable[[np.ndarray], float]): The objective function to be maximized. Should accept a 1D numpy array and return a float.
            dim (int): Number of dimensions (parameters) of the search space.
            bounds (tuple[float, float]): Tuple specifying the lower and upper bounds for each parameter.
            n_bees (int): Number of bees (food sources) in the colony.
            random_state (int, optional): Seed for the random number generator to ensure reproducibility. Defaults to 42.
        """
        # Store algorithm parameters
        self.fit_func = fit_func
        self.dim = dim
        self.x_min, self.x_max = bounds
        self.n_bees = n_bees

        # Initialize random number generator
        self.rgen = np.random.default_rng(random_state)

        # Initialize food sources randomly within bounds
        self.food_sources = self.rgen.uniform(
            self.x_min, self.x_max, (self.n_bees, self.dim)
        )

        # Initialize limit counters for abandonment
        self.limit = np.zeros(self.n_bees)
        self.abandon_limit = self.dim * self.n_bees

        # Calculate initial fitness values and find best solution
        self.fitness = np.array([self.fit_func(source) for source in self.food_sources])
        idx = np.argmax(self.fitness)
        self.best_solution = self.food_sources[idx]
        self.best_fitness = self.fitness[idx]

    def generate_new_solution(self, i: int) -> np.ndarray:
        """
        Generate a new candidate solution for a given food source using neighborhood search.

        A random partner food source is selected (different from the current one), and a new solution is generated by perturbing the current solution in the direction of the difference between the two sources, scaled by a random factor.

        Args:
            i (int): Index of the current food source to be modified.

        Returns:
            np.ndarray: The new candidate solution, clipped to remain within the defined bounds.
        """
        # Select a random partner solution, excluding the current solution
        available_indices = np.delete(np.arange(self.n_bees), i)
        partner_idx = self.rgen.choice(available_indices)

        # Generate random weights for the difference vector
        phi = self.rgen.uniform(-1, 1, self.dim)

        # Calculate the difference vector and add it to the current solution
        delta = phi * (self.food_sources[i] - self.food_sources[partner_idx])

        # Ensure the new solution stays within bounds
        return np.clip(self.food_sources[i] + delta, self.x_min, self.x_max)

    def employed_bees_phase(self):
        """
        Perform the employed bees phase of the ABC algorithm.

        Each employed bee explores the neighborhood of its assigned food source. If a better solution is found, the food source is updated and its abandonment counter is reset. Otherwise, the abandonment counter is incremented.
        """
        # Each employed bee visits its assigned food source
        for i in range(self.n_bees):
            # Generate and evaluate new candidate solution
            new_solution = self.generate_new_solution(i)
            new_fitness = self.fit_func(new_solution)

            # Update if better solution is found, otherwise increment limit
            if new_fitness > self.fitness[i]:
                self.food_sources[i] = new_solution
                self.fitness[i] = new_fitness
                self.limit[i] = 0
            else:
                self.limit[i] += 1

    def onlooker_bees_phase(self):
        """
        Perform the onlooker bees phase of the ABC algorithm.

        Onlooker bees probabilistically select food sources based on their fitness and attempt to improve them using neighborhood search. Better food sources are more likely to be chosen for further exploration.
        """
        # For maximization, better solutions have higher probabilities directly
        fitness_probs = (
            self.fitness - min(self.fitness) + 1e-10
        )  # Added small constant to avoid division by zero
        for i in range(self.n_bees):
            if self.rgen.random() < fitness_probs[i] / sum(fitness_probs):
                # Perform neighborhood search similar to employed bees phase
                new_solution = self.generate_new_solution(i)
                new_fitness = self.fit_func(new_solution)

                # Update if better solution is found
                if new_fitness > self.fitness[i]:
                    self.food_sources[i] = new_solution
                    self.fitness[i] = new_fitness
                    self.limit[i] = 0
                else:
                    self.limit[i] += 1

    def scout_bees_phase(self):
        """
        Perform the scout bees phase of the ABC algorithm.

        Food sources that have not improved for a number of trials exceeding the abandonment limit are abandoned and replaced with new randomly generated solutions. This helps the algorithm escape local optima.
        """
        # Check each food source for abandonment
        for i in range(self.n_bees):
            if self.limit[i] > self.abandon_limit:
                # Generate new random solution if limit exceeded
                self.food_sources[i] = self.rgen.uniform(
                    self.x_min, self.x_max, self.dim
                )
                self.fitness[i] = self.fit_func(self.food_sources[i])
                self.limit[i] = 0

    def step(self) -> Tuple[np.ndarray, float]:
        """
        Execute one full iteration of the ABC algorithm, including all three phases.

        This method runs the employed bees, onlooker bees, and scout bees phases in sequence, and updates the best solution found so far.

        Returns:
            Tuple[np.ndarray, float]:
                - The best solution found so far (as a numpy array).
                - The fitness value of the best solution (float).
        """
        # Execute all three phases of the algorithm
        self.employed_bees_phase()
        self.onlooker_bees_phase()
        self.scout_bees_phase()

        # Update best solution if improved
        best_idx = np.argmax(self.fitness)
        if self.fitness[best_idx] > self.best_fitness:
            self.best_solution = self.food_sources[best_idx]
            self.best_fitness = self.fitness[best_idx]

        return self.best_solution, self.best_fitness
