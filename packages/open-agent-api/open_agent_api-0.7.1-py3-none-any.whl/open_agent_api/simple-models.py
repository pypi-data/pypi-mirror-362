# generated by datamodel-codegen:
#   filename:  open-agent-api-bundled.yaml

from __future__ import annotations

from datetime import date as date_aliased
from datetime import datetime
from enum import Enum
from typing import Any, Optional, Union
from uuid import UUID

from pydantic import AnyUrl, BaseModel, EmailStr, Field


class AccountBalanceInfo(BaseModel):
    balance: Optional[int] = Field(0, title="Balance")
    currency: Optional[str] = Field("USD", title="Currency")


class Status(Enum):
    trialing = "trialing"
    active = "active"
    past_due = "past_due"
    canceled = "canceled"
    unpaid = "unpaid"


class AccountSubscriptionInfo(BaseModel):
    id: UUID = Field(
        ..., description="Unique identifier for the subscription", title="ID"
    )
    user_id: UUID = Field(
        ..., description="ID of the user this subscription belongs to", title="User ID"
    )
    plan_id: Optional[UUID] = Field(
        None, description="ID of the subscription plan", title="Plan ID"
    )
    status: Status = Field(
        ..., description="Current status of the subscription", title="Status"
    )
    stripe_customer_id: Optional[str] = Field(
        None, description="ID of the customer in Stripe", title="Stripe Customer ID"
    )
    stripe_subscription_id: Optional[str] = Field(
        None,
        description="ID of the subscription in Stripe",
        title="Stripe Subscription ID",
    )
    current_period_start: Optional[datetime] = Field(
        None,
        description="Start date of the current billing period",
        title="Current Period Start",
    )
    current_period_end: Optional[datetime] = Field(
        None,
        description="End date of the current billing period",
        title="Current Period End",
    )
    balance: Optional[int] = Field(
        None, description="The balance of the subscription", title="Balance"
    )
    usage_quota: Optional[dict[str, Any]] = Field(
        None, description="Token limits and other usage quotas", title="Usage Quota"
    )
    payment_method_id: Optional[str] = Field(
        None, description="ID of the payment method", title="Payment Method ID"
    )
    cancel_at_period_end: Optional[bool] = Field(
        False,
        description="Whether the subscription will be canceled at the end of the current period",
        title="Cancel At Period End",
    )
    created_at: Optional[datetime] = Field(
        None,
        description="Timestamp when the subscription was created",
        title="Created At",
    )
    updated_at: Optional[datetime] = Field(
        None,
        description="Timestamp when the subscription was last updated",
        title="Updated At",
    )


class AccountSubscriptionPurchase(BaseModel):
    plan_id: UUID = Field(
        ..., description="ID of the subscription plan", title="Plan ID"
    )
    payment_method_id: UUID = Field(
        ..., description="ID of the payment method", title="Payment Method ID"
    )


class AgentEnvironment(BaseModel):
    working_directory: str = Field(
        ..., description="The working directory for the agent"
    )
    platform: str = Field(..., description="The platform the agent is running on")


class ToolkitFunction(BaseModel):
    name: str = Field(..., description="The name of the function")
    description: str = Field(..., description="The description of the function")
    parameters: dict[str, Any] = Field(
        ..., description="The parameters of the function"
    )
    strict: Optional[bool] = Field(False, description="Whether the function is strict")


class AgentToolkitSummary(BaseModel):
    name: str = Field(..., description="The name of the tool")
    instructions: str = Field(..., description="Optional instructions for the toolkit")
    functions: list[str] = Field(..., description="The functions of the tool")


class Toolkit(BaseModel):
    name: str = Field(..., description="The name of the tool")
    instructions: str = Field(..., description="Optional instructions for the toolkit")
    functions: Optional[list[ToolkitFunction]] = Field(
        [], description="The functions of the tool"
    )


class Type(Enum):
    mcp = "mcp"


class ExternalTool(BaseModel):
    type: Optional[Type] = Field(None, description="The type of tool")
    name: str = Field(..., description="The name of the tool")
    url: Optional[str] = Field(
        None, description="The URL endpoint for the external tool"
    )
    api_key: Optional[str] = Field(
        None, description="The API key for the external tool"
    )


class Type1(Enum):
    function = "function"
    tool = "tool"


class Function(BaseModel):
    name: str = Field(..., description="The name of the function to call")
    arguments: str = Field(..., description="The arguments to pass to the function")


class AgentMessageToolCall(BaseModel):
    id: str = Field(..., description="The ID of the tool to call")
    type: Type1 = Field(..., description="The type of the tool or function")
    function: Function = Field(..., description="The function to call")


class Role(Enum):
    system = "system"
    user = "user"
    assistant = "assistant"
    tool = "tool"


class AuthMagicLinkRequest(BaseModel):
    email: EmailStr = Field(
        ..., description="Email address to send the magic login link to."
    )


class AuthLoginResponse(BaseModel):
    jwt_token: str = Field(..., description="JWT token for authentication")
    expires_at: datetime = Field(..., description="Expiration timestamp of the token")
    verified: bool = Field(..., description="Whether the email has been verified")


class Role1(Enum):
    tool = "tool"


class ToolCall(BaseModel):
    role: Optional[Role1] = Field("tool", description="The role of the tool")
    tool_call_id: str = Field(
        ..., description="The unique identifier for the tool call"
    )
    tool_name: str = Field(..., description="The name of the tool being called")
    tool_args: dict[str, Any] = Field(
        ..., description="The arguments passed to the tool"
    )
    tool_call_error: Optional[bool] = Field(
        None, description="Whether the tool call resulted in an error"
    )


class Metrics(BaseModel):
    input_tokens: Optional[int] = Field(None, description="Number of input tokens used")
    output_tokens: Optional[int] = Field(
        None, description="Number of output tokens used"
    )
    total_tokens: Optional[int] = Field(None, description="Total number of tokens used")
    prompt_tokens: Optional[int] = Field(
        None, description="Number of prompt tokens used"
    )
    completion_tokens: Optional[int] = Field(
        None, description="Number of completion tokens used"
    )
    prompt_tokens_details: Optional[dict[str, Any]] = Field(
        None, description="Detailed breakdown of prompt tokens"
    )
    completion_tokens_details: Optional[dict[str, Any]] = Field(
        None, description="Detailed breakdown of completion tokens"
    )
    additional_metrics: Optional[dict[str, Any]] = Field(
        None, description="Any additional metrics"
    )
    time: Optional[float] = Field(
        None, description="Time taken for the tool call in seconds"
    )
    time_to_first_token: Optional[float] = Field(
        None, description="Time to first token in seconds"
    )
    timer: Optional[dict[str, Any]] = Field(
        None, description="Detailed timing information"
    )


class ToolCallResult(BaseModel):
    role: Optional[Role1] = Field("tool", description="The role of the tool")
    tool_call_id: str = Field(
        ..., description="The unique identifier for the tool call"
    )
    tool_name: str = Field(..., description="The name of the tool being called")
    tool_args: dict[str, Any] = Field(
        ..., description="The arguments passed to the tool"
    )
    content: Optional[str] = Field(
        None, description="The content or result returned by the tool"
    )
    tool_call_error: Optional[bool] = Field(
        None, description="Indicates whether the tool call resulted in an error"
    )
    metrics: Optional[Metrics] = Field(
        None, description="Performance metrics for the tool call"
    )
    created_at: Optional[int] = Field(
        None, description="Timestamp when the tool call result was created"
    )


class AgentMessageReferences(BaseModel):
    query: str = Field(..., title="Query")
    references: list[dict[str, Any]] = Field(..., title="References")
    time: Optional[float] = Field(None, title="Time")


class UrlCitation(BaseModel):
    url: Optional[str] = Field(None, title="Url")
    title: Optional[str] = Field(None, title="Title")


class DocumentCitation(BaseModel):
    document_title: Optional[str] = Field(None, title="Document Title")
    cited_text: Optional[str] = Field(None, title="Cited Text")
    file_name: Optional[str] = Field(None, title="File Name")


class Event(Enum):
    RunStarted = "RunStarted"


class RunStartedEvent(BaseModel):
    run_id: str = Field(..., description="The unique identifier for the run")
    content: str = Field(..., description="The content of the response")
    content_type: str = Field(..., description="The type of content")
    event: Event = Field(..., description="The event type")
    model: Optional[str] = Field(None, description="The model used for the run")
    agent_id: Optional[str] = Field(
        None, description="The unique identifier for the agent"
    )
    session_id: str = Field(..., description="The unique identifier for the session")
    created_at: int = Field(
        ..., description="The timestamp when the response was created"
    )


class Event1(Enum):
    ToolCallStarted = "ToolCallStarted"


class Event2(Enum):
    ToolCallCompleted = "ToolCallCompleted"


class ToolCallCompletedEvent(BaseModel):
    run_id: str = Field(..., description="The unique identifier for the run")
    content: Optional[str] = Field(
        None, description="The content of the tool call completion"
    )
    content_type: str = Field(..., description="The type of content")
    event: Event2 = Field(..., description="The event type")
    model: Optional[str] = Field(None, description="The model used for the run")
    agent_id: Optional[str] = Field(
        None, description="The unique identifier for the agent"
    )
    session_id: str = Field(..., description="The unique identifier for the session")
    created_at: int = Field(
        ..., description="The timestamp when the tool call was completed"
    )
    tools: Optional[list[ToolCallResult]] = Field(
        None, description="Details of the completed tool call"
    )


class Event3(Enum):
    RunCompleted = "RunCompleted"


class Status1(Enum):
    succeeded = "succeeded"
    failed = "failed"
    canceled = "canceled"


class RunCompletedEvent(BaseModel):
    run_id: str = Field(..., description="The unique identifier for the run")
    content: Optional[str] = Field(None, description="The content of the response")
    content_type: Optional[str] = Field(None, description="The type of content")
    event: Event3 = Field(..., description="The event type")
    model: Optional[str] = Field(None, description="The model used for the run")
    agent_id: Optional[str] = Field(
        None, description="The unique identifier for the agent"
    )
    session_id: str = Field(..., description="The unique identifier for the session")
    created_at: int = Field(
        ..., description="The timestamp when the response was created"
    )
    runtime: Optional[float] = Field(
        None, description="The total runtime of the run in seconds"
    )
    metrics: Optional[dict[str, Any]] = Field(
        None, description="Metrics collected during the run"
    )
    status: Optional[Status1] = Field(None, description="The final status of the run")


class File(BaseModel):
    url: Optional[str] = Field(None, description="Remote location for file")
    filepath: Optional[str] = Field(
        None, description="Absolute local location for file"
    )
    content: Optional[dict[str, Any]] = Field(
        None, description="Actual file bytes content"
    )
    mime_type: Optional[str] = Field(None, description="MIME type of the file")


class Image(BaseModel):
    url: Optional[str] = Field(None, description="Remote location for image")
    filepath: Optional[str] = Field(
        None, description="Absolute local location for image"
    )
    content: Optional[dict[str, Any]] = Field(
        None, description="Actual image bytes content"
    )
    format: Optional[str] = Field(
        None, description="Image format (e.g. png, jpeg, webp, gif)"
    )
    detail: Optional[str] = Field(
        None,
        description="Image detail level (low, medium, high or auto) per OpenAI spec",
    )
    id: Optional[str] = Field(None, description="Unique identifier for the image")


class Media(BaseModel):
    id: Optional[str] = Field(None, description="Unique identifier for the media")
    original_prompt: Optional[str] = Field(
        None, description="Original prompt used to generate the media"
    )
    revised_prompt: Optional[str] = Field(
        None, description="Revised prompt used to generate the media"
    )


class Video(Media):
    url: Optional[str] = Field(None, description="Remote location for the video file")
    eta: Optional[str] = Field(None, description="Estimated time of arrival/completion")
    length: Optional[str] = Field(None, description="Length of the video")


class Agent(BaseModel):
    id: str = Field(..., description="Unique identifier for the agent.")
    name: Optional[str] = Field(None, description="Human-readable name for the agent.")
    model: Optional[str] = Field(None, description="Base model used by the agent.")
    description: Optional[str] = Field(
        None, description="Description or persona of the agent."
    )
    instructions: Optional[str] = Field(None, description="Instructions for the agent.")
    tools: Optional[list[Toolkit]] = Field(
        None,
        description="Toolkits available to the agent.\nA toolkit is a collection of tools that can be used by the agent.\n",
    )
    created_at: Optional[datetime] = None


class Member(BaseModel):
    agent_id: Optional[str] = None
    role: Optional[str] = None
    is_leader: Optional[bool] = None


class Team(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    members: Optional[list[Member]] = Field(None, description="Agents in the team.")
    tools: Optional[list[Toolkit]] = Field(
        None, description="Toolkits available to the manager of the team"
    )
    created_at: Optional[datetime] = None


class Url(UrlCitation):
    pass


class Document(DocumentCitation):
    pass


class TeamMessageCitations(BaseModel):
    raw: Optional[Any] = Field(None, title="Raw")
    urls: Optional[list[Url]] = Field(None, title="Urls")
    documents: Optional[list[Document]] = Field(None, title="Documents")


class CostSummary(BaseModel):
    input_tokens: float = Field(..., description="The number of input tokens used")
    output_tokens: float = Field(..., description="The number of output tokens used")
    microdollars: float = Field(..., description="The cost in microdollars")


class CostSummaryEvent(BaseModel):
    event: Optional[str] = Field(None, description="The type of event")
    cost: CostSummary


class ValidationError(BaseModel):
    loc: list[Union[str, int]] = Field(..., title="Location")
    msg: str = Field(..., title="Message")
    type: str = Field(..., title="Error Type")


class UserSubscriptionCreate(BaseModel):
    user_id: UUID = Field(..., title="User Id")
    plan_id: UUID = Field(..., title="Plan Id")


class SubscriptionStatus(Enum):
    active = "active"
    canceled = "canceled"
    past_due = "past_due"
    trialing = "trialing"
    unpaid = "unpaid"


class UserSubscriptionResponse(BaseModel):
    id: UUID = Field(..., title="Id")
    user_id: UUID = Field(..., title="User Id")
    plan_id: UUID = Field(..., title="Plan Id")
    status: SubscriptionStatus
    stripe_customer_id: Optional[str] = Field(None, title="Stripe Customer Id")
    stripe_subscription_id: Optional[str] = Field(None, title="Stripe Subscription Id")
    current_period_start: Optional[datetime] = Field(None, title="Current Period Start")
    current_period_end: Optional[datetime] = Field(None, title="Current Period End")
    cancel_at_period_end: Optional[bool] = Field(False, title="Cancel At Period End")
    created_at: datetime = Field(..., title="Created At")
    updated_at: datetime = Field(..., title="Updated At")


class ServerSetupRequest(BaseModel):
    stripe_api_key: Optional[str] = Field(None, title="Stripe Api Key")
    stripe_webhook_secret: Optional[str] = Field(None, title="Stripe Webhook Secret")


class ServerSetupResponse(BaseModel):
    status: str = Field(..., title="Status")
    message: str = Field(..., title="Message")
    configured_keys: dict[str, bool] = Field(..., title="Configured Keys")


class OAuthAuthorizationResponse(BaseModel):
    authorization_url: AnyUrl = Field(
        ..., description="The URL to redirect the user to for OAuth login"
    )
    state: str = Field(
        ..., description="CSRF protection state parameter to verify in the callback"
    )


class OAuthDeviceCodeResponse(BaseModel):
    device_code: str = Field(
        ..., description="Code that identifies the device verification request"
    )
    user_code: str = Field(
        ..., description="User-friendly code to enter on the verification page"
    )
    verification_uri: AnyUrl = Field(
        ..., description="URI where the user should enter the user_code"
    )
    expires_in: int = Field(
        ..., description="The lifetime in seconds of the device code"
    )
    interval: int = Field(
        ..., description="The minimum time in seconds to wait between polling requests"
    )


class OAuthDeviceCodeRequest(BaseModel):
    device_code: str = Field(
        ...,
        description="The device code returned from the initial OAuth device flow request",
    )


class OAuthCallbackResponse(BaseModel):
    token_id: str = Field(..., description="The ID of the token.")
    token_type: str = Field(..., example="Bearer")
    expires_at: datetime = Field(..., description="Expiration time of the token.")


class Scope(Enum):
    read = "read"
    write = "write"
    admin = "admin"


class ApiKeyCreationRequest(BaseModel):
    name: str = Field(
        ...,
        description="A descriptive name for the API key to help identify its purpose",
        title="Name",
    )
    expires_in: Optional[int] = Field(
        0,
        description="Number of days until the API key expires (0 for no expiration)",
        title="Expires In",
    )
    scopes: Optional[list[Scope]] = Field(
        ["read", "write"],
        description="Permission scopes for the API key",
        title="Scopes",
    )
    metadata: Optional[dict[str, Any]] = Field(
        {},
        description="Optional custom metadata for the API key (e.g., application name, environment)",
        title="Metadata",
    )


class Usage(BaseModel):
    total_requests: Optional[int] = Field(
        None,
        description="Total number of API requests made with this key",
        title="Total Requests",
    )
    total_tokens: Optional[int] = Field(
        None,
        description="Total number of tokens consumed by this key",
        title="Total Tokens",
    )
    monthly_requests: Optional[int] = Field(
        None,
        description="Number of API requests made this month",
        title="Monthly Requests",
    )
    monthly_tokens: Optional[int] = Field(
        None, description="Number of tokens consumed this month", title="Monthly Tokens"
    )


class ApiKeyInfo(BaseModel):
    id: UUID = Field(..., description="Unique identifier for the API key", title="ID")
    name: str = Field(
        ..., description="The descriptive name of the API key", title="Name"
    )
    prefix: Optional[str] = Field(
        None,
        description="First few characters of the API key for identification",
        title="Prefix",
    )
    created_at: datetime = Field(
        ..., description="Timestamp when the API key was created", title="Created At"
    )
    expires_at: Optional[datetime] = Field(
        None,
        description="Timestamp when the API key will expire (null if never expires)",
        title="Expires At",
    )
    is_active: bool = Field(
        ..., description="Whether the API key is currently active", title="Is Active"
    )
    last_used_at: datetime = Field(
        ...,
        description="Timestamp when the API key was last used (null if never used)",
        title="Last Used At",
    )
    scopes: Optional[list[str]] = Field(
        None, description="Permission scopes assigned to the API key", title="Scopes"
    )
    metadata: Optional[dict[str, Any]] = Field(
        None, description="Custom metadata for the API key", title="Metadata"
    )
    usage: Optional[Usage] = Field(
        None, description="Usage statistics for the API key", title="Usage"
    )


class AccountUpdateRequest(BaseModel):
    name: Optional[str] = Field(
        None, description="The name of the user account", title="Name"
    )
    username: Optional[str] = Field(
        None, description="The username of the user account", title="Username"
    )


class BillingInfo(BaseModel):
    stripe_customer_id: Optional[str] = Field(None, title="Stripe Customer ID")
    stripe_subscription_id: Optional[str] = Field(None, title="Stripe Subscription ID")
    current_period_start: Optional[datetime] = Field(None, title="Current Period Start")
    current_period_end: Optional[datetime] = Field(None, title="Current Period End")
    cancel_at_period_end: Optional[bool] = Field(False, title="Cancel At Period End")
    created_at: Optional[datetime] = Field(None, title="Created At")
    updated_at: Optional[datetime] = Field(None, title="Updated At")


class UsageData(BaseModel):
    total_requests: Optional[int] = Field(
        None,
        description="Total number of API requests made with this key",
        title="Total Requests",
    )
    total_tokens: Optional[int] = Field(
        None,
        description="Total number of tokens consumed by this key",
        title="Total Tokens",
    )
    monthly_requests: Optional[int] = Field(
        None,
        description="Number of API requests made this month",
        title="Monthly Requests",
    )
    monthly_tokens: Optional[int] = Field(
        None, description="Number of tokens consumed this month", title="Monthly Tokens"
    )
    billing_info: Optional[BillingInfo] = Field(
        None, description="Billing information for the API key"
    )


class TimeSery(BaseModel):
    date: Optional[date_aliased] = Field(None, description="Date for this data point")
    requests: Optional[int] = Field(None, description="Number of requests")
    tokens: Optional[int] = Field(None, description="Number of tokens")
    cost: Optional[float] = Field(None, description="Cost for this period")


class ApiKeyUsageResponse(BaseModel):
    usage_data: UsageData = Field(
        ..., description="Detailed usage statistics for the API key"
    )
    time_series: Optional[list[TimeSery]] = Field(
        None, description="Time-series data when group_by parameter is used"
    )


class CheckoutSessionRequest(BaseModel):
    success_url: Optional[str] = Field(
        None,
        description="The URL to redirect to after the checkout session is completed",
    )
    cancel_url: Optional[str] = Field(
        None, description="The URL to redirect to if the checkout session is canceled"
    )


class CheckoutSessionInfo(BaseModel):
    checkout_url: str = Field(
        ..., description="The checkout URL for the subscription plan"
    )
    session_id: str = Field(..., description="The ID of the checkout session")


class TeamUsageInfo(BaseModel):
    input_tokens: Optional[int] = Field(0, title="Input Tokens")
    output_tokens: Optional[int] = Field(0, title="Output Tokens")
    total_tokens: Optional[int] = Field(0, title="Total Tokens")
    prompt_tokens: Optional[int] = Field(0, title="Prompt Tokens")
    completion_tokens: Optional[int] = Field(0, title="Completion Tokens")
    prompt_tokens_details: Optional[dict[str, Any]] = Field(
        None, title="Prompt Tokens Details"
    )
    completion_tokens_details: Optional[dict[str, Any]] = Field(
        None, title="Completion Tokens Details"
    )
    additional_metrics: Optional[dict[str, Any]] = Field(
        None, title="Additional Metrics"
    )
    time: Optional[float] = Field(None, title="Time")
    time_to_first_token: Optional[float] = Field(None, title="Time To First Token")


class AccountUsageInfoItem(BaseModel):
    method: Optional[str] = Field(None, title="Method")
    endpoint: Optional[str] = Field(None, title="Endpoint")
    input_tokens: Optional[int] = Field(0, title="Input Tokens")
    output_tokens: Optional[int] = Field(0, title="Output Tokens")
    debit_microdollars: Optional[int] = Field(0, title="Debit Microdollars")
    credit_microdollars: Optional[int] = Field(0, title="Credit Microdollars")
    created_at: Optional[datetime] = Field(None, title="Created At")


class AccountPortalSessionCreatedResponse(BaseModel):
    url: str = Field(..., title="URL")


class Audio(BaseModel):
    url: str = Field(..., description="The URL of the audio file")
    duration: float = Field(..., description="The duration of the audio file")
    transcript: str = Field(..., description="The transcript of the audio file")
    language: str = Field(..., description="The language of the audio file")


class AccountInfo(BaseModel):
    id: Optional[UUID] = Field(
        None, description="Unique identifier for the user account", title="ID"
    )
    name: Optional[str] = Field(
        None, description="The name of the user account", title="Name"
    )
    email: str = Field(..., title="Email")
    username: Optional[str] = Field(
        None, description="The username of the user account", title="Username"
    )
    created_at: Optional[datetime] = Field(
        None,
        description="Timestamp when the user account was created",
        title="Created At",
    )
    subscriptions: Optional[list[AccountSubscriptionInfo]] = Field(
        None,
        description="List of subscriptions for the user account",
        title="Subscriptions",
    )


class AgentMessageMetrics(BaseModel):
    __root__: TeamUsageInfo


class AgentMessageCitations(BaseModel):
    raw: Optional[Any] = Field(None, title="Raw")
    urls: Optional[list[UrlCitation]] = Field(None, title="Urls")
    documents: Optional[list[DocumentCitation]] = Field(None, title="Documents")


class TeamMessage(BaseModel):
    role: Role = Field(..., description="The role of the message sender")
    content: Optional[Union[str, list[dict[str, Any]]]] = Field(
        None,
        description="The content of the message. Can be a string or an array of content blocks.",
    )
    name: Optional[str] = Field(None, title="Name")
    tool_call_id: Optional[str] = Field(None, title="Tool Call Id")
    tool_calls: Optional[list[AgentMessageToolCall]] = Field(None, title="Tool Calls")
    thinking: Optional[str] = Field(None, title="Thinking")
    redacted_thinking: Optional[str] = Field(None, title="Redacted Thinking")
    provider_data: Optional[dict[str, Any]] = Field(None, title="Provider Data")
    citations: Optional[AgentMessageCitations] = None
    reasoning_content: Optional[str] = Field(None, title="Reasoning Content")
    tool_name: Optional[str] = Field(None, title="Tool Name")
    tool_args: Optional[dict[str, Any]] = Field(None, title="Tool Args")
    tool_call_error: Optional[bool] = Field(None, title="Tool Call Error")
    stop_after_tool_call: Optional[bool] = Field(False, title="Stop After Tool Call")
    add_to_agent_memory: Optional[bool] = Field(True, title="Add To Agent Memory")
    from_history: Optional[bool] = Field(False, title="From History")
    metrics: Optional[TeamUsageInfo] = None
    references: Optional[AgentMessageReferences] = None
    created_at: Optional[int] = Field(0, title="Created At")


class ChatCompletionUsage(AgentMessageMetrics):
    pass


class AccountUsageInfo(BaseModel):
    transactions: Optional[list[AccountUsageInfoItem]] = None


class AgentMessage(TeamMessage):
    pass


class ChatCompletionRequest(BaseModel):
    model: str = Field(
        ..., description="ID of the model to use for completion (e.g., gpt-3.5-turbo)."
    )
    messages: list[AgentMessage]
    temperature: Optional[float] = Field(1, description="Sampling temperature.")
    top_p: Optional[float] = Field(1, description="Nucleus sampling probability.")
    n: Optional[int] = Field(1, description="Number of completions to generate.")
    stream: Optional[bool] = Field(
        False,
        description="Whether to stream the response as events. If true, SSE should be used.",
    )
    stop: Optional[Union[str, list[str]]] = Field(
        None, description="Stop sequence(s) to halt generation."
    )
    max_tokens: Optional[int] = Field(
        None, description="Maximum tokens to generate in the completion."
    )
    presence_penalty: Optional[float] = 0
    frequency_penalty: Optional[float] = 0
    user: Optional[str] = Field(
        None, description="Optional user identifier (for auditing or context)."
    )


class Choice(BaseModel):
    index: Optional[int] = None
    message: Optional[AgentMessage] = None
    finish_reason: Optional[str] = Field(None, description="e.g. stop, length, etc.")


class ChatCompletionResponse(BaseModel):
    id: Optional[str] = Field(None, description="Unique ID for the completion.")
    object: Optional[str] = Field(None, example="chat.completion")
    created: Optional[int] = Field(
        None, description="Unix timestamp of completion creation."
    )
    model: Optional[str] = None
    choices: Optional[list[Choice]] = None
    usage: Optional[TeamUsageInfo] = None


class ToolCallStartedEvent(BaseModel):
    run_id: str = Field(..., description="The unique identifier for the run")
    content: Optional[str] = Field(None, description="The content of the tool call")
    content_type: str = Field(..., description="The type of content")
    event: Event1 = Field(..., description="The event type")
    model: Optional[str] = Field(None, description="The model used for the run")
    agent_id: Optional[str] = Field(
        None, description="The unique identifier for the agent"
    )
    session_id: str = Field(..., description="The unique identifier for the session")
    created_at: int = Field(
        ..., description="The timestamp when the tool call was started"
    )
    tools: Optional[list[ToolCall]] = None
    messages: Optional[list[AgentMessage]] = Field(
        None, description="Messages related to the tool call"
    )


class RunResponseEvent(BaseModel):
    run_id: str = Field(..., description="The unique identifier for the run")
    content: str = Field(..., description="The content of the response")
    content_type: str = Field(..., description="The type of content")
    event: str = Field(..., description="The event type")
    model: Optional[str] = Field(None, description="The model used for the run")
    agent_id: Optional[str] = Field(
        None, description="The unique identifier for the agent"
    )
    session_id: str = Field(..., description="The unique identifier for the session")
    created_at: int = Field(
        ..., description="The timestamp when the response was created"
    )
    messages: Optional[list[AgentMessage]] = Field(
        None, description="The messages associated with the run"
    )


class TeamRunResponse(BaseModel):
    event: Optional[str] = Field(None, description="The event type")
    content: Optional[str] = Field(None, description="The content of the response")
    content_type: Optional[str] = Field("str", description="The type of content")
    thinking: Optional[str] = Field(None, description="Thinking process of the team")
    messages: Optional[list[AgentMessage]] = Field(
        None, description="The messages associated with the run"
    )
    metrics: Optional[dict[str, Any]] = Field(
        None, description="Metrics related to the team run"
    )
    model: Optional[str] = Field(None, description="The model used for the run")
    member_responses: Optional[list[RunResponseEvent]] = Field(
        [], description="Responses from individual team members"
    )
    run_id: Optional[str] = Field(None, description="The unique identifier for the run")
    team_id: Optional[str] = Field(
        None, description="The unique identifier for the team"
    )
    session_id: Optional[str] = Field(
        None, description="The unique identifier for the session"
    )
    tools: Optional[list[dict[str, Any]]] = Field(
        None, description="Tools used in the team run"
    )
    formatted_tool_calls: Optional[list[str]] = Field(
        None, description="Formatted representation of tool calls"
    )
    images: Optional[list[Image]] = Field(
        None, description="Images generated from member runs"
    )
    videos: Optional[list[Video]] = Field(
        None, description="Videos generated from member runs"
    )
    audio: Optional[list[Audio]] = Field(
        None, description="Audio generated from member runs"
    )
    created_at: Optional[int] = Field(
        None, description="The timestamp when the response was created"
    )


class TeamRunRequest(BaseModel):
    messages: Optional[list[AgentMessage]] = Field(
        None,
        description="The messages to send to the team, can be a string, list, dict, or Message object\n",
    )
    stream: Optional[bool] = Field(False, description="Whether to stream the response")
    stream_intermediate_steps: Optional[bool] = Field(
        False, description="Whether to stream intermediate steps"
    )
    retries: Optional[int] = Field(
        None, description="Number of retries if the run fails"
    )
    audio: Optional[list[Audio]] = Field(
        None, description="Audio files to include with the request"
    )
    images: Optional[list[Image]] = Field(
        None, description="Images to include with the request"
    )
    videos: Optional[list[Video]] = Field(
        None, description="Videos to include with the request"
    )
    files: Optional[list[File]] = Field(
        None, description="Files to include with the request"
    )


class AgentCompletionRequest(BaseModel):
    id: Optional[str] = Field("simple", description="The id of the agent to use")
    model: Optional[str] = Field(
        "claude-3-7-sonnet-latest", description="The Claude model to use"
    )
    environment: AgentEnvironment = Field(..., description="The environment")
    tools: Optional[list[Toolkit]] = Field([], description="The tools to use")
    messages: list[AgentMessage] = Field(
        ..., description="The messages to send to the agent"
    )


class AgentCompletionResponse(BaseModel):
    messages: list[AgentMessage] = Field(
        ..., description="The messages received from the agent"
    )
    cost: Optional[CostSummary] = None


class AgentCompletionChunk(BaseModel):
    __root__: Union[
        RunStartedEvent, ToolCallStartedEvent, RunCompletedEvent, ToolCallCompletedEvent
    ]
