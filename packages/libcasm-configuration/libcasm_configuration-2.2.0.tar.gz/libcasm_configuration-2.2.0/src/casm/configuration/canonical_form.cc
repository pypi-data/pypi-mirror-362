#include "casm/configuration/canonical_form.hh"

#include "casm/crystallography/CanonicalForm.hh"
#include "casm/crystallography/Niggli.hh"

namespace CASM {
namespace config {

/// \brief Return true if supercell lattice is right-handed lattice in
///     canonical form
bool is_canonical(Supercell const &supercell) {
  if (!supercell.superlattice.superlattice().is_right_handed()) {
    return false;
  }
  return xtal::canonical::check(supercell.superlattice.superlattice(),
                                supercell.prim->sym_info.point_group->element);
}

/// \brief Return a shared supercell with right-handed lattice that compares
///     greater to all equivalents with respect to prim point group symmetry
///
/// The result, `canonical_supercell` satisfies for all `op` in
/// `supercell.prim->sym_info.point_group->element`:
///     canonical_supercell->superlattice.superlattice() >=
///         sym::copy_apply(op,
///         supercell.superlattice.superlattice()).make_right_handed()
std::shared_ptr<Supercell const> make_canonical_form(
    Supercell const &supercell) {
  Lattice superlattice = supercell.superlattice.superlattice();
  superlattice.make_right_handed();
  Lattice canonical_superlattice = xtal::canonical::equivalent(
      superlattice, supercell.prim->sym_info.point_group->element,
      superlattice.tol());
  return std::make_shared<Supercell const>(
      supercell.prim, xtal::Superlattice(supercell.superlattice.prim_lattice(),
                                         canonical_superlattice));
}

/// \brief Return the supercell with distinct symmetrically equivalent lattices
///
/// The results, `equiv`, are the distinct supercell with lattices generated by
/// `equiv = copy_apply(op, supercell.superlattice.lattice())` for `op` in
/// ``supercell.prim->sym_info.point_group->element`.
std::vector<std::shared_ptr<Supercell const>> make_equivalents(
    Supercell const &supercell) {
  std::set<Lattice> superlats;
  std::shared_ptr<Prim const> prim = supercell.prim;
  Lattice const &init_superlat = supercell.superlattice.superlattice();
  std::vector<SymOp> const &point_group = prim->sym_info.point_group->element;

  // function puts equivalent superlattice into canonical form
  auto representation_prepare = [&](Lattice superlat) {
    superlat.make_right_handed();
    std::vector<Index> invariant_subgroup_indices =
        xtal::invariant_subgroup_indices(superlat, point_group);
    std::vector<SymOp> invariant_subgroup;
    for (Index i : invariant_subgroup_indices) {
      invariant_subgroup.push_back(point_group[i]);
    }
    return xtal::canonical::equivalent(superlat, invariant_subgroup);
  };

  // generate different orientations of equivalent superlattices
  for (auto const &op : point_group) {
    superlats.emplace(
        representation_prepare(sym::copy_apply(op, init_superlat)));
  }

  // make as shared Supercell
  std::vector<std::shared_ptr<Supercell const>> result;
  for (Lattice const &superlat : superlats) {
    result.push_back(std::make_shared<Supercell const>(prim, superlat));
  }

  return result;
}

/// \brief Return true if the operation does not mix given sites and other sites
bool site_indices_are_invariant(SupercellSymOp const &op,
                                std::set<Index> const &site_indices) {
  // Applying the operation indicated by `op` moves the value from
  // site index `op.permute_index(s)` to site index `s`, for each `s` in
  // the set. Therefore, if none of `op.permute_index(s)` are outside the
  // set `site_indices` the sites are invariant.

  return std::none_of(site_indices.begin(), site_indices.end(), [&](Index s) {
    return site_indices.count(op.permute_index(s)) == 0;
  });
}

}  // namespace config
}  // namespace CASM
