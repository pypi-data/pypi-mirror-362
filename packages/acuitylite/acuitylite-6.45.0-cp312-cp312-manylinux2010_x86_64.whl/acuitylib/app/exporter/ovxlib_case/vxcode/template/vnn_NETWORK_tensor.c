/****************************************************************************
*   Generated by ACUITY #ACUITY_VERSION#
*   Match ovxlib #OVXLIB_VERSION#
*
*   Neural Network appliction network tensor definition source file#ENABLE_MLE#
****************************************************************************/
/*-------------------------------------------
                   Includes
 -------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>

#include "vsi_nn_pub.h"

#include "vnn_global.h"
#include "vnn_#NETWORK_NAME_LOWER#.h"
/*-------------------------------------------
                   Macros
 -------------------------------------------*/

#define NEW_VIRTUAL_TENSOR(_id, _attr, _dtype) do {\
        memset( _attr.size, 0, VSI_NN_MAX_DIM_NUM * sizeof(vsi_size_t));\
        _attr.dim_num = VSI_NN_DIM_AUTO;\
        _attr.vtl = !VNN_APP_DEBUG;\
        _attr.is_const = FALSE;\
        _attr.dtype.vx_type = _dtype;\
        _id = vsi_nn_AddTensor( graph, VSI_NN_TENSOR_ID_AUTO,\
                & _attr, NULL );\
        if( VSI_NN_TENSOR_ID_NA == _id ) {\
            goto error;\
        }\
    } while(0)

// Set const tensor dims out of this macro.
#define NEW_CONST_TENSOR(_id, _attr, _dtype, _ofst, _size) do {\
        data = load_data( fp, _ofst, _size  );\
        if( NULL == data ) {\
            goto error;\
        }\
        _attr.vtl = FALSE;\
        _attr.is_const = TRUE;\
        _attr.dtype.vx_type = _dtype;\
        _id = vsi_nn_AddTensor( graph, VSI_NN_TENSOR_ID_AUTO,\
                & _attr, data );\
        free( data );\
        if( VSI_NN_TENSOR_ID_NA == _id ) {\
            goto error;\
        }\
    } while(0)

// Set generic tensor dims out of this macro.
#define NEW_NORM_TENSOR(_id, _attr, _dtype) do {\
        _attr.vtl = FALSE;\
        _attr.is_const = FALSE;\
        _attr.dtype.vx_type = _dtype;\
        if ( enable_from_handle )\
        {\
            _id = vsi_nn_AddTensorFromHandle( graph, VSI_NN_TENSOR_ID_AUTO,\
                    & _attr, NULL );\
        }\
        else\
        {\
            _id = vsi_nn_AddTensor( graph, VSI_NN_TENSOR_ID_AUTO,\
                    & _attr, NULL );\
        }\
        if( VSI_NN_TENSOR_ID_NA == _id ) {\
            goto error;\
        }\
    } while(0)

// Set generic tensor dims out of this macro.
#define NEW_NORM_TENSOR_FROM_HANDLE(_id, _attr, _dtype) do {\
        _attr.vtl = FALSE;\
        _attr.is_const = FALSE;\
        _attr.dtype.vx_type = _dtype;\
        _id = vsi_nn_AddTensorFromHandle( graph, VSI_NN_TENSOR_ID_AUTO,\
                & _attr, NULL );\
        if( VSI_NN_TENSOR_ID_NA == _id ) {\
            goto error;\
        }\
    } while(0)

/*-------------------------------------------
               Local Variables
 -------------------------------------------*/

/*-------------------------------------------
                  Functions
 -------------------------------------------*/
static uint8_t* load_data
    (
    FILE  * fp,
    size_t  ofst,
    size_t  sz
    )
{
    uint8_t* data;
    ssize_t ret;
    size_t size;
    data = NULL;
    if( NULL == fp )
    {
        return NULL;
    }

    ret = VSI_FSEEK(fp, ofst, SEEK_SET);
    if (ret != 0)
    {
        VSILOGE("blob seek failure.");
        return NULL;
    }

    data = (uint8_t*)malloc(sz);
    if (data == NULL)
    {
        VSILOGE("buffer malloc failure.");
        return NULL;
    }
    size = fread(data, 1, sz, fp);
    if (size != sz || size == 0)
    {
        free(data);
        data = NULL;
        VSILOGE("Read file to buffer failed.");
    }
    return data;
} /* load_data() */

static float load_scale
(
    FILE* fp,
    size_t  ofst,
    size_t  sz
)
{
    uint8_t* data = load_data(fp, ofst, sz);
    float scale = *((float*)data);
    free(data);
    return scale;
} /* load_scale() */

static int32_t load_zero_point
(
    FILE* fp,
    size_t  ofst,
    size_t  sz
)
{
    uint8_t *data = load_data(fp, ofst, sz);
    int32_t zero_point = *((int32_t*)data);
    free(data);
    return zero_point;
} /* load_zero_point() */

static int8_t load_fl
(
    FILE* fp,
    size_t  ofst,
    size_t  sz
)
{
    uint8_t* data = load_data(fp, ofst, sz);
    int8_t fl = *((int8_t*)data);
    free(data);
    return fl;
} /* load_fl() */

static char* load_quant_param_from_stack
(
    int32_t*  local_buffer,
    size_t  sz
)
{
    char* p_data = malloc(sz);
    if (p_data == NULL)
    {
        VSILOGE("buffer malloc failure.");
        return NULL;
    }
    memcpy(p_data, local_buffer, sz);
    return p_data;
} /* load_quant_param_from_stack() */

void** vnn_Create#NETWORK_NAME#Tensor
    (
    const char * data_file_name,
    vsi_nn_graph_t *  graph,
    vsi_nn_node_t * node[],
    vsi_nn_tensor_id_t norm_tensor[],
    vsi_nn_tensor_id_t const_tensor[],
    vsi_bool inference_with_nbg
    )
{
    vsi_status              status = VSI_FAILURE;
    vsi_nn_tensor_attr_t    attr;
    FILE *                  fp = fopen( data_file_name, "rb" );
    uint8_t *               data;
    char *                  use_from_handle = NULL;
    int32_t                 enable_from_handle = 0;
    void**                  pp_scales_zps = NULL;

#ifdef VSI_GRAPH_RUNTIME_ENV_SUPPORT
    use_from_handle = vsi_nn_GetRunTimeVariable(graph, "VSI_USE_FROM_HANDLE" );
    if ( use_from_handle )
    {
        enable_from_handle = atoi(use_from_handle);
        vsi_nn_Free(use_from_handle);
        use_from_handle = NULL;
    }
#else
    use_from_handle = getenv( "VSI_USE_FROM_HANDLE" );
    if ( use_from_handle )
    {
        enable_from_handle = atoi(use_from_handle);
    }
#endif

    if( NULL == fp )
    {
        VSILOGE( "Open file %s failed.", data_file_name );
        goto error;
    }

#NET_MALLOC_SCALES_ZPS_POINTER_POINTER#
#NET_SCALES#
#NET_ZERO_POINTS#

    memset( &attr, 0, sizeof( attr ) );

/*-----------------------------------------
  Tensor initialize
 -----------------------------------------*/
    attr.dtype.fmt = VSI_NN_DIM_FMT_NCHW;
#NORM_TENSOR_INITIALIZER#
#NORM_VIEW_TENSOR_INITIALIZER#
if (!inference_with_nbg){
#CONST_TENSOR_INITIALIZER#
#VIRTUAL_TENSOR_INITIALIZER#
}

    if( NULL != fp )
    {
        fclose( fp );
    }
    return pp_scales_zps;

error:
    if( NULL != fp )
    {
        fclose( fp );
    }
    vnn_Release#NETWORK_NAME#TensorQuantParams(pp_scales_zps);
    return NULL;
} /* vsi_nn_Create#NETWORK_NAME#Tensor() */

void vnn_Release#NETWORK_NAME#TensorQuantParams
    (
    void ** pp_scales_zps
    )
{
    if( NULL != pp_scales_zps)
    {
        for(int i = 0; i < #SCALES_ZPS_POINTER_POINTER_COUNT#; i++)
        {
            if(NULL != pp_scales_zps)
            {
                free(pp_scales_zps[i]);
                pp_scales_zps[i] = NULL;
            }
        }
        free(pp_scales_zps);
        pp_scales_zps = NULL;
    }
} /* vsi_nn_Release#NETWORK_NAME#TensorQuantParams() */