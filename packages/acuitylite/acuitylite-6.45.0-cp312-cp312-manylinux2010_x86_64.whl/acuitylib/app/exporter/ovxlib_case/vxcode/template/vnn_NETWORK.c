/****************************************************************************
*   Generated by ACUITY #ACUITY_VERSION#
*   Match ovxlib #OVXLIB_VERSION#
*
*   Neural Network appliction network definition source file#ENABLE_MLE#
****************************************************************************/
/*-------------------------------------------
                   Includes
 -------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>

#include "vsi_nn_pub.h"

#include "vnn_global.h"
#include "vnn_#NETWORK_NAME_LOWER#.h"
#NETWORK_CLIENT_TAB_H#
/*-------------------------------------------
                   Macros
 -------------------------------------------*/

#define NEW_VXNODE(_node, _type, _in, _out, _uid) do {\
        _node = vsi_nn_AddNode( graph, _type, _in, _out, NULL );\
        if( NULL == _node ) {\
            goto error;\
        }\
        _node->uid = (uint32_t)_uid;\
    } while(0)

#define NET_NODE_NUM            (#NODE_NUM#)
#define NET_NORM_TENSOR_NUM     (#NORM_TENSOR_NUM#)
#define NET_CONST_TENSOR_NUM    (#CONST_TENSOR_NUM#)
#define NET_VIRTUAL_TENSOR_NUM  (#VIRTUAL_TENSOR_NUM#)
#define NET_TOTAL_TENSOR_NUM    (NET_NORM_TENSOR_NUM + NET_CONST_TENSOR_NUM + NET_VIRTUAL_TENSOR_NUM)

/*-------------------------------------------
               Local Variables
 -------------------------------------------*/

/*-------------------------------------------
                  Functions
 -------------------------------------------*/
vsi_nn_graph_t * vnn_Create#NETWORK_NAME#
    (
    const char * data_file_name,
    vsi_nn_context_t in_ctx,
    const vsi_nn_preprocess_map_element_t * pre_process_map,
    uint32_t pre_process_map_count,
    const vsi_nn_postprocess_map_element_t * post_process_map,
    uint32_t post_process_map_count
    )
{
    uint32_t                _infinity = VSI_NN_FLOAT32_INF;
    vsi_status              status;
    vsi_bool                release_ctx;
    vsi_nn_context_t        ctx;
    vsi_nn_graph_t *        graph;
    vsi_nn_node_t *         node[NET_NODE_NUM];
    #NORM_TENSOR_DEFINITION#
    #CONST_TENSOR_DEFINITION#
    vsi_nn_tensor_attr_t    attr;
    uint32_t                i = 0;
    char *                  use_img_process_s;
    int32_t                 enable_pre_post_process = 0;
    vsi_bool                sort = FALSE;
    vsi_bool                inference_with_nbg = FALSE;
    char*                   pos = NULL;
    void**                  pp_scales_zps = NULL;

#NET_ARRAY_PARAMETERS#

    (void)(_infinity);
    ctx = NULL;
    graph = NULL;
    status = VSI_FAILURE;
    memset( &attr, 0, sizeof( attr ) );
    memset( &node, 0, sizeof( vsi_nn_node_t * ) * NET_NODE_NUM );

    pos = strstr(data_file_name, ".nb");
    if( pos && strcmp(pos, ".nb") == 0 )
    {
        inference_with_nbg = TRUE;
    }

    if( NULL == in_ctx )
    {
        ctx = vsi_nn_CreateContext();
    }
    else
    {
        ctx = in_ctx;
    }


    graph = vsi_nn_CreateGraph( ctx, NET_TOTAL_TENSOR_NUM, NET_NODE_NUM );
    if( NULL == graph )
    {
        VSILOGE( "Create graph fail." );
        goto error;
    }

#ifdef VSI_GRAPH_RUNTIME_ENV_SUPPORT
    use_img_process_s = vsi_nn_GetRunTimeVariable(graph, "VSI_USE_IMAGE_PROCESS");
    if( use_img_process_s )
    {
        enable_pre_post_process = atoi(use_img_process_s);
        vsi_nn_Free(use_img_process_s);
        use_img_process_s = NULL;
    }
#else
    use_img_process_s = getenv("VSI_USE_IMAGE_PROCESS");
    if( use_img_process_s )
    {
        enable_pre_post_process = atoi(use_img_process_s);
    }
#endif

    vsi_nn_SetGraphVersion( graph, VNN_VERSION_MAJOR, VNN_VERSION_MINOR, VNN_VERSION_PATCH );
#SET_GRAPH_INPUTS#
    vsi_nn_SetGraphOutputs( graph, NULL, #NET_OUTPUT_NUM# );
    vsi_nn_SetGraphFastMode(graph,FALSE);

/*-----------------------------------------
  Register client ops
 -----------------------------------------*/
#NET_CLIENT_REGISTER_FUNC#

/*-----------------------------------------
  Node definitions
 -----------------------------------------*/
    if( !inference_with_nbg )
    {
#NODE_INITIALIZER#
    }
    else
    {
#NBG_NODE_INITIALIZER#
    }

/*-----------------------------------------
  Tensor initialize
 -----------------------------------------*/
    pp_scales_zps = vnn_Create#NETWORK_NAME#Tensor(data_file_name, graph, node, norm_tensor, const_tensor,
     inference_with_nbg);

/*-----------------------------------------
  Connection initialize
 -----------------------------------------*/
    if( !inference_with_nbg )
    {
#CONNECTIONS#
    }
    else
    {
#NBG_CONNECTIONS#
    }
#GRAPH_IO#

    if( enable_pre_post_process )
    {
        sort = TRUE;
        if( pre_process_map_count > 0 )
        {
            for( i = 0; i < pre_process_map_count; i++ )
            {
                status = vsi_nn_AddGraphPreProcess(graph, pre_process_map[i].graph_input_idx,
                                                   pre_process_map[i].preprocesses,
                                                   pre_process_map[i].preprocess_count);
                TEST_CHECK_STATUS( status, error );
            }
        }

        if( post_process_map_count > 0 )
        {
            for( i = 0; i < post_process_map_count; i++ )
            {
                 status = vsi_nn_AddGraphPostProcess(graph, post_process_map[i].graph_output_idx,
                                                     post_process_map[i].postprocesses,
                                                     post_process_map[i].postprocess_count);
                 TEST_CHECK_STATUS( status, error );
            }
        }
    }

    status = vsi_nn_SetupGraph( graph, sort );
    if( NULL != pp_scales_zps)
    {
        vnn_Release#NETWORK_NAME#TensorQuantParams(pp_scales_zps);
    }
    TEST_CHECK_STATUS( status, error );

#DUMP_GRAPH_JSON#

    if( VSI_FAILURE == status )
    {
        goto error;
    }

    return graph;

error:
    release_ctx = ( NULL == in_ctx );
    vsi_nn_DumpGraphToJson( graph );
    vnn_Release#NETWORK_NAME#( graph, release_ctx );

    return NULL;
} /* vsi_nn_Create#NETWORK_NAME#() */

void vnn_Release#NETWORK_NAME#
    (
    vsi_nn_graph_t * graph,
    vsi_bool release_ctx
    )
{
    vsi_nn_context_t ctx;
    if( NULL != graph )
    {
        ctx = graph->ctx;
        vsi_nn_ReleaseGraph( &graph );

        /*-----------------------------------------
        Unregister client ops
        -----------------------------------------*/
        #NET_CLIENT_UNREGISTER_FUNC#

        if( release_ctx )
        {
            vsi_nn_ReleaseContext( &ctx );
        }
    }
} /* vsi_nn_Release#NETWORK_NAME#() */

