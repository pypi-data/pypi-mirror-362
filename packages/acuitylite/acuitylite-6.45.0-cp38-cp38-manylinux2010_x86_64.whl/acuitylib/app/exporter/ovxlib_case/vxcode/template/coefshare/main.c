/****************************************************************************
*   Generated by #ACUITY_VERSION#
*   Match #OVXLIB_VERSION#
*
*   Neural Network application project entry file
****************************************************************************/
/*-------------------------------------------
                Includes
-------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef __linux__
#include <time.h>
#include <inttypes.h>
#elif defined(_WIN32)
#include <windows.h>
#endif

#define _BASETSD_H

#include "vsi_nn_pub.h"

#include "vnn_global.h"
#include "vnn_pre_process.h"
#include "vnn_post_process.h"
#NETWORK_HEADERS_INCLUDE#

/*-------------------------------------------
        Macros and Variables
-------------------------------------------*/
#ifdef __linux__
#define VSI_UINT64_SPECIFIER PRIu64
#elif defined(_WIN32)
#define VSI_UINT64_SPECIFIER "I64u"
#endif

/*-------------------------------------------
                  Functions
-------------------------------------------*/
static vsi_status vnn_PostProcessNeuralNetwork
    (
    vsi_nn_graph_t *graph, int32_t graph_index
    )
{
    return vnn_PostProcessCoefShare( graph, graph_index );
}

#define BILLION                                 1000000000
static uint64_t get_perf_count()
{
#if defined(__linux__) || defined(__ANDROID__) || defined(__QNX__) || defined(__CYGWIN__)
    struct timespec ts;

    clock_gettime(CLOCK_MONOTONIC, &ts);

    return (uint64_t)((uint64_t)ts.tv_nsec + (uint64_t)ts.tv_sec * BILLION);
#elif defined(_WIN32) || defined(UNDER_CE)
    LARGE_INTEGER freq;
    LARGE_INTEGER ln;

    QueryPerformanceFrequency(&freq);
    QueryPerformanceCounter(&ln);

    return (uint64_t)(ln.QuadPart * BILLION / freq.QuadPart);
#endif
}

static vsi_status vnn_VerifyGraph
    (
    vsi_nn_graph_t *graph
    )
{
    vsi_status status = VSI_FAILURE;
    uint64_t tmsStart, tmsEnd, msVal, usVal;

    /* Verify graph */
    printf("Verify...\n");
    tmsStart = get_perf_count();
    status = vsi_nn_VerifyGraph( graph );
    TEST_CHECK_STATUS(status, final);
    tmsEnd = get_perf_count();
    msVal = (tmsEnd - tmsStart)/1000000;
    usVal = (tmsEnd - tmsStart)/1000;
    printf("Verify Graph: %"VSI_UINT64_SPECIFIER"ms or %"VSI_UINT64_SPECIFIER"us\n", msVal, usVal);

final:
    return status;
}

static vsi_status vnn_ProcessGraph
    (
    vsi_nn_graph_t *graph
    )
{
    vsi_status status = VSI_FAILURE;
    int32_t i,loop;
    char *loop_s;
    uint64_t tmsStart, tmsEnd, sigStart, sigEnd;
    float msVal, usVal;

    status = VSI_FAILURE;
    loop = 1; /* default loop time is 1 */
    loop_s = getenv("VNN_LOOP_TIME");
    if(loop_s)
    {
        loop = atoi(loop_s);
    }

    /* Run graph */
    tmsStart = get_perf_count();
    printf("Start run graph [%d] times...\n", loop);
    for(i = 0; i < loop; i++)
    {
        sigStart = get_perf_count();
#ifdef VNN_APP_ASYNC_RUN
        status = vsi_nn_AsyncRunGraph( graph );
        if(status != VSI_SUCCESS)
        {
            printf("Async Run graph the %d time fail\n", i);
        }
        TEST_CHECK_STATUS( status, final );

        //do something here...

        status = vsi_nn_AsyncRunWait( graph );
        if(status != VSI_SUCCESS)
        {
            printf("Wait graph the %d time fail\n", i);
        }
#else
        status = vsi_nn_RunGraph( graph );
        if(status != VSI_SUCCESS)
        {
            printf("Run graph the %d time fail\n", i);
        }
#endif
        TEST_CHECK_STATUS( status, final );

        sigEnd = get_perf_count();
        msVal = (sigEnd - sigStart)/(float)1000000;
        usVal = (sigEnd - sigStart)/(float)1000;
        printf("Run the %u time: %.2fms or %.2fus\n", (i + 1), msVal, usVal);
    }
    tmsEnd = get_perf_count();
    msVal = (tmsEnd - tmsStart)/(float)1000000;
    usVal = (tmsEnd - tmsStart)/(float)1000;
    printf("vxProcessGraph execution time:\n");
    printf("Total   %.2fms or %.2fus\n", msVal, usVal);
    printf("Average %.2fms or %.2fus\n", ((float)usVal)/1000/loop, ((float)usVal)/loop);

final:
    return status;
}

static vsi_status vnn_PreProcessNeuralNetwork
    (
    vsi_nn_graph_t *graph,
    int argc,
    char **argv,
    int32_t graph_index
    )
{
    /*
     * argv0:   execute file
     * argv1:   data file
     * argv2~n: inputs n file
     */
    const char **inputs = (const char **)argv + 2;
    uint32_t input_num = argc - 2;

    return vnn_PreProcessCoefShare( graph, inputs, input_num, graph_index );
}

static void vnn_GetSplitEnv
    (
    env_item_t** split_env,
    uint32_t prefill_core_count,
    uint32_t decode_core_count
    )
{
    char env_value[100];
    char env_name[100] = {"VIV_VX_MULTIVIP_NN_CONFIG"};
    if(prefill_core_count > 1 && decode_core_count > 1) // split Z
    {
        int max_core_count = prefill_core_count > decode_core_count ?
                             prefill_core_count : decode_core_count;
        sprintf(env_value, "[0,10000:Z,%d]", max_core_count);
    }
    else if(prefill_core_count > 1 && decode_core_count == 1)
    {
        sprintf(env_value, "[0,10000:Y,%d]", prefill_core_count);
    }
    if(prefill_core_count > 1 || decode_core_count > 1)
    {
        *split_env = (env_item_t*)malloc(sizeof(env_item_t));
        (*split_env)->name = (char*)malloc(sizeof(char)* 100);
        (*split_env)->value = (char*)malloc(sizeof(char)* 100);
        memcpy((*split_env)->name, env_name, sizeof(char)*100);
        memcpy((*split_env)->value, env_value, sizeof(char)*100);
    }
}

static void vnn_ReleaseEnvItem
    (
      env_item_t** env
    )
{
    if(NULL != env && NULL != *env)
    {
        env_item_t* e = *env;
        if(e->name)
        {
           free(e->name);
           e->name = NULL;
        }
        if(e->value)
        {
           free(e->value);
           e->value= NULL;
        }
        free(e);
        *env = NULL;
    }
}

/*-------------------------------------------
                  Main Functions
-------------------------------------------*/
typedef void (*release_graph_func_t)
    (
    vsi_nn_graph_t * graph,
    vsi_bool release_ctx
    );

typedef vsi_nn_graph_t * (*create_graph_func_t)
    (
    const char * data_file_name,
    vsi_nn_context_t in_ctx,
    const env_item_t* envs, uint32_t env_count
    );

static struct {
    const char* data_file_name;
    create_graph_func_t create_graph_func;
    release_graph_func_t release_graph_func;
    uint32_t used_core_count;
    int graph_type;  /* 0 for prefill, 1 for decode */
    int argc;
    char* argv[20];
    env_item_t envs[100];
    }subgraph_configs[] = {#SUBGRAPH_CONFIGS#};

int main
    (
    int argc,
    char **argv
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_nn_graph_t *graph[_cnt_of_array(subgraph_configs)] = { NULL };
    int i = 0;
    vsi_nn_context_t ctx = NULL;
    env_item_t* split_env = NULL;
    int real_run_graphs = _cnt_of_array(subgraph_configs);
    char* graph_names[] = {#NB_NAMES#};

    if(argc > 1)
    {
        int graph_count_from_arg = atoi(argv[1]);
        if(graph_count_from_arg >= 0 && graph_count_from_arg <= real_run_graphs)
        {
            real_run_graphs = graph_count_from_arg;
        }
    }

    ctx = vsi_nn_CreateContext();

    #ifdef VSI_DEVICE_SUPPORT
    uint32_t device_count = 0;
    uint32_t available_core_count = 0;
    vsi_nn_device_t device[VSI_MAX_DEVICES] = { NULL };
    vsi_nn_device_t sub_devices[_cnt_of_array(subgraph_configs)] = { NULL };
    vsi_nn_GetDevices(ctx, &device[0], &device_count);
    vsi_nn_GetDeviceCoreCount(device[0], &available_core_count);
    /*Analyze split env*/
    uint32_t prefill_core_count = available_core_count;
    uint32_t decode_core_count = available_core_count;
    for(i = 0; i < real_run_graphs; i++)
    {
       uint32_t core_count = subgraph_configs[i].used_core_count;
       if(core_count == 0)
       {
           core_count = available_core_count;
       }
       if(subgraph_configs[i].graph_type == 0)
       {
          prefill_core_count = core_count;
       }
       else if(subgraph_configs[i].graph_type == 1)
       {
          decode_core_count = core_count;
       }
    }
    vnn_GetSplitEnv(&split_env, prefill_core_count, decode_core_count);
    #endif

    printf("========= Analyze Weights =========\n");
    for(i = 0; i < real_run_graphs; i++)
    {
        int cur_graph_index = i;
        int j = 0;
        uint32_t used_core_count = subgraph_configs[cur_graph_index].used_core_count;
        printf("============Start of Graph %d============\n", i);
        for(j = 0; j < _cnt_of_array(subgraph_configs[cur_graph_index].envs) &&
                subgraph_configs[cur_graph_index].envs[j].name; j++);
        if(split_env)
        {
           subgraph_configs[cur_graph_index].envs[j] = *split_env;
           j+=1;
        }
        graph[i] = subgraph_configs[cur_graph_index].create_graph_func(
            subgraph_configs[cur_graph_index].data_file_name,
            ctx,
            subgraph_configs[cur_graph_index].envs, j
            );
        TEST_CHECK_PTR( graph[i], final );
        #ifdef VSI_SET_GRAPH_REFNAME_CONTEXT_ATTR_SUPPORT
            vsi_nn_SetGraphReferenceName(graph[i], graph_names[i]);
        #else
            printf("%s\n", "set graph reference name fail, please update ovxlib version");
            TEST_CHECK_STATUS( VSI_FAILURE, final );
        #endif
        #ifdef VSI_DEVICE_SUPPORT
        if(used_core_count == 0)
        {
            used_core_count = available_core_count;
        }
        vsi_nn_CreateSubDevice(device[0], 0, used_core_count, &sub_devices[i]);
        vsi_nn_BindDevices(graph[i], 1, &sub_devices[i]);
        #endif
        /* Verify graph */
        status = vnn_VerifyGraph( graph[i] );
        TEST_CHECK_STATUS( status, final);

        if(graph[i]) {
            subgraph_configs[cur_graph_index].release_graph_func(graph[i], FALSE);
            graph[i] = NULL;
        }
        printf("============End of Graph %d============\n", i);
    }

    printf("========= Real Run =========\n");
    vsi_enum phase = 1;
    #ifdef VSI_SET_GRAPH_REFNAME_CONTEXT_ATTR_SUPPORT
        vsi_nn_SetContextAttribute(ctx, VX_CONTEXT_SHARE_WB_PHASE, &phase, sizeof(phase));
    #else
        printf("%s\n", "set context attribute fail, please update ovxlib version");
        TEST_CHECK_STATUS( VSI_FAILURE, final );
    #endif
    for(i = 0; i < real_run_graphs; i++)
    {
        int cur_graph_index = i;
        int j = 0;

        printf("============Start of Graph %d=============\n", i);
        for(j = 0; j < _cnt_of_array(subgraph_configs[cur_graph_index].envs) &&
              subgraph_configs[cur_graph_index].envs[j].name; j++);

        graph[i] = subgraph_configs[cur_graph_index].create_graph_func(
            subgraph_configs[cur_graph_index].data_file_name,
            ctx,
            subgraph_configs[cur_graph_index].envs, j
            );
        TEST_CHECK_PTR( graph[i], final );

        #ifdef VSI_SET_GRAPH_REFNAME_CONTEXT_ATTR_SUPPORT
            vsi_nn_SetGraphReferenceName(graph[i], graph_names[i]);
        #else
            printf("%s\n", "set graph reference name fail, please update ovxlib version");
            TEST_CHECK_STATUS( VSI_FAILURE, final );
        #endif
        #ifdef VSI_DEVICE_SUPPORT
            vsi_nn_BindDevices(graph[i], 1, &sub_devices[i]);
        #endif
        /* Verify graph */
        status = vnn_VerifyGraph( graph[i] );
        TEST_CHECK_STATUS( status, final);

        /* Pre process the image data */
        status = vnn_PreProcessNeuralNetwork( graph[i],
            subgraph_configs[cur_graph_index].argc,
            subgraph_configs[cur_graph_index].argv,
            i);
        TEST_CHECK_STATUS( status, final );

        /* Process graph */
        status = vnn_ProcessGraph( graph[i] );
        TEST_CHECK_STATUS( status, final );

        /* Post process output data */
        status = vnn_PostProcessNeuralNetwork( graph[i], i );
        TEST_CHECK_STATUS( status, final );

        if(graph[i])
        {
            subgraph_configs[cur_graph_index].release_graph_func(graph[i], FALSE);
            graph[i] = NULL;
        }
        #ifdef VSI_DEVICE_SUPPORT
        if(sub_devices[i])
        {
            vsi_nn_ReleaseDevice(&sub_devices[i]);
        }
        #endif
        printf("============End of Graph %d============\n", i);
    }

final:
    #ifdef VSI_DEVICE_SUPPORT
    for(i = 0; i < device_count; i++)
    {
        vsi_nn_ReleaseDevice(&device[i]);
    }
    #endif
    vnn_ReleaseEnvItem(&split_env);
    vsi_nn_ReleaseContext( &ctx );
    fflush(stdout);
    fflush(stderr);
    return status;
}
