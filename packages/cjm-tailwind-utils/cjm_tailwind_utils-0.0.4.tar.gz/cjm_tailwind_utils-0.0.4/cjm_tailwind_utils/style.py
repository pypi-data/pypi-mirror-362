"""Visual styling utilities for typography, backgrounds, borders, shadows, and effects. Depends on colors module for color validation."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/style.ipynb.

# %% auto 0
__all__ = []

# %% ../nbs/style.ipynb 3
from typing import Union, Literal, Optional, Tuple, Self

from .core import TailwindBuilder, patch, _spacing_class, _format_spacing_value
from .types import ColorValue, OpacityValue, SpacingValue
from .validation import InvalidValueError, InvalidColorError, validate_opacity_value
from .colors import normalize_color, validate_color_value, is_valid_color, HEX_PATTERN, RGB_PATTERN, HSL_PATTERN, VAR_PATTERN

# %% ../nbs/style.ipynb 6
@patch
def text(self:TailwindBuilder, 
         size: Optional[Union[Literal["xs", "sm", "base", "lg", "xl", "2xl", "3xl", "4xl", "5xl", "6xl", "7xl", "8xl", "9xl"], str]] = None,
         align: Optional[Literal["left", "center", "right", "justify", "start", "end"]] = None,
         weight: Optional[Literal["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"]] = None,
         color: Optional[Union[ColorValue, str]] = None) -> Union[str, Self]:
    """Generate text utility classes with color validation and arbitrary value support."""
    classes = []
    if size:
        if isinstance(size, str) and size not in ["xs", "sm", "base", "lg", "xl", "2xl", "3xl", "4xl", "5xl", "6xl", "7xl", "8xl", "9xl"]:
            # Check if it's an arbitrary value
            if any(unit in size for unit in ['px', 'em', 'rem', 'pt', 'vh', 'vw']):
                classes.append(f"text-[{size}]")
            else:
                classes.append(f"text-{size}")
        else:
            classes.append(f"text-{size}")
    if align:
        classes.append(f"text-{align}")
    if weight:
        classes.append(f"font-{weight}")
    if color:
        # Check if color already contains opacity (e.g., 'white/80')
        opacity = None
        if isinstance(color, str) and "/" in color:
            color_part, opacity_str = color.rsplit("/", 1)
            try:
                opacity = int(opacity_str)
                color = color_part
            except ValueError:
                # Not a valid opacity suffix, treat as regular color
                pass
        
        # Normalize the color value
        color = normalize_color(color)
        
        # Check if it's a valid Tailwind color or special color
        if is_valid_color(color) and not any(pattern.match(color) for pattern in [HEX_PATTERN, RGB_PATTERN, HSL_PATTERN, VAR_PATTERN]):
            text_class = f"text-{color}"
        # Check if it's an arbitrary color value
        elif isinstance(color, str) and (color.startswith('#') or color.startswith('rgb') or color.startswith('hsl') or color.startswith('var(')):
            text_class = f"text-[{color}]"
        else:
            # For any other string, assume it's a Tailwind color
            text_class = f"text-{color}"
        
        # Apply opacity if it was extracted
        if opacity is not None:
            text_class = f"{text_class}/{opacity}"
        
        classes.append(text_class)
    
    class_str = " ".join(classes)
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 7
@patch
def font(
    self:TailwindBuilder,
    family: Union[Literal["sans", "serif", "mono"], str]  # Font family type or arbitrary value
) -> Union[str, Self]:  # Font family utility class string or self for chaining
    """Generate font family utility class with arbitrary value support."""
    if family in ["sans", "serif", "mono"]:
        class_str = f"font-{family}"
    else:
        # Arbitrary font family
        class_str = f"font-[{family}]"
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 8
@patch
def leading(
    self:TailwindBuilder,
    value: Union[Literal["none", "tight", "snug", "normal", "relaxed", "loose"], int, str]  # Line height value or arbitrary value
) -> Union[str, Self]:  # Line-height utility class string or self for chaining
    """Generate line-height utility class with arbitrary value support."""
    if isinstance(value, str) and value not in ["none", "tight", "snug", "normal", "relaxed", "loose"]:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '.']) or value.replace('.', '').isdigit():
            class_str = f"leading-[{value}]"
        else:
            class_str = f"leading-{value}"
    else:
        class_str = f"leading-{value}"
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 9
@patch
def tracking(
    self:TailwindBuilder,
    value: Union[Literal["tighter", "tight", "normal", "wide", "wider", "widest"], str]  # Letter spacing value or arbitrary value
) -> Union[str, Self]:  # Letter-spacing utility class string or self for chaining
    """Generate letter-spacing utility class with arbitrary value support."""
    if value in ["tighter", "tight", "normal", "wide", "wider", "widest"]:
        class_str = f"tracking-{value}"
    else:
        # Arbitrary value
        class_str = f"tracking-[{value}]"
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 11
@patch
def bg(
    self:TailwindBuilder,
    color: Union[ColorValue, str],  # Background color value or arbitrary value
    opacity: Optional[OpacityValue] = None  # Optional opacity value (0-100)
) -> Union[str, Self]:  # Background color utility class string or self for chaining
    """Generate background color utility class with validation and arbitrary value support."""
    try:
        # Check if color already contains opacity (e.g., 'white/80')
        if isinstance(color, str) and "/" in color and opacity is None:
            color_part, opacity_str = color.rsplit("/", 1)
            try:
                opacity = int(opacity_str)
                color = color_part
            except ValueError:
                # Not a valid opacity suffix, treat as regular color
                pass
        
        # Validate opacity if provided
        if opacity is not None:
            validate_opacity_value(opacity)
        
        # Normalize the color value
        color = normalize_color(color)
        
        # Validate the color (allow opacity suffix for validation purposes)
        validate_color_value(color, allow_opacity_suffix=False)
        
        # Check if it's a valid Tailwind color or special color
        if is_valid_color(color) and not any(pattern.match(color) for pattern in [HEX_PATTERN, RGB_PATTERN, HSL_PATTERN, VAR_PATTERN]):
            base = f"bg-{color}"
        # Check if it's an arbitrary color value
        elif isinstance(color, str) and (color.startswith('#') or color.startswith('rgb') or color.startswith('hsl') or color.startswith('var(')):
            base = f"bg-[{color}]"
        else:
            # For any other string, assume it's a Tailwind color
            base = f"bg-{color}"
        
        # Apply opacity if provided
        if opacity is not None:
            class_str = f"{base}/{opacity}"
        else:
            class_str = base
            
        return self._return_value(class_str)
    except InvalidValueError:
        # Re-raise InvalidValueError as-is (for opacity errors)
        raise
    except InvalidColorError as e:
        # Add context to color errors
        raise InvalidColorError(f"Invalid background color: {e}")

# %% ../nbs/style.ipynb 13
@patch
def border(self:TailwindBuilder, 
           width: Optional[Union[Literal[0, 2, 4, 8], Literal[""], str]] = "",
           side: Optional[Literal["t", "r", "b", "l", "x", "y"]] = None,
           color: Optional[Union[ColorValue, str]] = None,  # Border color value or arbitrary value
           style: Optional[Literal["solid", "dashed", "dotted", "double", "hidden", "none"]] = None) -> Union[str, Self]:
    """Generate border utility classes with color validation and arbitrary value support."""
    classes = []
    
    # Border width
    border_prefix = f"border{'-' + side if side else ''}"
    if width == "":
        classes.append(border_prefix)
    elif isinstance(width, str) and width not in ["0", "2", "4", "8"]:
        # Arbitrary width value
        classes.append(f"{border_prefix}-[{width}]")
    else:
        classes.append(f"{border_prefix}-{width}")
    
    # Border color
    if color:
        # Check if color already contains opacity (e.g., 'red-300/50')
        opacity = None
        if isinstance(color, str) and "/" in color:
            color_part, opacity_str = color.rsplit("/", 1)
            try:
                opacity = int(opacity_str)
                color = color_part
            except ValueError:
                # Not a valid opacity suffix, treat as regular color
                pass
        
        # Normalize the color value
        color = normalize_color(color)
        
        # Check if it's a valid Tailwind color or special color
        if is_valid_color(color) and not any(pattern.match(color) for pattern in [HEX_PATTERN, RGB_PATTERN, HSL_PATTERN, VAR_PATTERN]):
            border_class = f"border-{color}"
        # Check if it's an arbitrary color value
        elif isinstance(color, str) and (color.startswith('#') or color.startswith('rgb') or color.startswith('hsl') or color.startswith('var(')):
            border_class = f"border-[{color}]"
        else:
            # For any other string, assume it's a Tailwind color
            border_class = f"border-{color}"
        
        # Apply opacity if it was extracted
        if opacity is not None:
            border_class = f"{border_class}/{opacity}"
        
        classes.append(border_class)
    
    # Border style
    if style:
        classes.append(f"border-{style}")
    
    class_str = " ".join(classes)
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 14
@patch
def rounded(self:TailwindBuilder, 
            size: Optional[Union[Literal["none", "sm", "", "md", "lg", "xl", "2xl", "3xl", "full"], str]] = "",
            side: Optional[Literal["t", "r", "b", "l", "tl", "tr", "br", "bl"]] = None) -> Union[str, Self]:
    """Generate border-radius utility class with arbitrary value support."""
    prefix = f"rounded{'-' + side if side else ''}"
    if size == "":
        class_str = prefix
    elif size in ["none", "sm", "md", "lg", "xl", "2xl", "3xl", "full"]:
        class_str = f"{prefix}-{size}"
    else:
        # Arbitrary value
        class_str = f"{prefix}-[{size}]"
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 16
@patch
def shadow(
    self:TailwindBuilder,
    size: Optional[Union[Literal["sm", "", "md", "lg", "xl", "2xl", "inner", "none"], str]] = ""  # Shadow size or arbitrary value
) -> Union[str, Self]:  # Box-shadow utility class string or self for chaining
    """Generate box-shadow utility class with arbitrary value support."""
    if size == "":
        class_str = "shadow"
    elif size in ["sm", "md", "lg", "xl", "2xl", "inner", "none"]:
        class_str = f"shadow-{size}"
    else:
        # Arbitrary shadow value
        class_str = f"shadow-[{size}]"
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 18
@patch
def opacity(
    self:TailwindBuilder,
    value: Union[OpacityValue, int, float, str]  # Opacity value or arbitrary value
) -> Union[str, Self]:  # Opacity utility class string or self for chaining
    """Generate opacity utility class with arbitrary value support."""
    if value in [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100]:
        class_str = f"opacity-{value}"
    else:
        # Arbitrary opacity value
        class_str = f"opacity-[{value}]"
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 20
@patch
def overflow(self:TailwindBuilder, 
             value: Literal["auto", "hidden", "clip", "visible", "scroll"],
             axis: Optional[Literal["x", "y"]] = None) -> Union[str, Self]:
    """Generate overflow utility class."""
    if axis:
        class_str = f"overflow-{axis}-{value}"
    else:
        class_str = f"overflow-{value}"
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 22
@patch
def object(self:TailwindBuilder, 
           fit: Optional[Literal["contain", "cover", "fill", "none", "scale-down"]] = None,
           position: Optional[Union[Literal["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], str]] = None) -> Union[str, Self]:
    """Generate object-fit and object-position utility classes with arbitrary value support."""
    classes = []
    if fit:
        classes.append(f"object-{fit}")
    if position:
        if position in ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"]:
            classes.append(f"object-{position}")
        else:
            # Arbitrary position value
            classes.append(f"object-[{position}]")
    class_str = " ".join(classes)
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 24
@patch
def cursor(
    self:TailwindBuilder,
    value: Union[Literal["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out"], str]  # Cursor type or arbitrary value
) -> Union[str, Self]:  # Cursor utility class string or self for chaining
    """Generate cursor utility class with arbitrary value support."""
    if value in ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out"]:
        class_str = f"cursor-{value}"
    else:
        # Arbitrary cursor value
        class_str = f"cursor-[{value}]"
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 26
@patch
def transition(self:TailwindBuilder, 
               property: Optional[Literal["none", "all", "", "colors", "opacity", "shadow", "transform"]] = "",
               duration: Optional[Union[Literal[75, 100, 150, 200, 300, 500, 700, 1000], int, str]] = None,
               timing: Optional[Union[Literal["linear", "in", "out", "in-out"], str]] = None,
               delay: Optional[Union[int, str]] = None) -> Union[str, Self]:
    """Generate transition utility classes with arbitrary value support."""
    classes = []
    
    if property == "":
        classes.append("transition")
    else:
        classes.append(f"transition-{property}")
    
    if duration:
        if duration in [75, 100, 150, 200, 300, 500, 700, 1000]:
            classes.append(f"duration-{duration}")
        else:
            # Arbitrary duration
            classes.append(f"duration-[{duration}]")
    
    if timing:
        if timing in ["linear", "in", "out", "in-out"]:
            classes.append(f"ease-{timing}")
        else:
            # Arbitrary timing function
            classes.append(f"ease-[{timing}]")
    
    if delay:
        if isinstance(delay, int) and delay in [75, 100, 150, 200, 300, 500, 700, 1000]:
            classes.append(f"delay-{delay}")
        else:
            # Arbitrary delay
            classes.append(f"delay-[{delay}]")
    
    class_str = " ".join(classes)
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 27
@patch
def animate(
    self:TailwindBuilder,
    value: Union[Literal["none", "spin", "ping", "pulse", "bounce"], str]  # Animation type or arbitrary value
) -> Union[str, Self]:  # Animation utility class string or self for chaining
    """Generate animation utility class with arbitrary value support."""
    if value in ["none", "spin", "ping", "pulse", "bounce"]:
        class_str = f"animate-{value}"
    else:
        # Arbitrary animation
        class_str = f"animate-[{value}]"
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 29
@patch
def transform(self:TailwindBuilder, 
              scale: Optional[Union[Literal[0, 50, 75, 90, 95, 100, 105, 110, 125, 150], Tuple[Literal["x", "y"], Union[Literal[0, 50, 75, 90, 95, 100, 105, 110, 125, 150], str]], str]] = None,
              rotate: Optional[Union[Literal[0, 1, 2, 3, 6, 12, 45, 90, 180], Literal["-1", "-2", "-3", "-6", "-12", "-45", "-90", "-180"], str]] = None,
              translate: Optional[Union[Tuple[Literal["x", "y"], Union[SpacingValue, str, Tuple[Union[SpacingValue, str], bool]]], str]] = None) -> Union[str, Self]:
    "Generate transform utility classes with arbitrary value support and negative translate."
    classes = ["transform"]
    
    if scale is not None:
        if isinstance(scale, tuple):
            axis, value = scale
            if isinstance(value, str) and value not in [0, 50, 75, 90, 95, 100, 105, 110, 125, 150]:
                classes.append(f"scale-{axis}-[{value}]")
            else:
                classes.append(f"scale-{axis}-{value}")
        elif isinstance(scale, str):
            classes.append(f"scale-[{scale}]")
        else:
            classes.append(f"scale-{scale}")
    
    if rotate is not None:
        if isinstance(rotate, str) and rotate not in ["0", "1", "2", "3", "6", "12", "45", "90", "180", "-1", "-2", "-3", "-6", "-12", "-45", "-90", "-180"]:
            classes.append(f"rotate-[{rotate}]")
        else:
            classes.append(f"rotate-{rotate}")
    
    if translate:
        if isinstance(translate, str):
            # Single arbitrary translate value
            classes.append(f"translate-[{translate}]")
        else:
            axis, value_spec = translate
            
            # Check if negative is specified
            if isinstance(value_spec, tuple):
                value, negative = value_spec
                is_negative = negative
            else:
                value = value_spec
                is_negative = False
                
            # Check if value is already negative
            if isinstance(value, (int, float)) and value < 0:
                is_negative = True
                value = abs(value)
            
            prefix = f"translate-{axis}"
            if is_negative:
                prefix = f"-{prefix}"
                
            if isinstance(value, str) and not value in ["px", "auto", "full"]:
                # Check if it's an arbitrary value
                if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
                    classes.append(f"{prefix}-[{value}]")
                else:
                    classes.append(f"{prefix}-{_format_spacing_value(value)}")
            else:
                classes.append(f"{prefix}-{_format_spacing_value(value)}")
    
    class_str = " ".join(classes)
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 31
@patch
def container(
    self:TailwindBuilder,
    center: bool = True,  # Whether to center the container with mx-auto
    padding: Optional[SpacingValue] = None  # Optional padding to add
) -> Union[str, Self]:  # Container utility classes string or self for chaining
    """Generate container utility classes."""
    classes = ["container"]
    if center:
        classes.append("mx-auto")
    if padding is not None:
        classes.append(self._spacing_class("p", padding))
    class_str = " ".join(classes)
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 32
@patch
def stack(
    self:TailwindBuilder,
    gap: SpacingValue = 4  # Gap between stacked items
) -> Union[str, Self]:  # Flex stack utility classes string or self for chaining
    """Generate flex stack utility classes."""
    class_str = f"flex flex-col {self._spacing_class('gap', gap)}"
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 33
@patch
def center(
    self:TailwindBuilder,
    method: Literal["flex", "grid", "absolute"] = "flex"  # Centering method to use
) -> Union[str, Self]:  # Centering utility classes string or self for chaining
    """Generate centering utility classes."""
    if method == "flex":
        class_str = "flex items-center justify-center"
    elif method == "grid":
        class_str = "grid place-items-center"
    elif method == "absolute":
        class_str = "absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2"
    else:
        class_str = ""
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 34
@patch
def prose(
    self:TailwindBuilder,
    size: Optional[Literal["sm", "", "lg", "xl", "2xl"]] = ""  # Prose size variant
) -> Union[str, Self]:  # Prose utility classes string or self for chaining
    """Generate prose (typography) utility classes."""
    class_str = "prose" if size == "" else f"prose prose-{size}"
    return self._return_value(class_str)

# %% ../nbs/style.ipynb 35
@patch
def sr_only(
    self:TailwindBuilder
) -> Union[str, Self]:  # Screen reader only class string or self for chaining
    """Generate screen reader only utility class."""
    return self._return_value("sr-only")

# %% ../nbs/style.ipynb 36
@patch
def not_sr_only(
    self:TailwindBuilder
) -> Union[str, Self]:  # Not screen reader only class string or self for chaining
    """Generate not screen reader only utility class."""
    return self._return_value("not-sr-only")
