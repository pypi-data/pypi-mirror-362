# cjm-tailwind-utils


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

### Installation

``` sh
$ pip install cjm_tailwind_utils
```

## Project Structure

    nbs/
    ├── colors.ipynb             # Color system - needed for most daisyUI components
    ├── core.ipynb               # Essential foundation that's always needed
    ├── examples.ipynb           # Reference examples - not loaded for production
    ├── layout.ipynb             # Core layout utilities for daisyUI components
    ├── modern.ipynb             # Tailwind v4 features - load only if needed
    ├── style.ipynb              # Visual styling utilities
    ├── types.ipynb              # Type definitions - import when needed for type hints
    ├── validation.ipynb         # Validation & error handling - import only when implementing new utilities
    └── variants.ipynb           # State and responsive variants

Total: 10 notebooks

## Module Dependencies

``` mermaid
graph LR
    colors[colors<br/>Colors]
    core[core<br/>Core]
    examples[examples<br/>Practical Usage Examples]
    layout[layout<br/>Layout]
    modern[modern<br/>Modern]
    style[style<br/>Style]
    types[types<br/>Type Definitions]
    validation[validation<br/>Validation]
    variants[variants<br/>Variants]

    colors --> validation
    colors --> types
    core --> types
    core --> validation
    examples --> validation
    examples --> variants
    examples --> core
    examples --> modern
    examples --> colors
    examples --> layout
    examples --> style
    layout --> core
    layout --> types
    layout --> validation
    modern --> core
    style --> core
    style --> types
    style --> colors
    style --> validation
    variants --> core

    classDef default fill:#f9f9f9,stroke:#333,stroke-width:2px
```

*20 cross-module dependencies detected*

## CLI Reference

No CLI commands found in this project.

## Module Overview

Detailed documentation for each module in the project:

### Colors (`colors.ipynb`)

> Color system - needed for most daisyUI components

#### Import

``` python
from cjm_tailwind_utils.colors import (
    TAILWIND_COLORS,
    SPECIAL_COLORS,
    HEX_PATTERN,
    RGB_PATTERN,
    HSL_PATTERN,
    VAR_PATTERN,
    is_valid_color,
    normalize_color,
    validate_color_value,
    color_with_opacity,
    make_color
)
```

#### Functions

``` python
def is_valid_color(
    color: str  # Color string to validate
) -> bool:  # True if valid color, False otherwise
    "Validate if a string is a valid color value. Valid colors include: - Tailwind color names (with or without shade) - Special color keywords - Hex colors (#RGB, #RRGGBB, #RRGGBBAA) - RGB/RGBA functions - HSL/HSLA functions - CSS variables"
```

``` python
def normalize_color(
    color: str  # Color string to normalize
) -> str:  # Normalized color string
    "Normalize color value for use in Tailwind classes. This function handles: - Standard Tailwind colors (returns as-is) - CSS color functions (ensures proper formatting) - CSS variables (ensures proper formatting)"
```

``` python
def validate_color_value(
    color: str,  # The color value to validate
    allow_opacity_suffix: bool = False  # Whether to allow opacity suffix like 'white/80'
) -> None:  # TODO: Add return description
    "Validate a color value using the is_valid_color function."
```

``` python
def color_with_opacity(
    color: str,  # Base color value
    opacity: Optional[OpacityValue] = None  # Optional opacity value (0-100)
) -> str:  # Color string with opacity modifier if provided
    "Generate color string with optional opacity modifier."
```

``` python
def make_color(
    base: BaseColor,  # Base color name
    shade: ColorShade  # Color shade value
) -> str:  # Complete color string (e.g., "blue-500")
    "Create a color string from base color and shade."
```

#### Variables

``` python
TAILWIND_COLORS: Dict[str, Set[int]]
SPECIAL_COLORS: Set[str]
HEX_PATTERN  # ([0-9a-fA-F]{3}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$') # CSS Hex color format patterns
RGB_PATTERN  # CSS RGB color format patterns
HSL_PATTERN  # CSS HSL color format patterns
VAR_PATTERN  # CSS VAR color format patterns
```

### Core (`core.ipynb`)

> Essential foundation that’s always needed

#### Import

``` python
from cjm_tailwind_utils.core import (
    tw,
    TailwindBuilder
)
```

#### Functions

``` python
@patch
def arbitrary(
    self:TailwindBuilder,
    prefix: str,  # CSS utility prefix (e.g., 'p', 'w', 'text')
    value: str,  # Arbitrary value (e.g., '23px', '#1da1f2', 'calc(100%-1rem)')
    suffix: Optional[str] = None  # Optional suffix (e.g., for p-[20px]/50)
) -> Union[str, Self]:  # Arbitrary value utility class string or self for chaining
    """
    Generate arbitrary value utility class.
    
    Examples:
        tw.arbitrary('w', '23px')  # Returns 'w-[23px]'
        tw.arbitrary('bg', '#1da1f2')  # Returns 'bg-[#1da1f2]'
        tw.arbitrary('p', '20px', '50')  # Returns 'p-[20px]/50'
    """
```

``` python
@patch
def util(
    self:TailwindBuilder,
    *classes: str  # Raw Tailwind utility classes to add
) -> Union[str, Self]:  # Utility classes string or self for chaining
    """
    Add raw Tailwind utility classes without validation.
    
    This method allows adding any Tailwind utility classes directly,
    useful for custom utilities, newer Tailwind features, or third-party plugins.
    
    Args:
        *classes: One or more Tailwind utility class strings
        
    Returns:
        Combined utility classes string or self for chaining
        
    Examples:
        tw.util('backdrop-blur-sm')  # Returns 'backdrop-blur-sm'
        tw.util('animate-fade-in', 'will-change-transform')  # Returns 'animate-fade-in will-change-transform'
        tw.chain().util('custom-utility').p(4)  # Chainable
    """
```

``` python
@patch
def add_class(
    self:TailwindBuilder,
    class_str: str  # TODO: Add description
) -> Self:  # TODO: Add return description
    "Add arbitrary class string (only available in chain mode)."
```

``` python
@patch
def build(
    self:TailwindBuilder
) -> str:  # TODO: Add return description
    "Build and return the final class string (only available in chain mode)."
```

``` python
@patch
def __str__(
    self:TailwindBuilder
) -> str:  # TODO: Add return description
    "String representation."
```

``` python
@patch
def __repr__(
    self:TailwindBuilder
) -> str:  # TODO: Add return description
    "Representation."
```

``` python
@patch
def merge(
    self:TailwindBuilder,
    *class_strings: str,
    dedupe: bool = True  # Whether to deduplicate conflicting classes (default: True)
) -> str:  # Merged class string
    "Merge multiple class strings into one, with optional deduplication. This is a utility method that doesn't require chain mode."
```

``` python
@patch
def chain(self:TailwindBuilder, *classes: str, dedupe: bool = True) -> Self:  # Chainable TailwindBuilder instance
    """Create a chainable builder instance with optional starting classes.
    
    Args:
        *classes: Optional initial classes to add
        dedupe: Whether to deduplicate conflicting classes (default: True)
        
    Returns:
        A new chainable TailwindBuilder instance
    """
    builder = TailwindBuilder(_chain_mode=True, dedupe=dedupe)
    if classes
    """
    Create a chainable builder instance with optional starting classes.
    
    Args:
        *classes: Optional initial classes to add
        dedupe: Whether to deduplicate conflicting classes (default: True)
        
    Returns:
        A new chainable TailwindBuilder instance
    """
```

``` python
@patch
def _spacing_class(
    self:TailwindBuilder,
    prefix: str,  # CSS class prefix (e.g., 'p', 'mx', 'gap')
    value: Union[SpacingValue, str]  # Spacing value to format
) -> str:  # Complete CSS class string
    "Build spacing utility class."
```

``` python
@patch
def _size_class(
    self:TailwindBuilder,
    prefix: str,  # CSS class prefix (e.g., 'w', 'h', 'max-w')
    value: Union[SizeValue, str]  # Size value to format
) -> str:  # Complete CSS class string
    "Build size utility class."
```

``` python
def _format_spacing_value(
    value: SpacingValue  # Spacing value to format (numeric or string)
) -> str:  # Formatted string for CSS class name
    "Format spacing value for class name."
```

#### Classes

``` python
class TailwindBuilder:
    def __init__(
        self,
        _chain_mode: bool = False,  # TODO: Add description
        dedupe: bool = True  # TODO: Add description
    )
    """
    Dynamic Tailwind CSS utility class builder with full type safety and chainable API.
    
    This builder provides methods for generating Tailwind utility classes with proper type hints
    and validation. It supports both direct string returns and chainable fluent API.
    
    Usage:
        tw.p(4)  # Returns "p-4" 
        tw.chain().p(4).bg("blue-500")  # Returns chainable builder
    """
    
    def __init__(
            self,
            _chain_mode: bool = False,  # TODO: Add description
            dedupe: bool = True  # TODO: Add description
        )
        "Initialize builder.

Args:
    _chain_mode: Internal flag for chainable mode
    dedupe: Whether to deduplicate conflicting classes (default: True)"
```

#### Variables

``` python
tw  # Global instance of TailwindBuilder for convenience
```

### Layout (`layout.ipynb`)

> Core layout utilities for daisyUI components

#### Import

``` python
from cjm_tailwind_utils.layout import *
```

#### Functions

``` python
@patch
def p(
    self:TailwindBuilder,
    value: Union[SpacingValue, str],  # Spacing value or arbitrary value string
    side: Optional[Literal["t", "r", "b", "l", "x", "y"]] = None  # Optional side specification
) -> Union[str, Self]:  # Padding utility class string or self for chaining
    "Generate padding utility class with arbitrary value support and validation."
```

``` python
@patch
def m(
    self:TailwindBuilder,
    value: Union[SpacingValue, str],  # Spacing value or arbitrary value string
    side: Optional[Literal["t", "r", "b", "l", "x", "y"]] = None,  # Optional side specification
    negative: bool = False  # Whether to apply negative value
) -> Union[str, Self]:  # Margin utility class string or self for chaining
    """
    Generate margin utility class with arbitrary value support, validation, and negative values.
    
    Args:
        value: Spacing value or arbitrary value string
        side: Optional side specification ('t', 'r', 'b', 'l', 'x', 'y')
        negative: Whether to apply negative margin (default: False)
        
    Returns:
        Margin utility class string or self for chaining
        
    Examples:
        tw.m(4)  # 'm-4'
        tw.m(4, negative=True)  # '-m-4'
        tw.m(4, 'x', negative=True)  # '-mx-4'
    """
```

``` python
@patch
def gap(
    self:TailwindBuilder,
    value: Union[SpacingValue, str],  # Spacing value or arbitrary value string
    axis: Optional[Literal["x", "y"]] = None  # Optional axis specification
) -> Union[str, Self]:  # Gap utility class string or self for chaining
    "Generate gap utility class with arbitrary value support."
```

``` python
@patch
def space(
    self:TailwindBuilder,
    value: Union[SpacingValue, str],  # Spacing value or arbitrary value string
    axis: Literal["x", "y"]  # Axis for spacing
) -> Union[str, Self]:  # Space utility class string or self for chaining
    "Generate space between utility class with arbitrary value support."
```

``` python
@patch
def w(
    self:TailwindBuilder,
    value: Union[SizeValue, str],  # Size value or arbitrary value string
    important: bool = False  # Whether to add !important modifier
) -> Union[str, Self]:  # Width utility class string or self for chaining
    "Generate width utility class with arbitrary value support."
```

``` python
@patch
def h(
    self:TailwindBuilder,
    value: Union[SizeValue, str],  # Size value or arbitrary value string
    important: bool = False  # Whether to add !important modifier
) -> Union[str, Self]:  # Height utility class string or self for chaining
    "Generate height utility class with arbitrary value support."
```

``` python
@patch
def size(
    self:TailwindBuilder,
    value: Union[SizeValue, str]  # Size value or arbitrary value string
) -> Union[str, Self]:  # Size utility class string or self for chaining
    "Generate size utility class (sets both width and height) with arbitrary value support."
```

``` python
@patch
def min_w(
    self:TailwindBuilder,
    value: Union[SizeValue, str]  # Size value or arbitrary value string
) -> Union[str, Self]:  # Min-width utility class string or self for chaining
    "Generate min-width utility class with arbitrary value support."
```

``` python
@patch
def max_w(
    self:TailwindBuilder,
    value: Union[SizeValue, str, Literal["xs", "sm", "md", "lg", "xl", "2xl", "3xl", "4xl", "5xl", "6xl", "7xl", "prose"]]  # Size value, arbitrary value, or named size
) -> Union[str, Self]:  # Max-width utility class string or self for chaining
    "Generate max-width utility class with arbitrary value support."
```

``` python
@patch
def min_h(
    self:TailwindBuilder,
    value: Union[SizeValue, str]  # Size value or arbitrary value string
) -> Union[str, Self]:  # Min-height utility class string or self for chaining
    "Generate min-height utility class with arbitrary value support."
```

``` python
@patch
def max_h(
    self:TailwindBuilder,
    value: Union[SizeValue, str]  # Size value or arbitrary value string
) -> Union[str, Self]:  # Max-height utility class string or self for chaining
    "Generate max-height utility class with arbitrary value support."
```

``` python
@patch
def position(
    self:TailwindBuilder,
    value: Literal["static", "fixed", "absolute", "relative", "sticky"]  # Position type
) -> Union[str, Self]:  # Position utility class string or self for chaining
    "Generate position utility class."
```

``` python
@patch
def inset(
    self:TailwindBuilder,
    value: Union[SpacingValue, str],  # Inset value or arbitrary value string
    side: Optional[Literal["top", "right", "bottom", "left", "x", "y"]] = None,  # Optional side specification
    negative: bool = False  # Whether to apply negative value
) -> Union[str, Self]:  # Inset utility class string or self for chaining
    """
    Generate inset (top/right/bottom/left) utility class with arbitrary value support and negative values.
    
    Args:
        value: Inset value or arbitrary value string
        side: Optional side specification ('top', 'right', 'bottom', 'left', 'x', 'y')
        negative: Whether to apply negative inset (default: False)
        
    Returns:
        Inset utility class string or self for chaining
        
    Examples:
        tw.inset(4)  # 'inset-4'
        tw.inset(4, 'top')  # 'top-4'
        tw.inset(4, 'x', negative=True)  # '-inset-x-4'
    """
```

``` python
@patch
def z(
    self:TailwindBuilder,
    value: Union[ZIndexValue, int, str]  # Z-index value, integer, or arbitrary value string
) -> Union[str, Self]:  # Z-index utility class string or self for chaining
    "Generate z-index utility class with arbitrary value support."
```

``` python
@patch
def display(
    self:TailwindBuilder,
    value: Literal["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"]  # Display type
) -> Union[str, Self]:  # Display utility class string or self for chaining
    "Generate display utility class."
```

``` python
@patch
def flex(self:TailwindBuilder, 
         direction: Optional[Literal["row", "row-reverse", "col", "col-reverse"]] = None,
         wrap: Optional[Literal["wrap", "wrap-reverse", "nowrap"]] = None,
         grow: Optional[Literal[0, 1]] = None,
         shrink: Optional[Literal[0, 1]] = None,
         basis: Optional[Union[SizeValue, str]] = None) -> Union[str, Self]
    "Generate flex utility classes with arbitrary value support."
```

``` python
@patch
def items(
    self:TailwindBuilder,
    value: Literal["start", "end", "center", "baseline", "stretch"]  # Alignment value for flex/grid items
) -> Union[str, Self]:  # Align-items utility class string or self for chaining
    "Generate align-items utility class."
```

``` python
@patch
def justify(
    self:TailwindBuilder,
    value: Literal["normal", "start", "end", "center", "between", "around", "evenly", "stretch"]  # Justify-content value
) -> Union[str, Self]:  # Justify-content utility class string or self for chaining
    "Generate justify-content utility class."
```

``` python
@patch
def align(
    self:TailwindBuilder,
    value: Literal["auto", "start", "end", "center", "stretch", "baseline"]  # Align-self value
) -> Union[str, Self]:  # Align-self utility class string or self for chaining
    "Generate align-self utility class."
```

``` python
@patch
def grid(self:TailwindBuilder, 
         cols: Optional[Union[int, Literal["none"], str]] = None,
         rows: Optional[Union[int, Literal["none"], str]] = None,
         flow: Optional[Literal["row", "col", "dense", "row-dense", "col-dense"]] = None) -> Union[str, Self]
    "Generate grid utility classes with arbitrary value support."
```

``` python
@patch
def col(
    self:TailwindBuilder,
    span: Union[int, Literal["auto", "full"]],  # Number of columns to span or keyword
    start: Optional[int] = None  # Starting column number
) -> Union[str, Self]:  # Grid column utility class string or self for chaining
    "Generate grid column utility classes."
```

``` python
@patch
def row(
    self:TailwindBuilder,
    span: Union[int, Literal["auto", "full"]],  # Number of rows to span or keyword
    start: Optional[int] = None  # Starting row number
) -> Union[str, Self]:  # Grid row utility class string or self for chaining
    "Generate grid row utility classes."
```

### Modern (`modern.ipynb`)

> Tailwind v4 features - load only if needed

#### Import

``` python
from cjm_tailwind_utils.modern import *
```

#### Functions

``` python
@patch
def container_query(
    self:TailwindBuilder,
    name: Optional[str] = None  # Optional container name
) -> Union[str, Self]:  # Container query class string or self for chaining
    """
    Add container query support for container queries.
    
    Examples:
        tw.container_query()  # @container
        tw.container_query('sidebar')  # @container/sidebar
    """
```

``` python
@patch
def cq(
    self:TailwindBuilder,
    size: Union[str, int],  # Container size (e.g., 'sm', 'md', '300px', 20)
    *classes: str  # Classes to apply at container size
) -> Union[str, Self]:  # Container query classes string or self for chaining
    """
    Add container query size variant to classes.
    
    Examples:
        tw.cq('md', 'flex', 'gap-4')  # @md:flex @md:gap-4
        tw.cq('300px', 'grid-cols-2')  # @[300px]:grid-cols-2
        tw.cq(20, 'text-lg')  # @[20rem]:text-lg (numeric values treated as rem)
    """
```

``` python
@patch
def has(
    self:TailwindBuilder,
    selector: str,  # Selector to check for (e.g., 'hover', '[disabled]')
    *classes: str  # Classes to apply when selector matches
) -> Union[str, Self]:  # Has pseudo-class classes string or self for chaining
    """
    Add :has() pseudo-class support.
    
    Examples:
        tw.has('[disabled]', 'opacity-50')  # has-[[disabled]]:opacity-50
        tw.has('hover', 'shadow-lg')  # has-[hover]:shadow-lg
    """
```

``` python
@patch
def supports(
    self:TailwindBuilder,
    feature: str,  # CSS feature to check support for
    *classes: str  # Classes to apply when feature is supported
) -> Union[str, Self]:  # Feature query classes string or self for chaining
    """
    Add @supports feature query support.
    
    Examples:
        tw.supports('grid', 'grid', 'grid-cols-3')  # supports-[grid]:grid supports-[grid]:grid-cols-3
        tw.supports('backdrop-filter', 'backdrop-blur-sm')
    """
```

``` python
@patch
def data(
    self:TailwindBuilder,
    attribute: str,  # Data attribute to check (without data- prefix)
    value: Optional[str] = None,  # Optional value to match
    *classes: str  # Classes to apply when data attribute matches
) -> Union[str, Self]:  # Data attribute classes string or self for chaining
    """
    Add data attribute selector support.
    
    Examples:
        tw.data('open', None, 'block')  # data-[open]:block
        tw.data('state', 'active', 'bg-blue-500')  # data-[state=active]:bg-blue-500
    """
```

### Style (`style.ipynb`)

> Visual styling utilities

#### Import

``` python
from cjm_tailwind_utils.style import *
```

#### Functions

``` python
@patch
def text(self:TailwindBuilder, 
         size: Optional[Union[Literal["xs", "sm", "base", "lg", "xl", "2xl", "3xl", "4xl", "5xl", "6xl", "7xl", "8xl", "9xl"], str]] = None,
         align: Optional[Literal["left", "center", "right", "justify", "start", "end"]] = None,
         weight: Optional[Literal["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"]] = None,
         color: Optional[Union[ColorValue, str]] = None) -> Union[str, Self]
    "Generate text utility classes with color validation and arbitrary value support."
```

``` python
@patch
def font(
    self:TailwindBuilder,
    family: Union[Literal["sans", "serif", "mono"], str]  # Font family type or arbitrary value
) -> Union[str, Self]:  # Font family utility class string or self for chaining
    "Generate font family utility class with arbitrary value support."
```

``` python
@patch
def leading(
    self:TailwindBuilder,
    value: Union[Literal["none", "tight", "snug", "normal", "relaxed", "loose"], int, str]  # Line height value or arbitrary value
) -> Union[str, Self]:  # Line-height utility class string or self for chaining
    "Generate line-height utility class with arbitrary value support."
```

``` python
@patch
def tracking(
    self:TailwindBuilder,
    value: Union[Literal["tighter", "tight", "normal", "wide", "wider", "widest"], str]  # Letter spacing value or arbitrary value
) -> Union[str, Self]:  # Letter-spacing utility class string or self for chaining
    "Generate letter-spacing utility class with arbitrary value support."
```

``` python
@patch
def bg(
    self:TailwindBuilder,
    color: Union[ColorValue, str],  # Background color value or arbitrary value
    opacity: Optional[OpacityValue] = None  # Optional opacity value (0-100)
) -> Union[str, Self]:  # Background color utility class string or self for chaining
    "Generate background color utility class with validation and arbitrary value support."
```

``` python
@patch
def border(self:TailwindBuilder, 
           width: Optional[Union[Literal[0, 2, 4, 8], Literal[""], str]] = "",
           side: Optional[Literal["t", "r", "b", "l", "x", "y"]] = None,
           color: Optional[Union[ColorValue, str]] = None,  # Border color value or arbitrary value
           style: Optional[Literal["solid", "dashed", "dotted", "double", "hidden", "none"]] = None) -> Union[str, Self]
    "Generate border utility classes with color validation and arbitrary value support."
```

``` python
@patch
def rounded(self:TailwindBuilder, 
            size: Optional[Union[Literal["none", "sm", "", "md", "lg", "xl", "2xl", "3xl", "full"], str]] = "",
            side: Optional[Literal["t", "r", "b", "l", "tl", "tr", "br", "bl"]] = None) -> Union[str, Self]
    "Generate border-radius utility class with arbitrary value support."
```

``` python
@patch
def shadow(
    self:TailwindBuilder,
    size: Optional[Union[Literal["sm", "", "md", "lg", "xl", "2xl", "inner", "none"], str]] = ""  # Shadow size or arbitrary value
) -> Union[str, Self]:  # Box-shadow utility class string or self for chaining
    "Generate box-shadow utility class with arbitrary value support."
```

``` python
@patch
def opacity(
    self:TailwindBuilder,
    value: Union[OpacityValue, int, float, str]  # Opacity value or arbitrary value
) -> Union[str, Self]:  # Opacity utility class string or self for chaining
    "Generate opacity utility class with arbitrary value support."
```

``` python
@patch
def overflow(self:TailwindBuilder, 
             value: Literal["auto", "hidden", "clip", "visible", "scroll"],
             axis: Optional[Literal["x", "y"]] = None) -> Union[str, Self]
    "Generate overflow utility class."
```

``` python
@patch
def object(self:TailwindBuilder, 
           fit: Optional[Literal["contain", "cover", "fill", "none", "scale-down"]] = None,
           position: Optional[Union[Literal["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], str]] = None) -> Union[str, Self]
    "Generate object-fit and object-position utility classes with arbitrary value support."
```

``` python
@patch
def cursor(
    self:TailwindBuilder,
    value: Union[Literal["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out"], str]  # Cursor type or arbitrary value
) -> Union[str, Self]:  # Cursor utility class string or self for chaining
    "Generate cursor utility class with arbitrary value support."
```

``` python
@patch
def transition(self:TailwindBuilder, 
               property: Optional[Literal["none", "all", "", "colors", "opacity", "shadow", "transform"]] = "",
               duration: Optional[Union[Literal[75, 100, 150, 200, 300, 500, 700, 1000], int, str]] = None,
               timing: Optional[Union[Literal["linear", "in", "out", "in-out"], str]] = None,
               delay: Optional[Union[int, str]] = None) -> Union[str, Self]
    "Generate transition utility classes with arbitrary value support."
```

``` python
@patch
def animate(
    self:TailwindBuilder,
    value: Union[Literal["none", "spin", "ping", "pulse", "bounce"], str]  # Animation type or arbitrary value
) -> Union[str, Self]:  # Animation utility class string or self for chaining
    "Generate animation utility class with arbitrary value support."
```

``` python
@patch
def transform(self:TailwindBuilder, 
              scale: Optional[Union[Literal[0, 50, 75, 90, 95, 100, 105, 110, 125, 150], Tuple[Literal["x", "y"], Union[Literal[0, 50, 75, 90, 95, 100, 105, 110, 125, 150], str]], str]] = None,
              rotate: Optional[Union[Literal[0, 1, 2, 3, 6, 12, 45, 90, 180], Literal["-1", "-2", "-3", "-6", "-12", "-45", "-90", "-180"], str]] = None,
              translate: Optional[Union[Tuple[Literal["x", "y"], Union[SpacingValue, str, Tuple[Union[SpacingValue, str], bool]]], str]] = None) -> Union[str, Self]
    "Generate transform utility classes with arbitrary value support and negative translate."
```

``` python
@patch
def container(
    self:TailwindBuilder,
    center: bool = True,  # Whether to center the container with mx-auto
    padding: Optional[SpacingValue] = None  # Optional padding to add
) -> Union[str, Self]:  # Container utility classes string or self for chaining
    "Generate container utility classes."
```

``` python
@patch
def stack(
    self:TailwindBuilder,
    gap: SpacingValue = 4  # Gap between stacked items
) -> Union[str, Self]:  # Flex stack utility classes string or self for chaining
    "Generate flex stack utility classes."
```

``` python
@patch
def center(
    self:TailwindBuilder,
    method: Literal["flex", "grid", "absolute"] = "flex"  # Centering method to use
) -> Union[str, Self]:  # Centering utility classes string or self for chaining
    "Generate centering utility classes."
```

``` python
@patch
def prose(
    self:TailwindBuilder,
    size: Optional[Literal["sm", "", "lg", "xl", "2xl"]] = ""  # Prose size variant
) -> Union[str, Self]:  # Prose utility classes string or self for chaining
    "Generate prose (typography) utility classes."
```

``` python
@patch
def sr_only(
    self:TailwindBuilder
) -> Union[str, Self]:  # Screen reader only class string or self for chaining
    "Generate screen reader only utility class."
```

``` python
@patch
def not_sr_only(
    self:TailwindBuilder
) -> Union[str, Self]:  # Not screen reader only class string or self for chaining
    "Generate not screen reader only utility class."
```

### Type Definitions (`types.ipynb`)

> Type definitions - import when needed for type hints

#### Import

``` python
from cjm_tailwind_utils.types import (
    SpacingValue,
    FractionValue,
    SizeValue,
    OpacityValue,
    ZIndexValue,
    BaseColor,
    ColorShade,
    SpecialColor,
    ColorValue
)
```

#### Variables

``` python
FractionValue  # Fraction values
SizeValue  # Common size values
OpacityValue  # Color opacity values
ZIndexValue  # Z-index values
ColorShade  # Standard color shade values
```

### Validation (`validation.ipynb`)

> Validation & error handling - import only when implementing new
> utilities

#### Import

``` python
from cjm_tailwind_utils.validation import (
    VALID_SPACING_VALUES,
    VALID_SPACING_STRINGS,
    CONFLICTING_GROUPS,
    TailwindBuilderError,
    InvalidValueError,
    InvalidColorError,
    ChainModeError,
    validate_spacing_value,
    validate_opacity_value,
    extract_modifiers,
    extract_class_prefix,
    get_conflicting_group,
    should_replace_class
)
```

#### Functions

``` python
def validate_spacing_value(
    value: Any,  # The value to validate
    allow_negative: bool = False  # Whether to allow negative values
) -> None:  # TODO: Add return description
    "Validate a spacing value."
```

``` python
def validate_opacity_value(
    value: Any  # The opacity value to validate
) -> None:  # TODO: Add return description
    "Validate an opacity value."
```

``` python
def extract_modifiers(
    class_str: str  # TODO: Add description
) -> Tuple[str, str]:  # Tuple of (modifiers, base_class) where modifiers is like 'hover:dark:' or ''
    "Extract modifiers and base class from a utility class."
```

``` python
def extract_class_prefix(
    class_str: str  # TODO: Add description
) -> str:  # TODO: Add return description
    """
    Extract the prefix from a utility class.
    
    Examples:
        'p-4' -> 'p'
        'hover:bg-blue-500' -> 'bg'
        'sm:p-4' -> 'p'
        'dark:hover:text-white' -> 'text'
        'px-6' -> 'px'
    """
```

``` python
def get_conflicting_group(
    prefix: str  # TODO: Add description
) -> Optional[str]:  # TODO: Add return description
    """
    Get the conflicting group for a given prefix.
    
    Returns the group name if the prefix belongs to a conflicting group,
    None otherwise.
    """
```

``` python
def should_replace_class(
    existing_class: str,  # TODO: Add description
    new_class: str  # TODO: Add description
) -> bool:  # TODO: Add return description
    """
    Determine if new_class should replace existing_class.
    
    Returns True if they belong to the same conflicting group and should be replaced.
    """
```

#### Classes

``` python
class TailwindBuilderError(Exception):
    "Base exception for TailwindBuilder errors."
```

``` python
class InvalidValueError(TailwindBuilderError):
    "Raised when an invalid value is provided to a utility method."
```

``` python
class InvalidColorError(TailwindBuilderError):
    "Raised when an invalid color value is provided."
```

``` python
class ChainModeError(TailwindBuilderError):
    "Raised when chain-mode specific methods are called in direct mode."
```

#### Variables

``` python
VALID_SPACING_VALUES
VALID_SPACING_STRINGS  # Valid spacing strings
CONFLICTING_GROUPS: Dict[str, Tuple[str, ...]]
```

### Variants (`variants.ipynb`)

> State and responsive variants

#### Import

``` python
from cjm_tailwind_utils.variants import *
```

#### Functions

``` python
@patch
def hover(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # Hover state classes string or self for chaining
    "Add hover state variant to classes."
```

``` python
@patch
def focus(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # Focus state classes string or self for chaining
    "Add focus state variant to classes."
```

``` python
@patch
def active(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # Active state classes string or self for chaining
    "Add active state variant to classes."
```

``` python
@patch
def disabled(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # Disabled state classes string or self for chaining
    "Add disabled state variant to classes."
```

``` python
@patch
def sm(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # Small screen responsive classes string or self for chaining
    "Add small screen variant to classes."
```

``` python
@patch
def md(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # Medium screen responsive classes string or self for chaining
    "Add medium screen variant to classes."
```

``` python
@patch
def lg(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # Large screen responsive classes string or self for chaining
    "Add large screen variant to classes."
```

``` python
@patch
def xl(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # Extra large screen responsive classes string or self for chaining
    "Add extra large screen variant to classes."
```

``` python
@patch
def xxl(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # 2XL screen responsive classes string or self for chaining
    "Add 2xl screen variant to classes."
```

``` python
@patch
def dark(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # Dark mode classes string or self for chaining
    "Add dark mode variant to classes."
```

``` python
@patch
def group_hover(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # Group hover classes string or self for chaining
    "Add group-hover variant to classes."
```

``` python
@patch
def peer_hover(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # Peer hover classes string or self for chaining
    "Add peer-hover variant to classes."
```

``` python
@patch
def modifiers(
    self:TailwindBuilder,
    *modifiers: str,
    classes: Union[str, List[str]]
) -> Union[str, Self]:  # Modified classes string or self for chaining
    """
    Apply multiple modifiers to classes with support for stacking.
    
    Examples:
        tw.modifiers('dark', 'hover', classes='bg-blue-500')  # dark:hover:bg-blue-500
        tw.modifiers('sm', 'dark', classes=['bg-white', 'text-black'])
        tw.modifiers('group-hover', 'lg', classes=tw.bg('blue-500'))
    """
```

``` python
@patch
def first(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # First child classes string or self for chaining
    "Add first-child variant to classes."
```

``` python
@patch
def last(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # Last child classes string or self for chaining
    "Add last-child variant to classes."
```

``` python
@patch
def even(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # Even child classes string or self for chaining
    "Add even-child variant to classes."
```

``` python
@patch
def odd(
    self:TailwindBuilder,
    *classes: str
) -> Union[str, Self]:  # Odd child classes string or self for chaining
    "Add odd-child variant to classes."
```

``` python
@patch
def group(
    self:TailwindBuilder
) -> Union[str, Self]:  # Group class string or self for chaining
    "Add group class for group-hover and similar variants."
```

``` python
@patch
def peer(
    self:TailwindBuilder
) -> Union[str, Self]:  # Peer class string or self for chaining
    "Add peer class for peer-hover and similar variants."
```
