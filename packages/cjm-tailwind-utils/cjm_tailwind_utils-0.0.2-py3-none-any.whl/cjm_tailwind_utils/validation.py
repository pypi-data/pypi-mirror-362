"""Validation & error handling - import only when implementing new utilities"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/validation.ipynb.

# %% auto 0
__all__ = ['VALID_SPACING_VALUES', 'VALID_SPACING_STRINGS', 'CONFLICTING_GROUPS', 'TailwindBuilderError', 'InvalidValueError',
           'InvalidColorError', 'ChainModeError', 'validate_spacing_value', 'validate_opacity_value',
           'extract_modifiers', 'extract_class_prefix', 'get_conflicting_group', 'should_replace_class']

# %% ../nbs/validation.ipynb 3
import re
from typing import Any, Dict, Optional, Tuple

# %% ../nbs/validation.ipynb 4
class TailwindBuilderError(Exception):
    """Base exception for TailwindBuilder errors."""
    pass

# %% ../nbs/validation.ipynb 5
class InvalidValueError(TailwindBuilderError):
    """Raised when an invalid value is provided to a utility method."""
    pass

# %% ../nbs/validation.ipynb 6
class InvalidColorError(TailwindBuilderError):
    """Raised when an invalid color value is provided."""
    pass

# %% ../nbs/validation.ipynb 7
class ChainModeError(TailwindBuilderError):
    """Raised when chain-mode specific methods are called in direct mode."""
    pass

# %% ../nbs/validation.ipynb 8
VALID_SPACING_VALUES = {  # Valid spacing values including decimals
    0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 
    18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 
    56, 58, 60, 62, 64, 68, 72, 76, 80, 84, 88, 92, 96
}

# %% ../nbs/validation.ipynb 9
VALID_SPACING_STRINGS = {"px", "auto", "full"} # Valid spacing strings

# %% ../nbs/validation.ipynb 10
def validate_spacing_value(
    value: Any,  # The value to validate
    allow_negative: bool = False  # Whether to allow negative values
) -> None:  # TODO: Add return description
    "Validate a spacing value."
    if isinstance(value, (int, float)):
        abs_value = abs(value) if allow_negative else value
        if abs_value not in VALID_SPACING_VALUES:
            raise InvalidValueError(
                f"Invalid spacing value: {value}. "
                f"Must be one of: {sorted(VALID_SPACING_VALUES)} or {VALID_SPACING_STRINGS}"
            )
    elif isinstance(value, str):
        if value not in VALID_SPACING_STRINGS:
            # Check if it's an arbitrary value
            if not any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
                raise InvalidValueError(
                    f"Invalid spacing value: '{value}'. "
                    f"Must be one of: {sorted(VALID_SPACING_VALUES)}, {VALID_SPACING_STRINGS}, "
                    f"or an arbitrary value with units (e.g., '1.5rem', 'calc(100% - 20px)')"
                )
    else:
        raise InvalidValueError(f"Spacing value must be a number or string, got {type(value).__name__}")

# %% ../nbs/validation.ipynb 11
def validate_opacity_value(
    value: Any  # The opacity value to validate
) -> None:  # TODO: Add return description
    "Validate an opacity value."
    valid_values = {0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100}
    
    if isinstance(value, (int, float)):
        if value not in valid_values and not (0 <= value <= 100):
            raise InvalidValueError(
                f"Invalid opacity value: {value}. "
                f"Must be one of: {sorted(valid_values)} or between 0-100"
            )
    else:
        raise InvalidValueError(f"Opacity value must be a number, got {type(value).__name__}")

# %% ../nbs/validation.ipynb 12
CONFLICTING_GROUPS: Dict[str, Tuple[str, ...]] = { # Utility groups that conflict with each other
    'padding': ('p', 'px', 'py', 'pt', 'pr', 'pb', 'pl'),
    'margin': ('m', 'mx', 'my', 'mt', 'mr', 'mb', 'ml'),
    'width': ('w',),
    'height': ('h',),
    'min-width': ('min-w',),
    'max-width': ('max-w',),
    'min-height': ('min-h',),
    'max-height': ('max-h',),
    'background': ('bg',),
    'text-color': ('text',),
    'border-color': ('border',),
    'border-width': ('border', 'border-t', 'border-r', 'border-b', 'border-l', 'border-x', 'border-y'),
    'display': ('block', 'inline-block', 'inline', 'flex', 'inline-flex', 'table', 'grid', 'hidden'),
    'position': ('static', 'fixed', 'absolute', 'relative', 'sticky'),
    'rounded': ('rounded', 'rounded-t', 'rounded-r', 'rounded-b', 'rounded-l', 'rounded-tl', 'rounded-tr', 'rounded-br', 'rounded-bl'),
    'shadow': ('shadow',),
    'opacity': ('opacity',),
    'z-index': ('z',),
}

# %% ../nbs/validation.ipynb 13
def extract_modifiers(
    class_str: str  # TODO: Add description
) -> Tuple[str, str]:  # Tuple of (modifiers, base_class) where modifiers is like 'hover:dark:' or ''
    "Extract modifiers and base class from a utility class."
    parts = class_str.split(':')
    if len(parts) == 1:
        return '', class_str
    
    modifiers = ':'.join(parts[:-1]) + ':'
    base_class = parts[-1]
    return modifiers, base_class

# %% ../nbs/validation.ipynb 14
def extract_class_prefix(
    class_str: str  # TODO: Add description
) -> str:  # TODO: Add return description
    """Extract the prefix from a utility class.
    
    Examples:
        'p-4' -> 'p'
        'hover:bg-blue-500' -> 'bg'
        'sm:p-4' -> 'p'
        'dark:hover:text-white' -> 'text'
        'px-6' -> 'px'
    """
    # Remove all modifiers (hover:, sm:, etc.)
    _, base_class = extract_modifiers(class_str)
    
    # Handle arbitrary values
    if '[' in base_class:
        match = re.match(r'^([a-z-]+)-\[', base_class)
        if match:
            return match.group(1)
    
    # Special handling for padding/margin directional variants
    if base_class.startswith(('px-', 'py-', 'pt-', 'pr-', 'pb-', 'pl-',
                             'mx-', 'my-', 'mt-', 'mr-', 'mb-', 'ml-')):
        return base_class.split('-')[0]
    
    # Extract prefix from regular classes
    if '-' in base_class:
        return base_class.split('-')[0]
    
    # Return full class for non-hyphenated utilities
    return base_class

# %% ../nbs/validation.ipynb 15
def get_conflicting_group(
    prefix: str  # TODO: Add description
) -> Optional[str]:  # TODO: Add return description
    """Get the conflicting group for a given prefix.
    
    Returns the group name if the prefix belongs to a conflicting group,
    None otherwise.
    """
    for group_name, prefixes in CONFLICTING_GROUPS.items():
        if prefix in prefixes:
            return group_name
    return None

# %% ../nbs/validation.ipynb 16
def should_replace_class(
    existing_class: str,  # TODO: Add description
    new_class: str  # TODO: Add description
) -> bool:  # TODO: Add return description
    """Determine if new_class should replace existing_class.
    
    Returns True if they belong to the same conflicting group and should be replaced.
    """
    # Extract modifiers first
    existing_modifiers, existing_base = extract_modifiers(existing_class)
    new_modifiers, new_base = extract_modifiers(new_class)
    
    # Classes with different modifiers never conflict
    if existing_modifiers != new_modifiers:
        return False
    
    existing_prefix = extract_class_prefix(existing_class)
    new_prefix = extract_class_prefix(new_class)
    
    # Check if they belong to the same conflicting group
    existing_group = get_conflicting_group(existing_prefix)
    new_group = get_conflicting_group(new_prefix)
    
    if existing_group and new_group and existing_group == new_group:
        # Special handling for padding/margin groups
        if existing_group in ['padding', 'margin']:
            general_prefix = existing_group[0]  # 'p' for padding, 'm' for margin
            
            # Same prefix always replaces
            if existing_prefix == new_prefix:
                return True
                
            # General utility (p/m) only replaces other general utilities
            if new_prefix == general_prefix:
                return existing_prefix == general_prefix
                
            # Specific utilities replace other specific utilities of the same type
            # but not general utilities or other specific types
            return False
        
        # For other groups, same group means replacement
        return True
    
    # Special case for color utilities with the same prefix
    if existing_prefix == new_prefix and existing_prefix in ['bg', 'text', 'border']:
        return True
    
    return False
