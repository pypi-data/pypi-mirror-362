"""Layout utilities for spacing (padding, margin), sizing (width, height), positioning, flexbox, and grid. Essential for component structure and spacing."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/layout.ipynb.

# %% auto 0
__all__ = []

# %% ../nbs/layout.ipynb 3
from typing import Union, Literal, Optional, Self

from .core import TailwindBuilder, patch, _spacing_class, _size_class
from .types import SpacingValue, SizeValue, ZIndexValue

from .validation import InvalidValueError, validate_spacing_value

# %% ../nbs/layout.ipynb 6
@patch
def p(
    self:TailwindBuilder,
    value: Union[SpacingValue, str],  # Spacing value or arbitrary value string
    side: Optional[Literal["t", "r", "b", "l", "x", "y"]] = None  # Optional side specification
) -> Union[str, Self]:  # Padding utility class string or self for chaining
    """Generate padding utility class with arbitrary value support and validation."""
    try:
        # Validate the value
        validate_spacing_value(value)
        
        prefix = f"p{side}" if side else "p"
        if isinstance(value, str) and not value in ["px", "auto", "full"]:
            # Check if it's an arbitrary value (contains units or special chars)
            if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
                class_str = f"{prefix}-[{value}]"
                return self._return_value(class_str)
        class_str = self._spacing_class(prefix, value)
        return self._return_value(class_str)
    except InvalidValueError as e:
        raise InvalidValueError(f"Invalid padding value: {e}")

# %% ../nbs/layout.ipynb 7
@patch
def m(
    self:TailwindBuilder,
    value: Union[SpacingValue, str],  # Spacing value or arbitrary value string
    side: Optional[Literal["t", "r", "b", "l", "x", "y"]] = None,  # Optional side specification
    negative: bool = False  # Whether to apply negative value
) -> Union[str, Self]:  # Margin utility class string or self for chaining
    """Generate margin utility class with arbitrary value support, validation, and negative values.
    
    Args:
        value: Spacing value or arbitrary value string
        side: Optional side specification ('t', 'r', 'b', 'l', 'x', 'y')
        negative: Whether to apply negative margin (default: False)
        
    Returns:
        Margin utility class string or self for chaining
        
    Examples:
        tw.m(4)  # 'm-4'
        tw.m(4, negative=True)  # '-m-4'
        tw.m(4, 'x', negative=True)  # '-mx-4'
    """
    try:
        # Check if value is already negative
        is_negative = negative
        if isinstance(value, (int, float)) and value < 0:
            is_negative = True
            value = abs(value)
        
        # Validate the value (margins can be negative)
        validate_spacing_value(value, allow_negative=True)
        
        prefix = f"m{side}" if side else "m"
        if is_negative:
            prefix = f"-{prefix}"
            
        if isinstance(value, str) and not value in ["px", "auto", "full"]:
            # Check if it's an arbitrary value
            if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
                class_str = f"{prefix}-[{value}]"
                return self._return_value(class_str)
        class_str = self._spacing_class(prefix, value)
        return self._return_value(class_str)
    except InvalidValueError as e:
        raise InvalidValueError(f"Invalid margin value: {e}")

# %% ../nbs/layout.ipynb 8
@patch
def gap(
    self:TailwindBuilder,
    value: Union[SpacingValue, str],  # Spacing value or arbitrary value string
    axis: Optional[Literal["x", "y"]] = None  # Optional axis specification
) -> Union[str, Self]:  # Gap utility class string or self for chaining
    """Generate gap utility class with arbitrary value support."""
    prefix = f"gap-{axis}" if axis else "gap"
    if isinstance(value, str) and not value in ["px", "auto", "full"]:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
            class_str = f"{prefix}-[{value}]"
            return self._return_value(class_str)
    class_str = self._spacing_class(prefix, value)
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 9
@patch
def space(
    self:TailwindBuilder,
    value: Union[SpacingValue, str],  # Spacing value or arbitrary value string
    axis: Literal["x", "y"]  # Axis for spacing
) -> Union[str, Self]:  # Space utility class string or self for chaining
    """Generate space between utility class with arbitrary value support."""
    prefix = f"space-{axis}"
    if isinstance(value, str) and not value in ["px", "auto", "full"]:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
            class_str = f"{prefix}-[{value}]"
            return self._return_value(class_str)
    class_str = self._spacing_class(prefix, value)
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 11
@patch
def w(
    self:TailwindBuilder,
    value: Union[SizeValue, str],  # Size value or arbitrary value string
    important: bool = False  # Whether to add !important modifier
) -> Union[str, Self]:  # Width utility class string or self for chaining
    """Generate width utility class with arbitrary value support."""
    if isinstance(value, str) and not value in ["screen", "min", "max", "fit", "px", "auto", "full"] and "/" not in value:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc', 'ch', 'ex']):
            cls = f"w-[{value}]"
            class_str = f"!{cls}" if important else cls
            return self._return_value(class_str)
    cls = self._size_class("w", value)
    class_str = f"!{cls}" if important else cls
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 12
@patch
def h(
    self:TailwindBuilder,
    value: Union[SizeValue, str],  # Size value or arbitrary value string
    important: bool = False  # Whether to add !important modifier
) -> Union[str, Self]:  # Height utility class string or self for chaining
    """Generate height utility class with arbitrary value support."""
    if isinstance(value, str) and not value in ["screen", "min", "max", "fit", "px", "auto", "full"] and "/" not in value:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc', 'ch', 'ex']):
            cls = f"h-[{value}]"
            class_str = f"!{cls}" if important else cls
            return self._return_value(class_str)
    cls = self._size_class("h", value)
    class_str = f"!{cls}" if important else cls
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 13
@patch
def size(
    self:TailwindBuilder,
    value: Union[SizeValue, str]  # Size value or arbitrary value string
) -> Union[str, Self]:  # Size utility class string or self for chaining
    """Generate size utility class (sets both width and height) with arbitrary value support."""
    if isinstance(value, str) and not value in ["screen", "min", "max", "fit", "px", "auto", "full"] and "/" not in value:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc', 'ch', 'ex']):
            class_str = f"size-[{value}]"
            return self._return_value(class_str)
    class_str = self._size_class("size", value)
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 14
@patch
def min_w(
    self:TailwindBuilder,
    value: Union[SizeValue, str]  # Size value or arbitrary value string
) -> Union[str, Self]:  # Min-width utility class string or self for chaining
    """Generate min-width utility class with arbitrary value support."""
    if isinstance(value, str) and not value in ["screen", "min", "max", "fit", "px", "auto", "full"] and "/" not in value:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc', 'ch', 'ex']):
            class_str = f"min-w-[{value}]"
            return self._return_value(class_str)
    class_str = self._size_class("min-w", value)
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 15
@patch
def max_w(
    self:TailwindBuilder,
    value: Union[SizeValue, str, Literal["xs", "sm", "md", "lg", "xl", "2xl", "3xl", "4xl", "5xl", "6xl", "7xl", "prose"]]  # Size value, arbitrary value, or named size
) -> Union[str, Self]:  # Max-width utility class string or self for chaining
    """Generate max-width utility class with arbitrary value support."""
    if value in ["xs", "sm", "md", "lg", "xl", "2xl", "3xl", "4xl", "5xl", "6xl", "7xl", "prose"]:
        class_str = f"max-w-{value}"
    elif isinstance(value, str) and not value in ["screen", "min", "max", "fit", "px", "auto", "full"] and "/" not in value:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc', 'ch', 'ex']):
            class_str = f"max-w-[{value}]"
        else:
            class_str = self._size_class("max-w", value)
    else:
        class_str = self._size_class("max-w", value)
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 16
@patch
def min_h(
    self:TailwindBuilder,
    value: Union[SizeValue, str]  # Size value or arbitrary value string
) -> Union[str, Self]:  # Min-height utility class string or self for chaining
    """Generate min-height utility class with arbitrary value support."""
    if isinstance(value, str) and not value in ["screen", "min", "max", "fit", "px", "auto", "full"] and "/" not in value:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc', 'ch', 'ex']):
            class_str = f"min-h-[{value}]"
            return self._return_value(class_str)
    class_str = self._size_class("min-h", value)
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 17
@patch
def max_h(
    self:TailwindBuilder,
    value: Union[SizeValue, str]  # Size value or arbitrary value string
) -> Union[str, Self]:  # Max-height utility class string or self for chaining
    """Generate max-height utility class with arbitrary value support."""
    if isinstance(value, str) and not value in ["screen", "min", "max", "fit", "px", "auto", "full"] and "/" not in value:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc', 'ch', 'ex']):
            class_str = f"max-h-[{value}]"
            return self._return_value(class_str)
    class_str = self._size_class("max-h", value)
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 19
@patch
def position(
    self:TailwindBuilder,
    value: Literal["static", "fixed", "absolute", "relative", "sticky"]  # Position type
) -> Union[str, Self]:  # Position utility class string or self for chaining
    """Generate position utility class."""
    return self._return_value(value)

# %% ../nbs/layout.ipynb 20
@patch
def inset(
    self:TailwindBuilder,
    value: Union[SpacingValue, str],  # Inset value or arbitrary value string
    side: Optional[Literal["top", "right", "bottom", "left", "x", "y"]] = None,  # Optional side specification
    negative: bool = False  # Whether to apply negative value
) -> Union[str, Self]:  # Inset utility class string or self for chaining
    """Generate inset (top/right/bottom/left) utility class with arbitrary value support and negative values.
    
    Args:
        value: Inset value or arbitrary value string
        side: Optional side specification ('top', 'right', 'bottom', 'left', 'x', 'y')
        negative: Whether to apply negative inset (default: False)
        
    Returns:
        Inset utility class string or self for chaining
        
    Examples:
        tw.inset(4)  # 'inset-4'
        tw.inset(4, 'top')  # 'top-4'
        tw.inset(4, 'x', negative=True)  # '-inset-x-4'
    """
    # Check if value is already negative
    is_negative = negative
    if isinstance(value, (int, float)) and value < 0:
        is_negative = True
        value = abs(value)
    
    if isinstance(value, str) and not value in ["px", "auto", "full"]:
        # Check if it's an arbitrary value
        if any(unit in value for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
            prefix = side if side else "inset"
            if is_negative:
                prefix = f"-{prefix}"
            class_str = f"{prefix}-[{value}]"
            return self._return_value(class_str)
    
    if side:
        prefix = side
        if is_negative:
            prefix = f"-{prefix}"
        class_str = self._spacing_class(prefix, value)
    else:
        prefix = "inset"
        if is_negative:
            prefix = f"-{prefix}"
        class_str = self._spacing_class(prefix, value)
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 21
@patch
def z(
    self:TailwindBuilder,
    value: Union[ZIndexValue, int, str]  # Z-index value, integer, or arbitrary value string
) -> Union[str, Self]:  # Z-index utility class string or self for chaining
    """Generate z-index utility class with arbitrary value support."""
    if isinstance(value, str) and value not in ["auto"]:
        # It's an arbitrary value
        class_str = f"z-[{value}]"
    elif isinstance(value, int) and value not in [0, 10, 20, 30, 40, 50]:
        # Non-standard integer value
        class_str = f"z-[{value}]"
    else:
        class_str = f"z-{value}"
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 23
@patch
def display(
    self:TailwindBuilder,
    value: Literal["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"]  # Display type
) -> Union[str, Self]:  # Display utility class string or self for chaining
    """Generate display utility class."""
    return self._return_value(value)

# %% ../nbs/layout.ipynb 25
@patch
def flex(self:TailwindBuilder, 
         direction: Optional[Literal["row", "row-reverse", "col", "col-reverse"]] = None,
         wrap: Optional[Literal["wrap", "wrap-reverse", "nowrap"]] = None,
         grow: Optional[Literal[0, 1]] = None,
         shrink: Optional[Literal[0, 1]] = None,
         basis: Optional[Union[SizeValue, str]] = None) -> Union[str, Self]:
    """Generate flex utility classes with arbitrary value support."""
    classes = ["flex"]
    if direction:
        classes.append(f"flex-{direction}")
    if wrap:
        classes.append(f"flex-{wrap}")
    if grow is not None:
        classes.append(f"grow-{grow}" if grow else "grow-0")
    if shrink is not None:
        classes.append(f"shrink-{shrink}" if shrink else "shrink-0")
    if basis is not None:
        if isinstance(basis, str) and any(unit in basis for unit in ['px', 'em', 'rem', '%', 'vh', 'vw', 'calc']):
            classes.append(f"basis-[{basis}]")
        else:
            classes.append(f"basis-{_format_spacing_value(basis)}")
    class_str = " ".join(classes)
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 26
@patch
def items(
    self:TailwindBuilder,
    value: Literal["start", "end", "center", "baseline", "stretch"]  # Alignment value for flex/grid items
) -> Union[str, Self]:  # Align-items utility class string or self for chaining
    """Generate align-items utility class."""
    class_str = f"items-{value}"
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 27
@patch
def justify(
    self:TailwindBuilder,
    value: Literal["normal", "start", "end", "center", "between", "around", "evenly", "stretch"]  # Justify-content value
) -> Union[str, Self]:  # Justify-content utility class string or self for chaining
    """Generate justify-content utility class."""
    class_str = f"justify-{value}"
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 28
@patch
def align(
    self:TailwindBuilder,
    value: Literal["auto", "start", "end", "center", "stretch", "baseline"]  # Align-self value
) -> Union[str, Self]:  # Align-self utility class string or self for chaining
    """Generate align-self utility class."""
    class_str = f"self-{value}"
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 30
@patch
def grid(self:TailwindBuilder, 
         cols: Optional[Union[int, Literal["none"], str]] = None,
         rows: Optional[Union[int, Literal["none"], str]] = None,
         flow: Optional[Literal["row", "col", "dense", "row-dense", "col-dense"]] = None) -> Union[str, Self]:
    """Generate grid utility classes with arbitrary value support."""
    classes = ["grid"]
    if cols is not None:
        if isinstance(cols, str) and cols != "none":
            # Check if it's an arbitrary value
            if "(" in cols or "px" in cols or "fr" in cols:
                classes.append(f"grid-cols-[{cols}]")
            else:
                classes.append(f"grid-cols-{cols}")
        else:
            classes.append(f"grid-cols-{cols}")
    if rows is not None:
        if isinstance(rows, str) and rows != "none":
            # Check if it's an arbitrary value
            if "(" in rows or "px" in rows or "fr" in rows:
                classes.append(f"grid-rows-[{rows}]")
            else:
                classes.append(f"grid-rows-{rows}")
        else:
            classes.append(f"grid-rows-{rows}")
    if flow:
        classes.append(f"grid-flow-{flow}")
    class_str = " ".join(classes)
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 31
@patch
def col(
    self:TailwindBuilder,
    span: Union[int, Literal["auto", "full"]],  # Number of columns to span or keyword
    start: Optional[int] = None  # Starting column number
) -> Union[str, Self]:  # Grid column utility class string or self for chaining
    """Generate grid column utility classes."""
    classes = []
    if span:
        classes.append(f"col-span-{span}")
    if start:
        classes.append(f"col-start-{start}")
    class_str = " ".join(classes)
    return self._return_value(class_str)

# %% ../nbs/layout.ipynb 32
@patch
def row(
    self:TailwindBuilder,
    span: Union[int, Literal["auto", "full"]],  # Number of rows to span or keyword
    start: Optional[int] = None  # Starting row number
) -> Union[str, Self]:  # Grid row utility class string or self for chaining
    """Generate grid row utility classes."""
    classes = []
    if span:
        classes.append(f"row-span-{span}")
    if start:
        classes.append(f"row-start-{start}")
    class_str = " ".join(classes)
    return self._return_value(class_str)
