"""CLI tool for Claude Code and other coding assistants to understand and use cjm-tailwind-utils optimally"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/cli.ipynb.

# %% ../nbs/cli.ipynb 4
from __future__ import annotations
import argparse
import sys
import inspect
import importlib
from pathlib import Path
from typing import Dict, List, Any, Optional, get_type_hints
from dataclasses import dataclass

from .core import TailwindBuilder, tw

# %% auto 0
__all__ = ['MethodInfo', 'get_all_tailwind_methods', 'get_module_methods', 'cmd_list_methods', 'cmd_module_info', 'cmd_search',
           'cmd_method_details', 'cmd_source', 'VariableInfo', 'get_all_exported_variables', 'cmd_list_variables',
           'cmd_variable_details', 'cmd_variable_source', 'TypeInfo', 'get_all_type_definitions', 'cmd_list_types',
           'cmd_type_details', 'cmd_type_source', 'ImportInfo', 'get_import_patterns', 'cmd_list_imports',
           'cmd_import_details', 'main']

# %% ../nbs/cli.ipynb 6
@dataclass
class MethodInfo:
    """Information about a TailwindBuilder method"""
    name: str
    module: str
    signature: str
    docstring: Optional[str]
    return_type: str
    parameters: List[Dict[str, Any]]

# %% ../nbs/cli.ipynb 7
def get_all_tailwind_methods(
) -> Dict[str, MethodInfo]:  # Dictionary mapping method names to MethodInfo objects
    "Discover all TailwindBuilder methods using introspection."
    methods = {}
    
    # Get all callable attributes from TailwindBuilder class
    for name in dir(TailwindBuilder):
        if name.startswith('_'):
            continue
            
        try:
            attr = getattr(TailwindBuilder, name)
            if not callable(attr):
                continue
        except:
            continue
        
        # Get method signature
        try:
            sig = inspect.signature(attr)
            signature_str = f"{name}{sig}"
        except (ValueError, TypeError):
            signature_str = f"{name}(...)"
        
        # Get docstring
        docstring = inspect.getdoc(attr)
        
        # Get return type from annotations
        try:
            type_hints = get_type_hints(attr)
            return_type = str(type_hints.get('return', 'Any'))
        except (NameError, TypeError):
            return_type = 'Any'
        
        # Get parameter info
        parameters = []
        try:
            for param_name, param in sig.parameters.items():
                if param_name == 'self':
                    continue
                param_info = {
                    'name': param_name,
                    'type': str(param.annotation) if param.annotation != param.empty else 'Any',
                    'default': str(param.default) if param.default != param.empty else None,
                    'required': param.default == param.empty
                }
                parameters.append(param_info)
        except:
            parameters = []
        
        # Determine module by inspecting the method's module
        module = 'core'  # Default
        try:
            if hasattr(attr, '__module__'):
                module_path = attr.__module__
                if 'cjm_tailwind_utils' in module_path:
                    module = module_path.split('.')[-1]
        except:
            pass
        
        methods[name] = MethodInfo(
            name=name,
            module=module,
            signature=signature_str,
            docstring=docstring,
            return_type=return_type,
            parameters=parameters
        )
    
    return methods

# %% ../nbs/cli.ipynb 8
def get_module_methods(
) -> Dict[str, List[str]]:  # Dictionary mapping module names to lists of method names
    "Get methods organized by module using ground truth introspection."
    # Import all modules to ensure patches are registered
    module_names = ['layout', 'style', 'variants', 'modern', 'colors']
    for module_name in module_names:
        try:
            importlib.import_module(f'cjm_tailwind_utils.{module_name}')
        except ImportError:
            continue
    
    # Get all methods and discover their actual modules
    all_methods = get_all_tailwind_methods()
    module_methods = {}
    
    # Inspect each method to find its actual module
    for method_name, method_info in all_methods.items():
        try:
            method = getattr(TailwindBuilder, method_name)
            # Get the module where the method was defined
            if hasattr(method, '__module__'):
                module_path = method.__module__
                if 'cjm_tailwind_utils' in module_path:
                    module = module_path.split('.')[-1]
                else:
                    module = 'core'
            else:
                module = 'core'
        except:
            module = 'core'
        
        if module not in module_methods:
            module_methods[module] = []
        module_methods[module].append(method_name)
    
    return module_methods

# %% ../nbs/cli.ipynb 10
def cmd_list_methods(
    args  # TODO: Add type hint and description
): # TODO: Add type hint
    """List all available TailwindBuilder methods."""
    # Import all modules to ensure all patches are loaded
    for module_name in ['layout', 'style', 'variants', 'modern', 'colors']:
        try:
            importlib.import_module(f'cjm_tailwind_utils.{module_name}')
        except ImportError:
            continue
    
    all_methods = get_all_tailwind_methods()
    
    if args.module:
        # Filter by specific module
        module_methods = get_module_methods()
        if args.module not in module_methods:
            print(f"Module '{args.module}' not found. Available modules: {', '.join(module_methods.keys())}")
            return
        
        methods_to_show = {name: info for name, info in all_methods.items() 
                          if name in module_methods[args.module]}
        print(f"Methods in {args.module} module:")
    else:
        methods_to_show = all_methods
        print("All TailwindBuilder methods:")
    
    print()
    
    # Sort methods alphabetically
    for name in sorted(methods_to_show.keys()):
        info = methods_to_show[name]
        
        if args.signatures:
            print(f"**{name}**")
            print(f"  Signature: {info.signature}")
            if info.docstring:
                # Get first line of docstring
                first_line = info.docstring.split('\n')[0].strip()
                print(f"  Description: {first_line}")
            print(f"  Returns: {info.return_type}")
            print()
        else:
            # Compact format
            first_line = ""
            if info.docstring:
                first_line = info.docstring.split('\n')[0].strip()
            print(f"{name:<20} {first_line}")
    
    if not args.signatures and methods_to_show:
        print(f"\nTotal: {len(methods_to_show)} methods")
        print("Use --signatures to see method signatures")
        print("Use 'cjm-tailwind-utils method <name>' for detailed parameter info")
        print("Use 'cjm-tailwind-utils method-source <name>' for full source code")

# %% ../nbs/cli.ipynb 11
def cmd_module_info(
    args  # TODO: Add type hint and description
): # TODO: Add type hint
    """Show detailed information about a specific module."""
    # Import all modules to ensure all patches are loaded
    for module_name in ['layout', 'style', 'variants', 'modern', 'colors']:
        try:
            importlib.import_module(f'cjm_tailwind_utils.{module_name}')
        except ImportError:
            continue
    
    module_methods = get_module_methods()
    
    if args.name not in module_methods:
        print(f"Module '{args.name}' not found.")
        print(f"Available modules: {', '.join(sorted(module_methods.keys()))}")
        return
    
    # Get module docstring if available
    try:
        module = importlib.import_module(f'cjm_tailwind_utils.{args.name}')
        module_doc = module.__doc__ or "No description available"
    except ImportError:
        module_doc = "Core TailwindBuilder functionality"
    
    print(f"Module: {args.name}")
    print(f"Description: {module_doc}")
    print(f"Methods: {len(module_methods[args.name])}")
    print()
    
    # Show import statement
    if args.name == 'core':
        print("Import:")
        print(f"  from cjm_tailwind_utils.core import tw")
    else:
        print("Import:")
        print(f"  from cjm_tailwind_utils.{args.name} import *")
        print("  # This adds methods to the TailwindBuilder class via patches")
    print()
    
    # Show methods in this module
    all_methods = get_all_tailwind_methods()
    method_names = sorted(module_methods[args.name])
    
    print("Methods:")
    for method_name in method_names:
        if method_name in all_methods:
            info = all_methods[method_name]
            first_line = ""
            if info.docstring:
                first_line = info.docstring.split('\n')[0].strip()
            print(f"  {method_name:<20} {first_line}")
    
    print(f"\nUse 'cjm-tailwind-utils list-methods --module {args.name} --verbose' for detailed method information")

# %% ../nbs/cli.ipynb 12
def cmd_search(
    args  # TODO: Add type hint and description
): # TODO: Add type hint
    """Search for methods by keyword."""
    # Import all modules to ensure all patches are loaded
    for module_name in ['layout', 'style', 'variants', 'modern', 'colors']:
        try:
            importlib.import_module(f'cjm_tailwind_utils.{module_name}')
        except ImportError:
            continue
    
    all_methods = get_all_tailwind_methods()
    keyword = args.keyword.lower()
    
    matches = []
    
    for name, info in all_methods.items():
        # Search in method name
        if keyword in name.lower():
            matches.append((name, info, "name"))
            continue
        
        # Search in docstring
        if info.docstring and keyword in info.docstring.lower():
            matches.append((name, info, "description"))
            continue
        
        # Search in parameter names/types
        for param in info.parameters:
            if keyword in param['name'].lower() or keyword in param['type'].lower():
                matches.append((name, info, "parameter"))
                break
    
    if not matches:
        print(f"No methods found matching '{args.keyword}'")
        return
    
    print(f"Methods matching '{args.keyword}':")
    print()
    
    # Group by match type
    for match_type in ["name", "description", "parameter"]:
        type_matches = [(name, info) for name, info, mtype in matches if mtype == match_type]
        if not type_matches:
            continue
        
        if match_type == "name":
            print("Matches in method names:")
        elif match_type == "description":
            print("Matches in descriptions:")
        else:
            print("Matches in parameters:")
        
        for name, info in sorted(type_matches):
            first_line = ""
            if info.docstring:
                first_line = info.docstring.split('\n')[0].strip()
            print(f"  {name:<20} {first_line}")
        print()
    
    print(f"Total: {len(matches)} matches")

# %% ../nbs/cli.ipynb 13
def cmd_method_details(
    args  # TODO: Add type hint and description
): # TODO: Add type hint
    """Show detailed signature and parameter information for a specific method."""
    # Import all modules to ensure all patches are loaded
    for module_name in ['layout', 'style', 'variants', 'modern', 'colors']:
        try:
            importlib.import_module(f'cjm_tailwind_utils.{module_name}')
        except ImportError:
            continue
    
    all_methods = get_all_tailwind_methods()
    
    if args.method not in all_methods:
        print(f"Method '{args.method}' not found.")
        # Show similar methods - NO TRUNCATION
        similar = [name for name in all_methods.keys() if args.method.lower() in name.lower()]
        if similar:
            print(f"Similar methods: {', '.join(similar)}")
        return
    
    info = all_methods[args.method]
    print(f"Method: {args.method}")
    if info.docstring:
        print(f"Description: {info.docstring}")
    print(f"Signature: {info.signature}")
    print(f"Returns: {info.return_type}")
    print()
    
    # Show detailed parameter breakdown  
    if info.parameters:
        print("Parameters:")
        for param in info.parameters:
            required_str = "REQUIRED" if param['required'] else f"optional (default: {param['default']})"
            print(f"  {param['name']}: {param['type']}")
            print(f"    {required_str}")
            print()
    else:
        print("No parameters (besides self)")
    
    # Show module info
    module_methods = get_module_methods()
    for module, methods in module_methods.items():
        if args.method in methods:
            print(f"Module: {module}")
            if module != 'core':
                print(f"Import: from cjm_tailwind_utils.{module} import *")
            else:
                print(f"Import: from cjm_tailwind_utils.core import tw")
            break
    
    print()
    print(f"Use 'cjm-tailwind-utils method-source {args.method}' to see the full source code")

# %% ../nbs/cli.ipynb 14
def cmd_source(
    args  # TODO: Add type hint and description
): # TODO: Add type hint
    """Show the full source code for a specific method."""
    # Import all modules to ensure all patches are loaded
    for module_name in ['layout', 'style', 'variants', 'modern', 'colors']:
        try:
            importlib.import_module(f'cjm_tailwind_utils.{module_name}')
        except ImportError:
            continue
    
    all_methods = get_all_tailwind_methods()
    
    if args.method not in all_methods:
        print(f"Method '{args.method}' not found.")
        # Show similar methods
        similar = [name for name in all_methods.keys() if args.method.lower() in name.lower()]
        if similar:
            print(f"Similar methods: {', '.join(similar[:5])}")
        return
    
    try:
        method = getattr(TailwindBuilder, args.method)
        source_code = inspect.getsource(method)
        
        print(f"Source code for method '{args.method}':")
        print("=" * 50)
        print(source_code)
        print("=" * 50)
        
    except OSError:
        print(f"Source code not available for method '{args.method}'.")
        print("This might be a built-in method or the source file is not accessible.")
        
        # Still show the signature as fallback
        info = all_methods[args.method]
        print(f"\nSignature: {info.signature}")
        if info.docstring:
            print(f"Docstring: {info.docstring}")
    
    except Exception as e:
        print(f"Error retrieving source code: {e}")
        
        # Show method info as fallback
        info = all_methods[args.method]
        print(f"\nSignature: {info.signature}")
        if info.docstring:
            print(f"Docstring: {info.docstring}")

# %% ../nbs/cli.ipynb 15
@dataclass
class VariableInfo:
    """Information about an exported variable/constant"""
    name: str
    module: str
    type_name: str
    value: Any
    value_preview: str
    docstring: Optional[str]

# %% ../nbs/cli.ipynb 16
def get_all_exported_variables(
) -> Dict[str, VariableInfo]:  # Dictionary mapping variable names to VariableInfo objects
    "Discover all exported variables/constants using introspection."
    variables = {}
    
    # Import all modules and inspect their exports
    module_names = ['core', 'colors', 'types', 'validation']
    
    for module_name in module_names:
        try:
            module = importlib.import_module(f'cjm_tailwind_utils.{module_name}')
            
            # Get all public attributes (not starting with _)
            for name in dir(module):
                if name.startswith('_'):
                    continue
                    
                try:
                    attr = getattr(module, name)
                    
                    # Skip functions, classes, and modules
                    if (callable(attr) or 
                        inspect.isclass(attr) or 
                        inspect.ismodule(attr)):
                        continue
                    
                    # Get type information
                    type_name = type(attr).__name__
                    
                    # Create a preview of the value - NO TRUNCATION, just show full value
                    if isinstance(attr, (dict, list, tuple, set)):
                        value_preview = f"{type_name} with {len(attr)} items"
                    else:
                        value_preview = str(attr)
                    
                    # Try to get docstring if it's documented
                    docstring = None
                    if hasattr(attr, '__doc__'):
                        docstring = attr.__doc__
                    
                    variables[name] = VariableInfo(
                        name=name,
                        module=module_name,
                        type_name=type_name,
                        value=attr,
                        value_preview=value_preview,
                        docstring=docstring
                    )
                    
                except Exception:
                    # Skip attributes that can't be accessed
                    continue
                    
        except ImportError:
            continue
    
    return variables

# %% ../nbs/cli.ipynb 17
def cmd_list_variables(
    args  # TODO: Add type hint and description
): # TODO: Add type hint
    """List all exported variables/constants."""
    all_variables = get_all_exported_variables()
    
    if args.module:
        # Filter by specific module
        variables_to_show = {name: info for name, info in all_variables.items() 
                           if info.module == args.module}
        if not variables_to_show:
            available_modules = sorted(set(info.module for info in all_variables.values()))
            print(f"No variables found in module '{args.module}'.")
            print(f"Available modules: {', '.join(available_modules)}")
            return
        print(f"Variables/constants in {args.module} module:")
    else:
        variables_to_show = all_variables
        print("All exported variables/constants:")
    
    print()
    
    # Group by module for better organization
    by_module = {}
    for name, info in variables_to_show.items():
        if info.module not in by_module:
            by_module[info.module] = []
        by_module[info.module].append((name, info))
    
    for module in sorted(by_module.keys()):
        if not args.module:  # Only show module headers when showing all
            print(f"--- {module} ---")
        
        for name, info in sorted(by_module[module]):
            if args.values:
                print(f"{name:<25} {info.type_name:<15} {info.value_preview}")
            else:
                print(f"{name:<25} {info.type_name}")
        
        if not args.module:
            print()
    
    if not args.values and variables_to_show:
        print(f"Total: {len(variables_to_show)} variables/constants")
        print("Use --values to see variable values")
        print("Use 'cjm-tailwind-utils variable <name>' for detailed info")

# %% ../nbs/cli.ipynb 18
def cmd_variable_details(
    args  # TODO: Add type hint and description
): # TODO: Add type hint
    """Show detailed information about a specific variable/constant."""
    all_variables = get_all_exported_variables()
    
    if args.name not in all_variables:
        print(f"Variable '{args.name}' not found.")
        # Show similar variables
        similar = [name for name in all_variables.keys() if args.name.lower() in name.lower()]
        if similar:
            print(f"Similar variables: {', '.join(similar)}")
        return
    
    info = all_variables[args.name]
    print(f"Variable: {args.name}")
    print(f"Module: {info.module}")
    print(f"Type: {info.type_name}")
    if info.docstring:
        print(f"Description: {info.docstring}")
    print()
    
    # Show import statement
    print("Import:")
    print(f"  from cjm_tailwind_utils.{info.module} import {args.name}")
    print()
    
    # Show value details - NO TRUNCATION
    print("Value:")
    if isinstance(info.value, dict):
        print(f"  Dictionary with {len(info.value)} items:")
        for key, value in info.value.items():
            print(f"    {key}: {value}")
            
    elif isinstance(info.value, (list, tuple)):
        print(f"  {info.type_name} with {len(info.value)} items:")
        for i, item in enumerate(info.value):
            print(f"    [{i}]: {item}")
            
    elif isinstance(info.value, set):
        print(f"  Set with {len(info.value)} items:")
        for item in sorted(info.value):
            print(f"    {item}")
            
    else:
        print(f"  {info.value}")
    
    print()
    print(f"Use 'cjm-tailwind-utils variable-source {args.name}' to see how this variable is defined")

# %% ../nbs/cli.ipynb 19
def cmd_variable_source(
    args  # TODO: Add type hint and description
): # TODO: Add type hint
    """Show the source definition of a specific variable/constant."""
    all_variables = get_all_exported_variables()
    
    if args.name not in all_variables:
        print(f"Variable '{args.name}' not found.")
        similar = [name for name in all_variables.keys() if args.name.lower() in name.lower()]
        if similar:
            print(f"Similar variables: {', '.join(similar[:5])}")
        return
    
    info = all_variables[args.name]
    
    try:
        # Import the module and try to get source
        module = importlib.import_module(f'cjm_tailwind_utils.{info.module}')
        
        # Try to get source from module file
        module_file = inspect.getfile(module)
        with open(module_file, 'r') as f:
            source_lines = f.readlines()
        
        # Look for the variable definition
        found_definition = False
        definition_lines = []
        in_definition = False
        
        for i, line in enumerate(source_lines):
            # Look for variable assignment
            if f"{args.name} = " in line or f"{args.name}: " in line:
                found_definition = True
                in_definition = True
                definition_lines.append(f"{i+1:4d}: {line.rstrip()}")
                
            elif in_definition:
                # Continue if line is part of multi-line definition
                if (line.startswith(' ') or line.startswith('\t') or 
                    line.strip().startswith('"') or line.strip().startswith("'") or
                    line.strip() in ['}', ']', ')']):
                    definition_lines.append(f"{i+1:4d}: {line.rstrip()}")
                else:
                    # End of definition
                    break
        
        if found_definition:
            print(f"Source definition for '{args.name}':")
            print("=" * 50)
            for line in definition_lines:
                print(line)
            print("=" * 50)
        else:
            print(f"Could not find source definition for '{args.name}' in {module_file}")
            print(f"Value: {info.value_preview}")
            
    except Exception as e:
        print(f"Error retrieving source: {e}")
        print(f"Variable: {args.name}")
        print(f"Type: {info.type_name}")
        print(f"Value: {info.value_preview}")

# %% ../nbs/cli.ipynb 20
@dataclass
class TypeInfo:
    """Information about a type definition"""
    name: str
    module: str
    type_kind: str  # 'TypeAlias', 'Union', 'Literal', etc.
    definition: str
    docstring: Optional[str]
    actual_type: Any

# %% ../nbs/cli.ipynb 21
def get_all_type_definitions(
) -> Dict[str, TypeInfo]:  # Dictionary mapping type names to TypeInfo objects
    "Discover all type definitions using introspection."
    types_info = {}
    
    # Import types module to get type definitions
    try:
        types_module = importlib.import_module('cjm_tailwind_utils.types')
        
        # Get all public attributes from types module
        for name in dir(types_module):
            if name.startswith('_'):
                continue
                
            try:
                attr = getattr(types_module, name)
                
                # Skip imported basic types and constructs
                if (inspect.ismodule(attr) or 
                    inspect.isfunction(attr) or 
                    (inspect.isclass(attr) and not attr.__module__.startswith('cjm_tailwind_utils'))):
                    continue
                
                # Determine type kind and definition
                type_kind = 'Unknown'
                definition = str(attr)
                
                # Check for typing constructs
                type_name = type(attr).__name__
                
                if 'Union' in type_name:
                    type_kind = 'Union'
                    if hasattr(attr, '__args__'):
                        args = [str(arg) for arg in attr.__args__]
                        definition = f"Union[{', '.join(args)}]"
                elif 'Literal' in type_name:
                    type_kind = 'Literal'
                    if hasattr(attr, '__args__'):
                        values = [repr(arg) for arg in attr.__args__]
                        # NO TRUNCATION - show all values
                        definition = f"Literal[{', '.join(values)}]"
                elif hasattr(attr, '_name'):  # Type aliases
                    type_kind = 'TypeAlias'
                    definition = str(attr)
                elif inspect.isclass(attr):
                    type_kind = 'Class'
                    definition = f"class {name}"
                elif name in ['Union', 'Literal']:  # Skip these basic constructs
                    continue
                else:
                    # This is likely a type alias
                    type_kind = 'TypeAlias'
                
                # Try to get docstring
                docstring = None
                if hasattr(attr, '__doc__'):
                    docstring = attr.__doc__
                
                types_info[name] = TypeInfo(
                    name=name,
                    module='types',
                    type_kind=type_kind,
                    definition=definition,
                    docstring=docstring,
                    actual_type=attr
                )
                
            except Exception:
                # Skip attributes that can't be accessed
                continue
                
    except ImportError:
        pass
    
    # Also check other modules for type definitions and classes
    for module_name in ['colors', 'validation']:
        try:
            module = importlib.import_module(f'cjm_tailwind_utils.{module_name}')
            
            for name in dir(module):
                if (name.startswith('_') or 
                    name in types_info):  # Already found
                    continue
                    
                try:
                    attr = getattr(module, name)
                    
                    # Look for classes and type-like constructs
                    if inspect.isclass(attr) and attr.__module__.startswith('cjm_tailwind_utils'):
                        type_kind = 'Class'
                        definition = f"class {name}"
                        docstring = getattr(attr, '__doc__', None)
                        
                        types_info[name] = TypeInfo(
                            name=name,
                            module=module_name,
                            type_kind=type_kind,
                            definition=definition,
                            docstring=docstring,
                            actual_type=attr
                        )
                        
                except Exception:
                    continue
                    
        except ImportError:
            continue
    
    return types_info

# %% ../nbs/cli.ipynb 22
def cmd_list_types(
    args  # TODO: Add type hint and description
): # TODO: Add type hint
    """List all type definitions."""
    all_types = get_all_type_definitions()
    
    if args.module:
        # Filter by specific module
        types_to_show = {name: info for name, info in all_types.items() 
                        if info.module == args.module}
        if not types_to_show:
            available_modules = sorted(set(info.module for info in all_types.values()))
            print(f"No types found in module '{args.module}'.")
            print(f"Available modules: {', '.join(available_modules)}")
            return
        print(f"Type definitions in {args.module} module:")
    else:
        types_to_show = all_types
        print("All type definitions:")
    
    print()
    
    # Group by module for better organization
    by_module = {}
    for name, info in types_to_show.items():
        if info.module not in by_module:
            by_module[info.module] = []
        by_module[info.module].append((name, info))
    
    for module in sorted(by_module.keys()):
        if not args.module:  # Only show module headers when showing all
            print(f"--- {module} ---")
        
        for name, info in sorted(by_module[module]):
            if args.definitions:
                print(f"{name:<25} {info.type_kind:<15} {info.definition}")
            else:
                print(f"{name:<25} {info.type_kind}")
        
        if not args.module:
            print()
    
    if not args.definitions and types_to_show:
        print(f"Total: {len(types_to_show)} type definitions")
        print("Use --definitions to see type definitions")
        print("Use 'cjm-tailwind-utils type <name>' for detailed info")

# %% ../nbs/cli.ipynb 23
def cmd_type_details(
    args  # TODO: Add type hint and description
): # TODO: Add type hint
    """Show detailed information about a specific type definition."""
    all_types = get_all_type_definitions()
    
    if args.name not in all_types:
        print(f"Type '{args.name}' not found.")
        # Show similar types
        similar = [name for name in all_types.keys() if args.name.lower() in name.lower()]
        if similar:
            print(f"Similar types: {', '.join(similar)}")
        return
    
    info = all_types[args.name]
    print(f"Type: {args.name}")
    print(f"Module: {info.module}")
    print(f"Kind: {info.type_kind}")
    if info.docstring:
        print(f"Description: {info.docstring}")
    print()
    
    # Show import statement
    print("Import:")
    print(f"  from cjm_tailwind_utils.{info.module} import {args.name}")
    print()
    
    # Show type definition
    print("Definition:")
    print(f"  {info.definition}")
    print()
    
    # Show expanded information for different type kinds - NO TRUNCATION
    if info.type_kind == 'Literal':
        try:
            if hasattr(info.actual_type, '__args__'):
                values = list(info.actual_type.__args__)
                print(f"Allowed values ({len(values)} total):")
                for value in values:
                    print(f"  {repr(value)}")
        except:
            pass
    
    elif info.type_kind == 'Union':
        try:
            if hasattr(info.actual_type, '__args__'):
                types = list(info.actual_type.__args__)
                print(f"Union of {len(types)} types:")
                for i, union_type in enumerate(types, 1):
                    print(f"  {i}. {union_type}")
        except:
            pass
    
    elif info.type_kind == 'TypeAlias':
        print("This is a type alias. The actual type definition may be complex.")
    
    print()
    print(f"Use 'cjm-tailwind-utils type-source {args.name}' to see how this type is defined")

# %% ../nbs/cli.ipynb 24
def cmd_type_source(
    args  # TODO: Add type hint and description
): # TODO: Add type hint
    """Show the source definition of a specific type."""
    all_types = get_all_type_definitions()
    
    if args.name not in all_types:
        print(f"Type '{args.name}' not found.")
        similar = [name for name in all_types.keys() if args.name.lower() in name.lower()]
        if similar:
            print(f"Similar types: {', '.join(similar[:5])}")
        return
    
    info = all_types[args.name]
    
    try:
        # Import the module and try to get source
        module = importlib.import_module(f'cjm_tailwind_utils.{info.module}')
        
        # Try to get source from module file
        module_file = inspect.getfile(module)
        with open(module_file, 'r') as f:
            source_lines = f.readlines()
        
        # Look for the type definition
        found_definition = False
        definition_lines = []
        in_definition = False
        
        for i, line in enumerate(source_lines):
            # Look for type definition patterns
            if (f"{args.name} = " in line or 
                f"{args.name}: " in line or
                f"class {args.name}" in line):
                found_definition = True
                in_definition = True
                definition_lines.append(f"{i+1:4d}: {line.rstrip()}")
                
            elif in_definition:
                # Continue if line is part of multi-line definition
                if (line.startswith(' ') or line.startswith('\t') or 
                    line.strip().startswith('"') or line.strip().startswith("'") or
                    line.strip() in ['}', ']', ')', '|'] or
                    '|' in line or 'Union[' in line or 'Literal[' in line):
                    definition_lines.append(f"{i+1:4d}: {line.rstrip()}")
                else:
                    # End of definition
                    break
        
        if found_definition:
            print(f"Source definition for type '{args.name}':")
            print("=" * 50)
            for line in definition_lines:
                print(line)
            print("=" * 50)
        else:
            print(f"Could not find source definition for type '{args.name}' in {module_file}")
            print(f"Definition: {info.definition}")
            
    except Exception as e:
        print(f"Error retrieving source: {e}")
        print(f"Type: {args.name}")
        print(f"Kind: {info.type_kind}")
        print(f"Definition: {info.definition}")

# %% ../nbs/cli.ipynb 25
@dataclass
class ImportInfo:
    """Information about import patterns and recommendations"""
    import_statement: str
    description: str
    use_case: str
    items: List[str]
    dependencies: List[str]

# %% ../nbs/cli.ipynb 26
def get_import_patterns(
) -> Dict[str, ImportInfo]:  # Dictionary mapping pattern names to ImportInfo objects
    "Discover optimal import patterns using ground truth analysis."
    patterns = {}
    
    # Analyze what each module actually provides
    all_methods = get_all_tailwind_methods()
    all_variables = get_all_exported_variables()
    all_types = get_all_type_definitions()
    module_methods = get_module_methods()
    
    # Core import pattern - only if tw variable actually exists
    if 'tw' in all_variables:
        core_items = ['tw (global TailwindBuilder instance)']
        patterns['core'] = ImportInfo(
            import_statement="from cjm_tailwind_utils.core import tw",
            description="Basic usage with global tw instance",
            use_case="Most common usage - provides access to utility methods via tw.method()",
            items=core_items,
            dependencies=[]
        )
    
    # Module-specific import patterns - only for modules that actually exist and have methods
    for module_name, methods in module_methods.items():
        if module_name != 'core' and methods:
            patterns[f'{module_name}_methods'] = ImportInfo(
                import_statement=f"from cjm_tailwind_utils.{module_name} import *",
                description=f"Adds {len(methods)} methods to TailwindBuilder",
                use_case=f"Import to enable {', '.join(methods[:3])}{'...' if len(methods) > 3 else ''} methods on tw instance",
                items=[f"{method}() method" for method in sorted(methods)],
                dependencies=['core'] if 'tw' in all_variables else []
            )
    
    # Types import pattern - only for types that actually exist
    type_items = [name for name, info in all_types.items() if info.module == 'types']
    if type_items:
        # Create intelligent import statement based on what actually exists
        important_types = [t for t in ['SpacingValue', 'ColorValue', 'SizeValue'] if t in type_items]
        import_list = ', '.join(important_types[:3]) if important_types else ', '.join(type_items[:3])
        
        patterns['types'] = ImportInfo(
            import_statement=f"from cjm_tailwind_utils.types import {import_list}",
            description="Type definitions for better IDE support and type checking",
            use_case="Import when you need type hints for function parameters",
            items=[f"{name} (type definition)" for name in sorted(type_items)],
            dependencies=[]
        )
    
    # Colors import pattern - only for color constants that actually exist
    color_variables = [name for name, info in all_variables.items() if info.module == 'colors']
    if color_variables:
        # Create import statement based on what actually exists
        important_colors = [c for c in ['TAILWIND_COLORS', 'SPECIAL_COLORS'] if c in color_variables]
        import_list = ', '.join(important_colors) if important_colors else ', '.join(color_variables[:2])
        
        patterns['colors'] = ImportInfo(
            import_statement=f"from cjm_tailwind_utils.colors import {import_list}",
            description="Color constants and validation utilities",
            use_case="Import when you need to work with color data directly",
            items=[f"{name} (constant)" for name in sorted(color_variables)],
            dependencies=[]
        )
    
    # Check if 'all' module actually exists
    try:
        importlib.import_module('cjm_tailwind_utils.all')
        patterns['complete'] = ImportInfo(
            import_statement="from cjm_tailwind_utils.all import *",
            description="Complete library with all functionality",
            use_case="Convenience import that enables all features at once",
            items=["All available functionality"],
            dependencies=[]
        )
    except ImportError:
        # all module doesn't exist, skip this pattern
        pass
    
    # Validation import pattern - only for validation items that actually exist
    validation_variables = [name for name, info in all_variables.items() if info.module == 'validation']
    validation_types = [name for name, info in all_types.items() if info.module == 'validation']
    validation_items = validation_variables + validation_types
    
    if validation_items:
        # Create import statement based on what actually exists
        funcs = [item for item in validation_items if item.startswith('validate_')]
        errors = [item for item in validation_items if item.endswith('Error')]
        import_candidates = (funcs[:1] + errors[:1])[:2]  # Take at most 2 items
        import_list = ', '.join(import_candidates) if import_candidates else validation_items[0]
        
        patterns['validation'] = ImportInfo(
            import_statement=f"from cjm_tailwind_utils.validation import {import_list}",
            description="Validation functions and error classes",
            use_case="Import when building custom utilities or handling validation",
            items=[f"{name} ({'function' if name.startswith('validate_') else 'class/constant'})" for name in sorted(validation_items)],
            dependencies=[]
        )
    
    return patterns

# %% ../nbs/cli.ipynb 27
def cmd_list_imports(
    args  # TODO: Add type hint and description
): # TODO: Add type hint
    """List all recommended import patterns."""
    import_patterns = get_import_patterns()
    
    if args.use_case:
        # Filter by use case
        use_case_lower = args.use_case.lower()
        filtered_patterns = {
            name: info for name, info in import_patterns.items()
            if use_case_lower in info.use_case.lower() or use_case_lower in info.description.lower()
        }
        if not filtered_patterns:
            print(f"No import patterns found for use case '{args.use_case}'")
            print(f"Available patterns: {', '.join(import_patterns.keys())}")
            return
        patterns_to_show = filtered_patterns
        print(f"Import patterns for use case '{args.use_case}':")
    else:
        patterns_to_show = import_patterns
        print("All recommended import patterns:")
    
    print()
    
    for name, info in sorted(patterns_to_show.items()):
        if args.detailed:
            print(f"**{name}**")
            print(f"  Import: {info.import_statement}")
            print(f"  Description: {info.description}")
            print(f"  Use case: {info.use_case}")
            if info.dependencies:
                print(f"  Dependencies: {', '.join(info.dependencies)}")
            print(f"  Provides: {len(info.items)} items")
            print()
        else:
            print(f"{name:<20} {info.description}")
    
    if not args.detailed and patterns_to_show:
        print(f"\nTotal: {len(patterns_to_show)} import patterns")
        print("Use --detailed for complete information")
        print("Use 'cjm-tailwind-utils import <pattern>' for specific pattern details")

# %% ../nbs/cli.ipynb 28
def cmd_import_details(
    args  # TODO: Add type hint and description
): # TODO: Add type hint
    """Show detailed information about a specific import pattern."""
    import_patterns = get_import_patterns()
    
    if args.pattern not in import_patterns:
        print(f"Import pattern '{args.pattern}' not found.")
        # Show similar patterns
        similar = [name for name in import_patterns.keys() if args.pattern.lower() in name.lower()]
        if similar:
            print(f"Similar patterns: {', '.join(similar)}")
        print(f"Available patterns: {', '.join(sorted(import_patterns.keys()))}")
        return
    
    info = import_patterns[args.pattern]
    print(f"Import Pattern: {args.pattern}")
    print(f"Description: {info.description}")
    print()
    
    print("Import Statement:")
    print(f"  {info.import_statement}")
    print()
    
    print("Use Case:")
    print(f"  {info.use_case}")
    print()
    
    if info.dependencies:
        print("Dependencies:")
        for dep in info.dependencies:
            dep_info = import_patterns.get(dep)
            if dep_info:
                print(f"  {dep}: {dep_info.import_statement}")
            else:
                print(f"  {dep}")
        print()
    
    print(f"Provides ({len(info.items)} items):")
    for item in info.items:
        print(f"  - {item}")
    
    # Show method breakdown if this provides methods
    if args.pattern.endswith('_methods'):
        module_name = args.pattern.replace('_methods', '')
        module_methods = get_module_methods()
        if module_name in module_methods:
            methods = module_methods[module_name]
            print()
            print(f"Methods added to TailwindBuilder ({len(methods)} total):")
            for method in sorted(methods):
                print(f"  tw.{method}()")
    
    print()
    print("Usage Example:")
    if args.pattern == 'core':
        print("  from cjm_tailwind_utils.core import tw")
        # Use actual methods that exist
        all_methods = get_all_tailwind_methods()
        if 'p' in all_methods:
            print("  result = tw.p(4)  # Returns 'p-4'")
        elif all_methods:
            first_method = sorted(all_methods.keys())[0]
            print(f"  result = tw.{first_method}(...)  # Use available methods")
    elif args.pattern.endswith('_methods'):
        module_name = args.pattern.replace('_methods', '')
        print(f"  from cjm_tailwind_utils.core import tw")
        print(f"  from cjm_tailwind_utils.{module_name} import *")
        module_methods = get_module_methods()
        if module_name in module_methods and module_methods[module_name]:
            example_method = sorted(module_methods[module_name])[0]
            print(f"  result = tw.{example_method}(...)  # Now available")
    elif args.pattern == 'types':
        # Use actual types that exist
        all_types = get_all_type_definitions()
        type_items = [name for name, info in all_types.items() if info.module == 'types']
        if type_items:
            example_type = type_items[0]
            print(f"  from cjm_tailwind_utils.types import {example_type}")
            print(f"  def my_function(param: {example_type}): ...")
    elif args.pattern == 'complete':
        print("  from cjm_tailwind_utils.all import *")
        print("  # All functionality now available")
    else:
        print(f"  {info.import_statement}")
        print("  # Use the imported items as needed")

# %% ../nbs/cli.ipynb 32
def main(
): # TODO: Add type hint
    """Main CLI entry point for cjm-tailwind-utils"""
    parser = argparse.ArgumentParser(
        prog='cjm-tailwind-utils',
        description='CLI tool for understanding and using cjm-tailwind-utils library optimally'
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Method commands
    list_methods_parser = subparsers.add_parser('list-methods', help='List all available TailwindBuilder methods')
    list_methods_parser.add_argument('--module', help='Filter by specific module (core, layout, style, variants, modern)')
    list_methods_parser.add_argument('--signatures', action='store_true', help='Show method signatures and parameters')
    list_methods_parser.set_defaults(func=cmd_list_methods)
    
    method_parser = subparsers.add_parser('method', help='Show detailed signature and parameters for a specific method')
    method_parser.add_argument('method', help='Method name (e.g., p, flex, text, hover)')
    method_parser.set_defaults(func=cmd_method_details)
    
    method_source_parser = subparsers.add_parser('method-source', help='Show full source code for a specific method')
    method_source_parser.add_argument('method', help='Method name (e.g., p, flex, text, hover)')
    method_source_parser.set_defaults(func=cmd_source)
    
    # Variable commands
    list_vars_parser = subparsers.add_parser('list-variables', help='List all exported variables/constants')
    list_vars_parser.add_argument('--module', help='Filter by specific module (core, colors, types, validation)')
    list_vars_parser.add_argument('--values', action='store_true', help='Show variable values and previews')
    list_vars_parser.set_defaults(func=cmd_list_variables)
    
    variable_parser = subparsers.add_parser('variable', help='Show detailed information about a specific variable/constant')
    variable_parser.add_argument('name', help='Variable name (e.g., TAILWIND_COLORS, tw)')
    variable_parser.set_defaults(func=cmd_variable_details)
    
    variable_source_parser = subparsers.add_parser('variable-source', help='Show source definition of a specific variable/constant')
    variable_source_parser.add_argument('name', help='Variable name (e.g., TAILWIND_COLORS, tw)')
    variable_source_parser.set_defaults(func=cmd_variable_source)
    
    # Type commands
    list_types_parser = subparsers.add_parser('list-types', help='List all type definitions')
    list_types_parser.add_argument('--module', help='Filter by specific module (types, colors, validation)')
    list_types_parser.add_argument('--definitions', action='store_true', help='Show type definitions and details')
    list_types_parser.set_defaults(func=cmd_list_types)
    
    type_parser = subparsers.add_parser('type', help='Show detailed information about a specific type definition')
    type_parser.add_argument('name', help='Type name (e.g., SpacingValue, ColorValue)')
    type_parser.set_defaults(func=cmd_type_details)
    
    type_source_parser = subparsers.add_parser('type-source', help='Show source definition of a specific type')
    type_source_parser.add_argument('name', help='Type name (e.g., SpacingValue, ColorValue)')
    type_source_parser.set_defaults(func=cmd_type_source)
    
    # Import commands
    list_imports_parser = subparsers.add_parser('list-imports', help='List all recommended import patterns')
    list_imports_parser.add_argument('--use-case', help='Filter by specific use case')
    list_imports_parser.add_argument('--detailed', action='store_true', help='Show detailed import information')
    list_imports_parser.set_defaults(func=cmd_list_imports)
    
    import_parser = subparsers.add_parser('import', help='Show detailed information about a specific import pattern')
    import_parser.add_argument('pattern', help='Import pattern name (e.g., core, layout_methods, types)')
    import_parser.set_defaults(func=cmd_import_details)
    
    # Module command
    module_parser = subparsers.add_parser('module', help='Show detailed information about a specific module')
    module_parser.add_argument('name', help='Module name (core, layout, style, variants, modern)')
    module_parser.set_defaults(func=cmd_module_info)
    
    # Search command
    search_parser = subparsers.add_parser('search', help='Search for methods by keyword')
    search_parser.add_argument('keyword', help='Keyword to search for')
    search_parser.set_defaults(func=cmd_search)
    
    # Parse arguments
    args = parser.parse_args()
    
    # Execute command
    if args.command:
        args.func(args)
    else:
        parser.print_help()
