"""
Tests for core notebook operations in notebook_ops.py.
"""

import pytest
import os
import nbformat
from unittest import mock
from pathlib import Path
import logging
from io import StringIO
import asyncio
import sys
import atexit
from contextlib import suppress

# Now import functions to test
from cursor_notebook_mcp import notebook_ops
from cursor_notebook_mcp.server import setup_logging

# --- Fixtures for isolated mocking ---

# Using the event_loop fixture from conftest.py

@pytest.fixture
def mock_sftp_operations(monkeypatch, request):
    """Mock SFTP operations for tests that use remote functionality"""
    # Create mock SFTP manager
    mock_sftp_mgr = mock.MagicMock()
    
    # Setup common SFTP operations behavior
    mock_sftp_mgr.read_file.return_value = b"{\"cells\": [], \"metadata\": {}, \"nbformat\": 4, \"nbformat_minor\": 5}"
    mock_sftp_mgr.translate_path.return_value = (True, "/remote/path/notebook.ipynb", ("mock_client", "mock_sftp"))
    mock_sftp_mgr._get_absolute_remote_path.return_value = "/remote/path/notebook.ipynb"
    
    # Create mock connection and SFTP client
    mock_client = mock.MagicMock()
    mock_sftp = mock.MagicMock()
    mock_sftp.normalize.return_value = "/remote/path"
    
    # Add path mappings for permission checks
    mock_sftp_mgr.connections = {"hostname": (mock_client, mock_sftp)}
    mock_sftp_mgr.path_mappings = {
        "user@hostname:/remote/path": ("hostname", "user", "/remote/path/", "/local/path/")
    }
    
    # Mock home directory query
    mock_sftp_mgr._get_remote_home_dir.return_value = "/home/user"
    
    # Use monkeypatch for safer function-level patching
    monkeypatch.setattr('cursor_notebook_mcp.notebook_ops.SFTPManager', lambda: mock_sftp_mgr)
    
    # Add finalizer to ensure proper cleanup
    def finalizer():
        # Reset any mocks that might be causing issues
        mock_sftp_mgr.reset_mock()
        mock_client.reset_mock()
        mock_sftp.reset_mock()
    
    request.addfinalizer(finalizer)
    
    return mock_sftp_mgr

@pytest.mark.asyncio
async def test_read_notebook_io_error(tmp_path):
    """Test read_notebook handles IOError during the underlying read."""
    dummy_path = tmp_path / "dummy_read_io.ipynb"
    dummy_path.write_text("{\"cells\": [], \"metadata\": {}, \"nbformat\": 4, \"nbformat_minor\": 5}")
    allowed_roots = [str(tmp_path)]
    
    # Simulate IOError during the to_thread call directly
    async def mock_to_thread(*args, **kwargs):
        # Simulate the error that would happen inside the thread
        raise IOError("Simulated Cannot read file")

    # Patch asyncio.to_thread within notebook_ops for this test
    with mock.patch('cursor_notebook_mcp.notebook_ops.asyncio.to_thread', side_effect=mock_to_thread):
        # The IOError from the mocked to_thread should propagate out
        # Match the wrapper function's message
        with pytest.raises(IOError, match=r"Failed to read local notebook file.*?Simulated Cannot read file"):
            # Add a timeout to prevent hanging
            try:
                await asyncio.wait_for(
                    notebook_ops.read_notebook(str(dummy_path), allowed_roots),
                    timeout=5.0
                )
            except asyncio.TimeoutError:
                pytest.fail("Test timed out after 5 seconds")

@pytest.mark.asyncio
async def test_read_notebook_validation_error(tmp_path):
    """Test read_notebook handles ValidationError during parsing."""
    dummy_path = tmp_path / "dummy_validation.ipynb"
    # Write valid JSON but invalid notebook structure
    dummy_path.write_text("{\"invalid_notebook_structure\": true}") 
    allowed_roots = [str(tmp_path)]
    validation_error_instance = nbformat.ValidationError("Invalid notebook format")
    
    # Mock nbformat.reads (which happens after file read) to raise ValidationError
    with mock.patch('nbformat.reads', side_effect=validation_error_instance):
        # The function should catch ValidationError and raise IOError
        # Match the message generated by the exception wrapper
        with pytest.raises(IOError, match=r"An unexpected error occurred while reading.*?Invalid notebook format"):
            # Add a timeout to prevent hanging
            try:
                await asyncio.wait_for(
                    notebook_ops.read_notebook(str(dummy_path), allowed_roots),
                    timeout=5.0
                )
            except asyncio.TimeoutError:
                pytest.fail("Test timed out after 5 seconds")

@pytest.mark.asyncio
async def test_write_notebook_io_error(tmp_path):
    """Test write_notebook handles IOError from nbformat.write."""
    dummy_path = tmp_path / "dummy_write.ipynb"
    # Do not create the file beforehand for write test
    allowed_roots = [str(tmp_path)]
    nb = nbformat.v4.new_notebook() # Create an empty notebook object
    
    # Mock nbformat.write to raise IOError
    with mock.patch('nbformat.write', side_effect=IOError("Cannot write file")):
        with pytest.raises(IOError, match="Cannot write file"):
            # Add a timeout to prevent hanging
            try:
                await asyncio.wait_for(
                    notebook_ops.write_notebook(str(dummy_path), nb, allowed_roots),
                    timeout=5.0
                )
            except asyncio.TimeoutError:
                pytest.fail("Test timed out after 5 seconds")

@pytest.mark.asyncio
async def test_read_notebook_file_not_found(tmp_path):
    """Test read_notebook handles FileNotFoundError."""
    non_existent_path = tmp_path / "non_existent.ipynb"
    allowed_roots = [str(tmp_path)]
    
    # Ensure the file does not exist
    assert not non_existent_path.exists()
    
    with pytest.raises(FileNotFoundError):
        # Add a timeout to prevent hanging
        try:
            await asyncio.wait_for(
                notebook_ops.read_notebook(str(non_existent_path), allowed_roots),
                timeout=5.0
            )
        except asyncio.TimeoutError:
            pytest.fail("Test timed out after 5 seconds")

@pytest.mark.asyncio
async def test_read_notebook_generic_exception(tmp_path):
    """Test read_notebook handles generic Exception during read/parse."""
    dummy_path = tmp_path / "dummy_generic_read.ipynb"
    dummy_path.write_text("{\"cells\": [], \"metadata\": {}, \"nbformat\": 4, \"nbformat_minor\": 5}") # Valid structure
    allowed_roots = [str(tmp_path)]
    generic_error = Exception("Some generic read/parse error")

    # Mock nbformat.reads to raise a generic exception
    with mock.patch('nbformat.reads', side_effect=generic_error):
        # Match the message generated by the exception wrapper
        with pytest.raises(IOError, match=r"An unexpected error occurred while reading.*?Some generic read/parse error"):
            # Add a timeout to prevent hanging
            try:
                await asyncio.wait_for(
                    notebook_ops.read_notebook(str(dummy_path), allowed_roots),
                    timeout=5.0
                )
            except asyncio.TimeoutError:
                pytest.fail("Test timed out after 5 seconds")

@pytest.mark.asyncio
async def test_write_notebook_generic_exception(tmp_path):
    """Test write_notebook handles generic Exception from the write implementation."""
    dummy_path = tmp_path / "dummy_generic_write.ipynb"
    allowed_roots = [str(tmp_path)]
    nb = nbformat.v4.new_notebook()
    generic_error = Exception("Some generic write error")

    # Mock the specific write function called within the thread (nbformat.write)
    with mock.patch('nbformat.write', side_effect=generic_error):
        # Expect the wrapper exception message
        with pytest.raises(IOError, match=r"Failed to write local notebook.*?Some generic write error"):
            # Add a timeout to prevent hanging
            try:
                await asyncio.wait_for(
                    notebook_ops.write_notebook(str(dummy_path), nb, allowed_roots),
                    timeout=5.0
                )
            except asyncio.TimeoutError:
                pytest.fail("Test timed out after 5 seconds")


# --- setup_logging Tests (Synchronous) ---

# Removed: test_setup_logging_makedirs_error - Kept in tests/test_server.py as setup_logging is a server utility.
# @mock.patch('os.makedirs', side_effect=OSError("Permission denied to create dir"))
# @mock.patch('logging.FileHandler') # Mock FileHandler to prevent actual file creation
# @mock.patch('sys.stderr', new_callable=StringIO) # Use imported StringIO
# def test_setup_logging_makedirs_error(mock_stderr, mock_filehandler, mock_makedirs, tmp_path):
#     """Test setup_logging handles OSError when creating log directory."""
#     log_dir = str(tmp_path / "unwritable_logs")
#     setup_logging(log_dir, logging.INFO)
# 
#     mock_makedirs.assert_called_once_with(log_dir, exist_ok=True)
#     # Check that the error was printed to stderr
#     assert "Could not create log directory" in mock_stderr.getvalue()
#     assert "Permission denied to create dir" in mock_stderr.getvalue()
#     # Check that FileHandler was NOT called because log_dir creation failed
#     mock_filehandler.assert_not_called()

# Removed: test_setup_logging_filehandler_error - Kept in tests/test_server.py as setup_logging is a server utility.

# --- Additional Tests for notebook_ops.py Coverage ---

def test_is_path_allowed_empty_roots():
    """Test is_path_allowed behavior with empty allowed_roots list."""
    test_path = "/some/path"
    allowed_roots = []
    
    # Function should return False if no roots are configured
    assert not notebook_ops.is_path_allowed(test_path, allowed_roots)

def test_is_path_allowed_path_resolve_error():
    """Test is_path_allowed behavior when path resolution fails."""
    with mock.patch('os.path.realpath', side_effect=Exception("Path resolution error")):
        test_path = "/some/path"
        allowed_roots = ["/allowed/root"]
        
        # Function should return False if path resolution fails
        assert not notebook_ops.is_path_allowed(test_path, allowed_roots)

def test_is_path_allowed_root_resolve_error():
    """Test is_path_allowed behavior when allowed root resolution fails."""
    # First call returns successfully, second call raises exception
    def mock_realpath(path):
        if path == "/some/path":
            return "/some/path"
        raise Exception("Root resolution error")
    
    with mock.patch('os.path.realpath', side_effect=mock_realpath):
        test_path = "/some/path"
        allowed_roots = ["/allowed/root"]
        
        # Function should continue to the next root and return False
        assert not notebook_ops.is_path_allowed(test_path, allowed_roots)

@pytest.mark.asyncio
async def test_read_notebook_non_absolute_path(tmp_path):
    """Test read_notebook correctly resolves relative paths within allowed roots."""
    allowed_roots = [str(tmp_path)]
    relative_path = "subdir/my_notebook.ipynb" # Relative path
    absolute_path = tmp_path / relative_path
    
    # Create the file at the expected absolute location
    absolute_path.parent.mkdir(parents=True, exist_ok=True)
    # Write minimal valid notebook content
    nb_content = nbformat.v4.new_notebook()
    nbformat.write(nb_content, str(absolute_path))
    
    # Read using the relative path
    try:
        nb_read = await notebook_ops.read_notebook(relative_path, allowed_roots)
        assert isinstance(nb_read, nbformat.NotebookNode) # Verify successful read
    except Exception as e:
        pytest.fail(f"Read with relative path failed unexpectedly: {e}")
    finally:
        # Clean up
        if absolute_path.exists():
            absolute_path.unlink()
        if absolute_path.parent.exists():
            # Only remove if empty, might interfere with other tests otherwise
            try: 
                absolute_path.parent.rmdir()
            except OSError:
                pass # Ignore if not empty

@pytest.mark.asyncio
async def test_read_notebook_outside_allowed_roots(tmp_path):
    """Test read_notebook rejects paths outside allowed roots."""
    dummy_path = "/some/other/root/notebook.ipynb"
    allowed_roots = [str(tmp_path)]
    
    # Update the match pattern for the more specific error message
    match_pattern = r"Access denied: Path '.*?' resolves to '.*?' which is outside allowed local allowed roots defined by --allow-root."
    with pytest.raises(PermissionError, match=match_pattern):
        await notebook_ops.read_notebook(dummy_path, allowed_roots)

@pytest.mark.asyncio
async def test_read_notebook_invalid_extension(tmp_path):
    """Test read_notebook rejects non-notebook files by extension."""
    dummy_path = tmp_path / "not_a_notebook.txt"
    dummy_path.touch()
    allowed_roots = [str(tmp_path)]
    
    # Adjust the regex to match the exact error message format
    with pytest.raises(ValueError, match=r"Invalid notebook path: '.*not_a_notebook\.txt'"):
        await notebook_ops.read_notebook(str(dummy_path), allowed_roots)

@pytest.mark.asyncio
async def test_write_notebook_non_absolute_path(tmp_path):
    """Test write_notebook correctly resolves relative paths within allowed roots."""
    allowed_roots = [str(tmp_path)]
    relative_path = "subdir/my_write_notebook.ipynb" # Relative path
    absolute_path = tmp_path / relative_path
    nb = nbformat.v4.new_notebook()

    # Ensure path doesn't exist initially
    if absolute_path.exists():
        absolute_path.unlink()
    if absolute_path.parent.exists():
        absolute_path.parent.rmdir()
    assert not absolute_path.exists()
    assert not absolute_path.parent.exists()

    # Write using the relative path
    try:
        await notebook_ops.write_notebook(relative_path, nb, allowed_roots)
        # Verify file was created at the correct absolute path
        assert absolute_path.exists()
        # Verify content is valid notebook (basic check)
        nb_read = nbformat.read(str(absolute_path), as_version=4)
        assert isinstance(nb_read, nbformat.NotebookNode)
    except Exception as e:
        pytest.fail(f"Write with relative path failed unexpectedly: {e}")
    finally:
        # Clean up
        if absolute_path.exists():
            absolute_path.unlink()
        if absolute_path.parent.exists():
             try: 
                 absolute_path.parent.rmdir()
             except OSError:
                 pass

@pytest.mark.asyncio
async def test_write_notebook_outside_allowed_roots(tmp_path):
    """Test write_notebook rejects paths outside allowed roots."""
    dummy_path = "/some/other/root/notebook.ipynb"
    allowed_roots = [str(tmp_path)]
    nb = nbformat.v4.new_notebook()
    
    # Update the match pattern for the more specific error message
    match_pattern = r"Access denied: Path '.*?' resolves to '.*?' which is outside allowed local allowed roots defined by --allow-root."
    with pytest.raises(PermissionError, match=match_pattern):
        await notebook_ops.write_notebook(dummy_path, nb, allowed_roots)

@pytest.mark.asyncio
async def test_write_notebook_invalid_extension(tmp_path):
    """Test write_notebook rejects non-notebook files by extension."""
    dummy_path = str(tmp_path / "not_a_notebook.txt")
    allowed_roots = [str(tmp_path)]
    nb = nbformat.v4.new_notebook()
    
    # Adjust the regex to match the exact error message format
    with pytest.raises(ValueError, match=r"Invalid notebook path for writing: '.*not_a_notebook\.txt'"):
        await notebook_ops.write_notebook(dummy_path, nb, allowed_roots)

@pytest.mark.asyncio
async def test_write_notebook_create_parent_dir(tmp_path):
    """Test write_notebook creates parent directory."""
    parent_dir = tmp_path / "nested" / "dir"
    dummy_path = parent_dir / "notebook.ipynb"
    allowed_roots = [str(tmp_path)]
    nb = nbformat.v4.new_notebook()
    
    # Ensure the parent directory doesn't exist yet
    assert not parent_dir.exists()
    
    # Mock the directory creation and nbformat.write to verify they're called
    with mock.patch('os.path.isdir', return_value=False), \
         mock.patch('os.makedirs') as mock_makedirs, \
         mock.patch('nbformat.write') as mock_write:
        
        await notebook_ops.write_notebook(str(dummy_path), nb, allowed_roots)
        
        mock_makedirs.assert_called_once_with(str(parent_dir), exist_ok=True)
        mock_write.assert_called_once()

@pytest.mark.asyncio
async def test_write_notebook_parent_dir_creation_fails(tmp_path):
    """Test write_notebook handles error during parent directory creation."""
    parent_dir = tmp_path / "nested" / "dir"
    dummy_path = parent_dir / "notebook.ipynb"
    allowed_roots = [str(tmp_path)]
    nb = nbformat.v4.new_notebook()
    
    # Mock directory checks and creation to simulate failure
    # Mocking os.makedirs is correct here as it's called for local writes
    with mock.patch('os.makedirs', side_effect=OSError("Failed to create directory")):
        # Adjust regex to match the actual IOError message from the wrapper
        with pytest.raises(IOError, match=r"Could not create local directory.*?Failed to create directory"):
            await notebook_ops.write_notebook(str(dummy_path), nb, allowed_roots)

# Removed test_read_notebook_remote_path as its functionality is covered by the version in tests/test_notebook_ops_isolated.py
# @pytest.mark.asyncio
# async def test_read_notebook_remote_path(mock_sftp_operations):
#     """Test reading a notebook from a remote path via SFTP."""
#     remote_path = "ssh://user@hostname:/path/to/notebook.ipynb"
#     allowed_roots = ["/some/root"]
    
#     # Mock path resolution to return a permitted path
#     with mock.patch('cursor_notebook_mcp.notebook_ops.resolve_path_and_check_permissions', 
#                     return_value=(True, "/remote/path/notebook.ipynb")):
#         await notebook_ops.read_notebook(remote_path, allowed_roots, sftp_manager=mock_sftp_operations)
    
#     # Verify SFTPManager was used correctly
#     mock_sftp_operations.read_file.assert_called_once()

# Removed: test_write_notebook_remote_path - Kept in tests/test_notebook_ops_isolated.py as it handles SFTP/paramiko mocking.
# @pytest.mark.asyncio
# async def test_write_notebook_remote_path(mock_sftp_operations):
#     """Test writing a notebook to a remote path via SFTP."""
#     remote_path = "ssh://user@hostname:/path/to/notebook.ipynb"
#     allowed_roots = ["/some/root"]
#     nb = nbformat.v4.new_notebook()
#     
#     # Mock path resolution to return a permitted path
#     with mock.patch('cursor_notebook_mcp.notebook_ops.resolve_path_and_check_permissions', 
#                     return_value=(True, "/remote/path/notebook.ipynb")):
#         await notebook_ops.write_notebook(remote_path, nb, allowed_roots, sftp_manager=mock_sftp_operations)
#     
#     # Verify SFTPManager was used correctly
#     mock_sftp_operations.write_file.assert_called_once()