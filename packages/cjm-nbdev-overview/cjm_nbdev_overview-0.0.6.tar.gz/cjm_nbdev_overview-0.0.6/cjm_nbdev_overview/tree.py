"""Generate tree visualizations for nbdev project structure"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_tree.ipynb.

# %% ../nbs/02_tree.ipynb 3
from __future__ import annotations
from pathlib import Path
from typing import List, Optional, Dict, Any
from nbdev.config import get_config
from .core import *
import re

# %% auto 0
__all__ = ['generate_tree_lines', 'generate_tree', 'extract_notebook_info', 'generate_tree_with_descriptions',
           'generate_subdirectory_tree', 'get_tree_summary']

# %% ../nbs/02_tree.ipynb 5
def generate_tree_lines(path: Path,                         # Directory to visualize
                       prefix: str = "",                    # Line prefix for tree structure
                       is_last: bool = True,                # Is this the last item in parent
                       show_notebooks_only: bool = False,   # Only show notebooks, not directories
                       max_depth: Optional[int] = None,     # Maximum depth to traverse
                       current_depth: int = 0,              # Current depth in traversal
                       exclude_index: bool = True           # Exclude index.ipynb from tree
                       ) -> List[str]:                      # Lines of tree output
    "Generate tree visualization lines for a directory"
    lines = []
    
    # Check depth limit
    if max_depth is not None and current_depth >= max_depth:
        return lines
    
    # Get items to process
    subdirs = sorted([d for d in path.iterdir() if d.is_dir()])
    notebooks = get_notebook_files(path, recursive=False)
    
    # Filter out index.ipynb if exclude_index is True
    if exclude_index:
        notebooks = [nb for nb in notebooks if nb.name not in ['index.ipynb', '00_index.ipynb']]
    
    # Combine items based on show_notebooks_only
    if show_notebooks_only:
        items = [(nb, 'file') for nb in notebooks]
    else:
        items = [(d, 'dir') for d in subdirs] + [(nb, 'file') for nb in notebooks]
    
    # Generate lines for each item
    for i, (item, item_type) in enumerate(items):
        is_last_item = (i == len(items) - 1)
        connector = "└── " if is_last_item else "├── "
        
        if item_type == 'dir':
            # Directory line
            lines.append(f"{prefix}{connector}{item.name}/")
            
            # Recursive call for subdirectory
            next_prefix = prefix + ("    " if is_last_item else "│   ")
            child_lines = generate_tree_lines(
                item, next_prefix, is_last_item, show_notebooks_only, 
                max_depth, current_depth + 1, exclude_index
            )
            lines.extend(child_lines)
        else:
            # Notebook file line
            lines.append(f"{prefix}{connector}{item.name}")
    
    return lines

# %% ../nbs/02_tree.ipynb 6
def generate_tree(path: Path = None,                    # Directory to visualize (defaults to nbs_path)
                 show_notebooks_only: bool = False,     # Only show notebooks, not directories
                 max_depth: Optional[int] = None,       # Maximum depth to traverse
                 exclude_index: bool = True             # Exclude index.ipynb from tree
                 ) -> str:                              # Tree visualization as string
    "Generate a tree visualization for a directory"
    if path is None:
        cfg = get_config()
        path = cfg.nbs_path
    
    # Start with the root directory name
    lines = [f"{path.name}/"]
    
    # Generate tree lines
    tree_lines = generate_tree_lines(path, "", True, show_notebooks_only, max_depth, 0, exclude_index)
    lines.extend(tree_lines)
    
    return '\n'.join(lines)

# %% ../nbs/02_tree.ipynb 10
def extract_notebook_info(path: Path                    # Path to notebook file
                         ) -> NotebookInfo:             # Notebook information
    "Extract title and description from a notebook"
    nb_info = NotebookInfo(
        path=path,
        name=path.stem
    )
    
    try:
        nb_content = read_notebook(path)
        cells = nb_content.get('cells', [])
        
        if not cells:
            return nb_info
        
        # Look for default_exp in first few code cells
        for cell in cells[:5]:
            if cell.get('cell_type') == 'code':
                source = get_cell_source(cell)
                if '#| default_exp' in source:
                    match = re.search(r'#\|\s*default_exp\s+(\S+)', source)
                    if match:
                        nb_info.export_module = match.group(1)
        
        # Extract title and description from first markdown cell
        for cell in cells:
            if cell.get('cell_type') == 'markdown':
                source = get_cell_source(cell)
                lines = source.strip().split('\n')
                
                if not lines:
                    continue
                
                # Look for H1 title
                for i, line in enumerate(lines):
                    if line.strip().startswith('# '):
                        nb_info.title = line.strip()[2:].strip()
                        
                        # Look for blockquote description after the title
                        # It could be on any subsequent line
                        for j in range(i + 1, len(lines)):
                            if lines[j].strip().startswith('> '):
                                nb_info.description = lines[j].strip()[2:].strip()
                                break
                            elif lines[j].strip() and not lines[j].strip().startswith('>'):
                                # If we hit a non-empty, non-blockquote line, stop looking
                                break
                        break
                
                # If we found a title, we're done
                if nb_info.title:
                    break
    
    except Exception:
        # If we can't read the notebook, just return basic info
        pass
    
    return nb_info

# %% ../nbs/02_tree.ipynb 13
def generate_tree_with_descriptions(path: Path = None,              # Directory to visualize
                                   show_counts: bool = True,        # Show notebook counts for directories
                                   max_depth: Optional[int] = None, # Maximum depth to traverse
                                   exclude_index: bool = True       # Exclude index.ipynb from tree
                                   ) -> str:                        # Tree with descriptions
    "Generate tree visualization with descriptions from notebooks"
    if path is None:
        cfg = get_config()
        path = cfg.nbs_path
    
    lines = []
    
    # Check if this is a flat structure (no subdirectories)
    subdirs = get_subdirectories(path, recursive=False)
    is_flat = len(subdirs) == 0
    
    if is_flat:
        # Flat structure - show notebooks with descriptions
        lines.append(f"{path.name}/")
        notebooks = get_notebook_files(path, recursive=False)
        
        # Filter out index.ipynb if exclude_index is True
        if exclude_index:
            notebooks = [nb for nb in notebooks if nb.name not in ['index.ipynb', '00_index.ipynb']]
        
        for i, nb_path in enumerate(notebooks):
            is_last = (i == len(notebooks) - 1)
            connector = "└── " if is_last else "├── "
            
            # Extract notebook info
            nb_info = extract_notebook_info(nb_path)
            
            # Format line with description
            if nb_info.description:
                line = f"{connector}{nb_path.name}".ljust(28) + f" # {nb_info.description}"
            else:
                line = f"{connector}{nb_path.name}"
            
            lines.append(line)
    else:
        # Nested structure - show directories with counts and descriptions
        lines.append(f"{path.name}/")
        lines.extend(_generate_nested_tree_lines(path, "", show_counts, max_depth, 0, exclude_index))
    
    return '\n'.join(lines)

# %% ../nbs/02_tree.ipynb 14
def _generate_nested_tree_lines(path: Path,                         # Directory to process
                               prefix: str = "",                    # Line prefix
                               show_counts: bool = True,            # Show notebook counts
                               max_depth: Optional[int] = None,     # Maximum depth
                               current_depth: int = 0,              # Current depth
                               exclude_index: bool = True           # Exclude index.ipynb from tree
                               ) -> List[str]:                      # Tree lines
    "Generate tree lines for nested directory structure"
    lines = []
    
    # Check depth limit
    if max_depth is not None and current_depth >= max_depth:
        return lines
    
    # Get subdirectories and notebooks
    subdirs = get_subdirectories(path, recursive=False)
    notebooks = get_notebook_files(path, recursive=False)
    
    # Filter out index.ipynb if exclude_index is True
    if exclude_index:
        notebooks = [nb for nb in notebooks if nb.name not in ['index.ipynb', '00_index.ipynb']]
    
    # Combine and sort all items
    all_items = []
    
    # Add subdirectories
    for subdir in subdirs:
        all_nb_files = get_notebook_files(subdir, recursive=True)
        # Filter out index.ipynb from counts if exclude_index is True
        if exclude_index:
            all_nb_files = [nb for nb in all_nb_files if nb.name not in ['index.ipynb', '00_index.ipynb']]
        
        notebook_count = len(all_nb_files)
        
        if show_counts and notebook_count > 0:
            all_items.append((subdir, 'dir', f"({notebook_count})"))
        else:
            all_items.append((subdir, 'dir', ""))
    
    # Add notebooks in current directory
    for nb_path in notebooks:
        nb_info = extract_notebook_info(nb_path)
        if nb_info.description:
            all_items.append((nb_path, 'file', f"# {nb_info.description}"))
        else:
            all_items.append((nb_path, 'file', ""))
    
    # Generate lines for each item
    for i, (item, item_type, annotation) in enumerate(all_items):
        is_last = (i == len(all_items) - 1)
        connector = "└── " if is_last else "├── "
        
        if item_type == 'dir':
            # Directory with count
            dir_line = f"{prefix}{connector}{item.name}/"
            if annotation:
                dir_line += f" {annotation}"
            lines.append(dir_line)
            
            # Recurse into subdirectory
            next_prefix = prefix + ("    " if is_last else "│   ")
            child_lines = _generate_nested_tree_lines(
                item, next_prefix, show_counts, max_depth, 
                current_depth + 1, exclude_index
            )
            lines.extend(child_lines)
        else:
            # Notebook file
            nb_line = f"{prefix}{connector}{item.name}"
            if annotation:
                # Pad the filename to align descriptions
                nb_line = nb_line.ljust(len(prefix) + 28) + f" {annotation}"
            lines.append(nb_line)
    
    return lines

# %% ../nbs/02_tree.ipynb 18
def generate_subdirectory_tree(subdir_path: Path,               # Path to subdirectory
                              show_descriptions: bool = True    # Include notebook descriptions
                              ) -> str:                         # Tree visualization
    "Generate tree visualization for a specific subdirectory showing all notebooks"
    lines = [f"{subdir_path.name}/"]
    
    # Process all items (subdirs and notebooks) in order
    items = []
    
    # Get subdirectories
    subdirs = get_subdirectories(subdir_path, recursive=False)
    for subdir in subdirs:
        items.append((subdir, True))
    
    # Get notebooks
    notebooks = get_notebook_files(subdir_path, recursive=False)
    for notebook in notebooks:
        items.append((notebook, False))
    
    # Sort by name
    items.sort(key=lambda x: x[0].name.lower())
    
    # Generate tree lines
    for i, (item, is_dir) in enumerate(items):
        is_last = (i == len(items) - 1)
        lines.extend(_generate_subdirectory_lines(
            item, "", is_last, is_dir, show_descriptions, 0
        ))
    
    return '\n'.join(lines)

# %% ../nbs/02_tree.ipynb 19
def _generate_subdirectory_lines(item: Path,                    # Item to process
                                prefix: str,                    # Line prefix
                                is_last: bool,                  # Is last item
                                is_dir: bool,                   # Is directory
                                show_descriptions: bool,        # Show descriptions
                                depth: int                      # Current depth
                                ) -> List[str]:                 # Tree lines
    "Generate tree lines for subdirectory visualization"
    lines = []
    
    connector = "└── " if is_last else "├── "
    extension = "    " if is_last else "│   "
    
    if is_dir:
        # Directory entry
        line = f"{prefix}{connector}{item.name}/"
        lines.append(line)
        
        # Process subdirectory contents
        sub_items = []
        
        # Get nested subdirectories
        subdirs = get_subdirectories(item, recursive=False)
        for subdir in subdirs:
            sub_items.append((subdir, True))
        
        # Get notebooks in subdirectory
        notebooks = get_notebook_files(item, recursive=False)
        for notebook in notebooks:
            sub_items.append((notebook, False))
        
        # Sort by name
        sub_items.sort(key=lambda x: x[0].name.lower())
        
        # Generate lines for sub-items
        for j, (sub_item, sub_is_dir) in enumerate(sub_items):
            sub_is_last = (j == len(sub_items) - 1)
            lines.extend(_generate_subdirectory_lines(
                sub_item, prefix + extension, sub_is_last, 
                sub_is_dir, show_descriptions, depth + 1
            ))
    else:
        # Notebook entry
        if show_descriptions:
            nb_info = extract_notebook_info(item)
            if nb_info.description:
                line = f"{prefix}{connector}{item.name}".ljust(40) + f" # {nb_info.description}"
            else:
                line = f"{prefix}{connector}{item.name}"
        else:
            line = f"{prefix}{connector}{item.name}"
        
        lines.append(line)
    
    return lines

# %% ../nbs/02_tree.ipynb 21
def get_tree_summary(path: Path = None              # Directory to analyze
                    ) -> str:                       # Summary string
    "Get summary statistics for notebooks in directory tree"
    if path is None:
        cfg = get_config()
        path = cfg.nbs_path
    
    # Count notebooks
    total_notebooks = len(get_notebook_files(path, recursive=True))
    
    # Count directories
    subdirs = get_subdirectories(path, recursive=False)
    total_dirs = len(subdirs)
    
    if total_dirs == 0:
        return f"Total: {total_notebooks} notebook{'s' if total_notebooks != 1 else ''}"
    else:
        return f"Total: {total_notebooks} notebook{'s' if total_notebooks != 1 else ''} across {total_dirs} director{'ies' if total_dirs != 1 else 'y'}"
