// Copyright (c) 2024 PAL Robotics S.L. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef {{ id | upper }}__NODE_{{ id | upper }}_HPP_
#define {{ id | upper }}__NODE_{{ id | upper }}_HPP_

#include <memory>
#include <string>

#include "diagnostic_msgs/msg/diagnostic_array.hpp"
#include "kb_msgs/srv/query.hpp"
#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include "rclcpp_lifecycle/lifecycle_node.hpp"

// This is an example of a Locate skill action message generated by rpk
// alongside this package.
#include "locate_skill_msgs/action/locate.hpp"

namespace {{id}}
{
/** \brief Implementation of {{id}}.
  *
  * This is the main class for the skill. It is a ROS2 node that uses the
  * lifecycle feature of ROS2 to manage its states.
  *
  * This basic 'locate' skill template performs some basic
  * computation (querying a knowledge base) to try to locate an object.
  *
  * You can use it as a starting point to implement your own, more advanced,
  * 'Locate' skill.
  *
  * Don't forget to update accordingly the manifest of the skill, included in
  * locate_skill_msgs/package.xml, to describe what your skill is actually
  * doing.
  */
class Node{{Id}} : public rclcpp_lifecycle::LifecycleNode
{
public:
  using LifecycleCallbackReturn =
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn;
  using Locate = locate_skill_msgs::action::Locate;
  using LocateGoal = std::shared_ptr<const Locate::Goal>;
  using LocateGoalHandle = std::shared_ptr<rclcpp_action::ServerGoalHandle<Locate>>;

  struct LocateResult
  {
    std::string location;
    int error_code;
    std::string error_msg;
  };

  /** \brief Construct the skill node. */
  explicit Node{{Id}}(const rclcpp::NodeOptions & options = rclcpp::NodeOptions());
  /** \brief Destruct the skill node. */
  ~Node{{Id}}();

  ////////////////////////////////////////////////////////////////////////////////////////////////
  // Lifecycle transitions callbacks

  /** \brief Configure the skill node.
   *
   * You usually want to do the following in this transition:
   * - Read ROS parameters (if any)
   * - Create ROS action clients and servers
   * - Create ROS publishers and subscribers
   * - Start publishing diagnostic information
   *
   * While the skill is configured, but not activated, it should not
   * perform any actions that are not required for configuration, such as
   * effectively processing data or calling external services.
   * For instance, incoming goals on an action server should be rejected.
   */
  LifecycleCallbackReturn on_configure(const rclcpp_lifecycle::State &);

  /** \brief Activate the skill node.
   *
   * You usually want to do the following in this transition:
   * - Create and start any timers performing periodic tasks
   * - Start processing data, and accepting action goals, if any
   */
  LifecycleCallbackReturn on_activate(const rclcpp_lifecycle::State &);

  /** \brief Deactivate the skill node.
   *
   * You usually want to do the following in this transition:
   * - Stop any timer started in the "on_activate" transition
   * - Stop processing data and reject incoming action goals
   */
  LifecycleCallbackReturn on_deactivate(const rclcpp_lifecycle::State &);

  /** \brief Cleanup the configuration for the skill node.
   *
   * You usually want to do the following in this transition:
   * - Destroy ROS action clients and servers
   * - Destroy ROS publishers and subscribers
   * - Stop publishing diagnostic information
   */
  LifecycleCallbackReturn on_cleanup(const rclcpp_lifecycle::State &);

  /** \brief Shutdown the skill node.
   *
   * This makes the node transition to the "finalized" state,
   * a functionally dead end state which is not expected to be exited.
   */
  LifecycleCallbackReturn on_shutdown(const rclcpp_lifecycle::State &);

private:
  // Internal implementation for the "cleanup" transition
  void cleanup_impl();
  // Internal implementation for the "deactivate" transition
  void deactivate_impl();
  // Locate the item using the knowledge base.
  LocateResult locate_item(std::string target);
  // Accept the incoming goal, if appropriate.
  rclcpp_action::GoalResponse on_locate_request_goal(const rclcpp_action::GoalUUID &, LocateGoal);
  // Process an accepted incoming goal.
  void on_locate_request_accepted(const LocateGoalHandle goal_handle);
  // Periodically publish diagnostic information.
  void publish_diagnostics();
  // Main logic cycle of the node.
  void run();

  int nb_requests_;

  rclcpp::OnShutdownCallbackHandle on_shutdown_cb_handle_;
  rclcpp_action::Server<Locate>::SharedPtr skill_server_;
  std::shared_ptr<rclcpp::TimerBase> run_timer_;
  std::shared_ptr<rclcpp::TimerBase> diagnostics_timer_;
  rclcpp::Publisher<diagnostic_msgs::msg::DiagnosticArray>::SharedPtr diagnostics_pub_;

  rclcpp::CallbackGroup::SharedPtr kb_cb_group_;
  rclcpp::Client<kb_msgs::srv::Query>::SharedPtr kb_client_;
};

}  // namespace {{id}}

#endif  // {{ id | upper }}__NODE_{{ id | upper }}_HPP_

