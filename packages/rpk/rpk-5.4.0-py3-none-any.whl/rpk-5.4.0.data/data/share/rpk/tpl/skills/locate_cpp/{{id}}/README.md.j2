{{ name }}
====================

Welcome to your new robot 'localte' skill.

What are the next steps?

## Compile and install the skill

You need a ROS 2 environment to compile the template.

You can for instance use the ROS humble Docker image, or PAL Robotics own 
public 'tutorials' Docker image (itself based on ROS humble):

```
> docker pull palrobotics/public-tutorials-alum-devel
> docker run -it --name ros2_sandbox \
             -v <path to your workspace>:/home/user/exchange/ws \
             palrobotics/public-tutorials-alum-devel bash
```

Then, simply run:

```
> cd /home/user/exchange/ws
> colcon build
> source install/setup.bash
```

You can now start your skill with:

```
> ros2 launch {{id}} {{id}}.launch.py
```

## Testing

This basic skill template does not do much on this own. However, we can already check it works
as intended.

Open a second terminal, and run:

```
ros2 action list
```

> Note: you can open a new terminal in the same Docker image with:
> ```
> docker exec -it ros2_sandbox bash
> ```

You should see your skill action:

```
/skill/locate
```


We can trigger the skill (from a third terminal):

```
ros2 action send_goal /skill/locate locate_skill_msgs/action/Locate "skill_data: 'object'" 
```

You should get the following output:

```
Waiting for an action server to become available...
Sending goal:
     skill_data: object

Goal accepted with ID: a257b444a54d4f42911678d6f93e7e65

Result:
    result:
  error_code: 0
  error_msg: ''
    value: ''

Goal finished with status: SUCCEEDED
```

(or an error! you need a knowledge base for this simple skill template to actually
perform a query)

## Customize your skill

By default, the 'locate' template performs a semantic query to a running knowledge base
(using the `/kb/query` ROS service). In an actual robot system, you might want to
extend it with eg asking help from a human, or moving the robot's head around.

To implement your skill logic, have a look at the header file
`include/{{id}}/node_{{id}}.hpp` and the source file
`src/{{id}}/node_{{id}}.cpp`:
these are the main files you will have to modify.

You might also want to customize the API of your skill. Check the `locate_skill_msgs`
package that has been generated alongside this package, and feel free to modify
it & rename it as you see fit.

## Install on the robot

**To deploy the code to the robot, you have to run the following commands from
*inside* your PAL OS Developer Docker image**.

- from within the PAL OS Developer Docker image, go to root of the project
- run `ros2 run pal_deploy deploy --package {{ id }} {{ robot | lower
  }}-XXc` (replace `{{ robot | lower }}-XXc` by your actual robot)

You can now `ssh` onto the robot (`ssh pal@{{ robot | lower }}-XXc`, password
`pal`), and go to your project: `cd ~/deployed_ws/share/{{ id }}`

## Run your application

`ssh` onto the robot (`ssh pal@{{ robot | lower }}-XXc`, password `pal`).

There are several ways to run the application:

1. Automatically launch the app and transition to an active state:

`ros2 launch {{ id }} {{ id }}.launch.py`

2. Manually start your skill:

`ros2 run {{ id }} start_skill`

3. Automatically start your application at startup:

To make your application run at startup, uncomment the related lines in
`CMakeLists.txt` and reinstall the package. You can then start, stop or view the logs
of the application as a module. See [Application
management](https://docs.pal-robotics.com/edge/management/application-management)
for more details. 
