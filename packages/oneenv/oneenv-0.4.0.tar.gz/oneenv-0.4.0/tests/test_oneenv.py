import os
import pytest

from oneenv import (
    oneenv,
    template,
    generate_env_example,
    diff,
    set_key,
    unset_key,
    dotenv_values,
    load_dotenv,
    OneEnv,
    collect_templates,
    report_duplicates,
    env,
)
import oneenv as oneenv_module  # Used to clear the global registry

# Fixture to clear the template registry before each test
@pytest.fixture(autouse=True)
def clear_registry():
    oneenv_module._TEMPLATE_REGISTRY.clear()
    # Also clear the enhanced core registry
    from oneenv.core import _oneenv_core
    _oneenv_core._legacy_registry.clear()
    # Clear named environments registry
    oneenv_module._named_environments.clear()


# Define a sample template function for testing
@oneenv
def sample_template():
    """
    Returns a dictionary of environment variable settings for testing.
    """
    return {
        "TEST_VAR": {
            "description": "Test variable description.",
            "default": "value",
            "required": True,
            "choices": ["value", "other"]
        }
    }


# Define sample templates with group and importance for testing
@oneenv
def grouped_template():
    """
    Returns grouped environment variables for testing.
    """
    return {
        "HIGH_DATABASE_VAR": {
            "description": "High importance database variable",
            "default": "db_value",
            "required": True,
            "group": "Database",
            "importance": "high"
        },
        "MEDIUM_WEB_VAR": {
            "description": "Medium importance web variable",
            "default": "web_value",
            "required": False,
            "group": "Web",
            "importance": "medium"
        },
        "LOW_LOG_VAR": {
            "description": "Low importance logging variable",
            "default": "log_value",
            "required": False,
            "group": "Logging",
            "importance": "low"
        }
    }


def test_template_output():
    """
    Test that the generated template output contains expected lines:
    - The description
    - 'Required' if required is True
    - 'Choices: ...' if choices are provided
    - The variable assignment in the format DEFAULT=...
    """
    output = template()
    # Check for header and defined source
    assert "# Auto-generated by OneEnv" in output
    assert "# (Defined in: sample_template)" in output
    # Check description lines
    assert "# Test variable description." in output
    # Check for required and choices comments
    assert "# Required" in output
    assert "# Choices: value, other" in output
    # Check variable assignment
    assert "TEST_VAR=value" in output


def test_diff():
    """
    Test that diff() properly formats differences between texts.
    """
    previous_text = "TEST_VAR=old_value\n"
    current_text = "TEST_VAR=new_value\n"
    diff_output = diff(previous_text, current_text)
    # Expect a modification line in the format "~ old_line → new_line"
    expected_line = "~ TEST_VAR=old_value → TEST_VAR=new_value"
    assert expected_line in diff_output


def test_generate_env_example(tmp_path):
    """
    Test that generate_env_example() writes the same content as returned by template().
    """
    env_file = tmp_path / ".env.example"
    generate_env_example(str(env_file))
    written_content = env_file.read_text(encoding="utf-8")
    expected = template()
    assert written_content == expected


def test_set_and_unset_key(tmp_path):
    """
    Test set_key() and unset_key() functions by creating a temporary .env file,
    setting a key, updating it, then unsetting it.
    """
    env_file = tmp_path / ".env"
    # Start with an empty .env file
    env_file.write_text("", encoding="utf-8")
    
    # Set a key in the .env file and check content
    set_key(str(env_file), "MY_KEY", "123")
    content_after_set = env_file.read_text(encoding="utf-8")
    assert "MY_KEY=123" in content_after_set
    
    # Update the key value and check new content
    set_key(str(env_file), "MY_KEY", "456")
    content_after_update = env_file.read_text(encoding="utf-8")
    assert "MY_KEY=456" in content_after_update
    
    # Unset the key and verify it is removed
    unset_key(str(env_file), "MY_KEY")
    content_after_unset = env_file.read_text(encoding="utf-8")
    assert "MY_KEY=" not in content_after_unset


def test_dotenv_values(tmp_path):
    """
    Test that dotenv_values() correctly reads environment variables from a .env file.
    """
    env_file = tmp_path / ".env"
    env_file.write_text("MY_KEY=789\n", encoding="utf-8")
    values = dotenv_values(str(env_file))
    assert values["MY_KEY"] == "789"


def test_load_dotenv(tmp_path):
    """
    Test that load_dotenv() loads environment variables from a .env file into os.environ.
    """
    env_file = tmp_path / ".env"
    env_file.write_text("MY_LOAD_KEY=loaded_value\n", encoding="utf-8")
    # Ensure the environment variable is not already set
    if "MY_LOAD_KEY" in os.environ:
        del os.environ["MY_LOAD_KEY"]
    result = load_dotenv(str(env_file))
    assert result is True
    assert os.environ.get("MY_LOAD_KEY") == "loaded_value"


# English: Test class inheriting from OneEnv for testing purposes.
# Japanese: テスト用のOneEnvを継承したクラスです。
class TestLibTemplate(OneEnv):
    def get_template(self) -> dict:
        return {
            "TEST_LIB_KEY": {
                "description": "Test library key",
                "default": "test_value",
                "required": True
            }
        }


# English: Another test class for testing duplicate keys.
# Japanese: 重複キーのテスト用の別のクラスです。
class AnotherTestTemplate(OneEnv):
    def get_template(self) -> dict:
        return {
            "TEST_LIB_KEY": {  # Intentionally duplicate key
                "description": "Duplicate key for testing",
                "default": "another_value"
            }
        }


@oneenv
def test_template():
    """
    English: Test template function using the @oneenv decorator.
    Japanese: @oneenvデコレータを使用したテストテンプレート関数です。
    """
    return {
        "TEST_API_KEY": {
            "description": "Test API key",
            "default": "",
            "required": True
        }
    }




def test_oneenv_decorator():
    """
    English: Test that the @oneenv decorator correctly registers template functions.
    Japanese: @oneenvデコレータがテンプレート関数を正しく登録することをテストします。
    """
    templates = collect_templates()
    assert "TEST_API_KEY" in templates
    assert templates["TEST_API_KEY"]["config"]["description"] == "Test API key"
    assert "test_template" in templates["TEST_API_KEY"]["sources"]


def test_decorator_duplicate_keys():
    """
    English: Test that duplicate keys are properly handled and reported.
    Japanese: 重複キーが適切に処理され、報告されることをテストします。
    """
    # Define two decorated functions that return duplicate key "DUPLICATE_KEY"
    @oneenv
    def duplicate_template_A():
        return {
            "DUPLICATE_KEY": {
                "description": "Duplicate key from function A",
                "default": "A"
            }
        }

    @oneenv
    def duplicate_template_B():
        return {
            "DUPLICATE_KEY": {
                "description": "Duplicate key from function B",
                "default": "B"
            }
        }
    templates = collect_templates()
    assert "DUPLICATE_KEY" in templates
    sources = templates["DUPLICATE_KEY"]["sources"]
    # Check that both functions are registered for the duplicate key.
    assert "duplicate_template_A" in sources
    assert "duplicate_template_B" in sources


def test_template_generation():
    """
    English: Test that template generation includes both decorator and subclass templates.
    Japanese: テンプレート生成がデコレータとサブクラスの両方のテンプレートを含むことをテストします。
    """
    env_content = template()
    # Check that templates from decorated functions are included.
    # 'sample_template' returns key "TEST_VAR" and 'test_template' returns key "TEST_API_KEY".
    assert "TEST_VAR" in env_content
    assert "TEST_API_KEY" in env_content
    # The duplicate key from test_decorator_duplicate_keys should be in the generated output.
    assert "DUPLICATE_KEY" in env_content


def test_missing_description():
    """
    English: Test that templates without description raise ValueError.
    Japanese: 説明のないテンプレートがValueErrorを発生させることをテストします。
    """
    @oneenv
    def invalid_template():
        return {
            "INVALID_KEY": {
                "default": "value"  # Missing description
            }
        }
    
    with pytest.raises(ValueError):
        collect_templates()


def test_required_field():
    """
    English: Test that required field is properly reflected in template output.
    Japanese: required フィールドがテンプレート出力に正しく反映されることをテストします。
    """
    env_content = template()
    assert "# Required" in env_content


def test_named_environment_basic():
    """
    Test basic named environment functionality.
    """
    # Test common environment (no name)
    common_env = env()
    assert common_env.name is None
    
    # Test named environment
    named_env = env("X")
    assert named_env.name == "X"
    
    # Test that same name returns same instance
    same_env = env("X")
    assert same_env is named_env


def test_named_environment_load_dotenv(tmp_path):
    """
    Test loading .env files into named environments.
    """
    # Create test .env files
    common_env_file = tmp_path / "common.env"
    common_env_file.write_text("TIMEOUT=30\nCOMMON_VAR=common_value\n", encoding="utf-8")
    
    x_env_file = tmp_path / "X.env"
    x_env_file.write_text("API_KEY=x_key\nTIMEOUT=60\n", encoding="utf-8")
    
    # Load into different environments
    common_env = env()
    x_env = env("X")
    
    # Load the files
    assert common_env.load_dotenv(str(common_env_file)) is True
    assert x_env.load_dotenv(str(x_env_file)) is True
    
    # Test that values are loaded correctly
    assert common_env.get("TIMEOUT") == "30"
    assert common_env.get("COMMON_VAR") == "common_value"
    assert x_env.get("API_KEY") == "x_key"
    assert x_env.get("TIMEOUT") == "60"


def test_named_environment_fallback(tmp_path):
    """
    Test that named environments fall back to common environment.
    """
    # Create test .env files
    common_env_file = tmp_path / "common.env"
    common_env_file.write_text("TIMEOUT=30\nCOMMON_VAR=common_value\n", encoding="utf-8")
    
    x_env_file = tmp_path / "X.env"
    x_env_file.write_text("API_KEY=x_key\n", encoding="utf-8")
    
    # Load into environments
    common_env = env()
    x_env = env("X")
    
    common_env.load_dotenv(str(common_env_file))
    x_env.load_dotenv(str(x_env_file))
    
    # Test fallback behavior
    assert x_env.get("API_KEY") == "x_key"  # Found in X environment
    assert x_env.get("TIMEOUT") == "30"     # Falls back to common environment
    assert x_env.get("COMMON_VAR") == "common_value"  # Falls back to common environment
    assert x_env.get("NONEXISTENT", "default") == "default"  # Default value


def test_named_environment_override(tmp_path):
    """
    Test override behavior in named environments.
    """
    # Create test .env files
    env_file = tmp_path / "test.env"
    env_file.write_text("KEY1=value1\nKEY2=value2\n", encoding="utf-8")
    
    test_env = env("test")
    
    # Load without override
    test_env.load_dotenv(str(env_file))
    assert test_env.get("KEY1") == "value1"
    
    # Update file
    env_file.write_text("KEY1=new_value1\nKEY3=value3\n", encoding="utf-8")
    
    # Load without override (should not update existing keys)
    test_env.load_dotenv(str(env_file), override=False)
    assert test_env.get("KEY1") == "value1"  # Should not change
    assert test_env.get("KEY3") == "value3"  # Should be added
    
    # Load with override
    test_env.load_dotenv(str(env_file), override=True)
    assert test_env.get("KEY1") == "new_value1"  # Should be updated
    assert test_env.get("KEY2", None) is None  # Should be removed since not in new file


def test_named_environment_os_environ_fallback():
    """
    Test that environments fall back to OS environment variables.
    """
    # Set an OS environment variable
    os.environ["TEST_OS_VAR"] = "os_value"
    
    try:
        test_env = env("test")
        
        # Should fall back to OS environment
        assert test_env.get("TEST_OS_VAR") == "os_value"
        assert test_env.get("NONEXISTENT_VAR", "default") == "default"
        
    finally:
        # Clean up
        if "TEST_OS_VAR" in os.environ:
            del os.environ["TEST_OS_VAR"]


def test_named_environment_load_nonexistent_file():
    """
    Test loading from non-existent file returns False.
    """
    test_env = env("test")
    assert test_env.load_dotenv("/nonexistent/file.env") is False
    assert test_env.load_dotenv(None) is False


def test_multiple_named_environments(tmp_path):
    """
    Test multiple named environments working independently.
    """
    # Create test .env files
    common_env_file = tmp_path / "common.env"
    common_env_file.write_text("TIMEOUT=30\n", encoding="utf-8")
    
    x_env_file = tmp_path / "X.env"
    x_env_file.write_text("API_KEY=x_key\n", encoding="utf-8")
    
    y_env_file = tmp_path / "Y.env"
    y_env_file.write_text("API_KEY=y_key\n", encoding="utf-8")
    
    # Load into different environments
    common_env = env()
    x_env = env("X")
    y_env = env("Y")
    
    common_env.load_dotenv(str(common_env_file))
    x_env.load_dotenv(str(x_env_file))
    y_env.load_dotenv(str(y_env_file))
    
    # Test that environments are independent
    assert common_env.get("TIMEOUT") == "30"
    assert x_env.get("API_KEY") == "x_key"
    assert y_env.get("API_KEY") == "y_key"
    
    # Test fallback to common
    assert x_env.get("TIMEOUT") == "30"
    assert y_env.get("TIMEOUT") == "30" 