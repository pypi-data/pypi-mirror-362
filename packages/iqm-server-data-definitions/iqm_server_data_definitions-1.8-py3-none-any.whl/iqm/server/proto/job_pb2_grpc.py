# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

from . import common_pb2 as common__pb2
from . import job_pb2 as job__pb2

GRPC_GENERATED_VERSION = '1.71.0'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in job_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class JobsStub(object):
    """
    User job management APIs.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.SubmitJobV1 = channel.unary_unary(
                '/iqm.server.Jobs/SubmitJobV1',
                request_serializer=job__pb2.SubmitJobRequestV1.SerializeToString,
                response_deserializer=job__pb2.JobV1.FromString,
                _registered_method=True)
        self.GetJobV1 = channel.unary_unary(
                '/iqm.server.Jobs/GetJobV1',
                request_serializer=job__pb2.JobLookupV1.SerializeToString,
                response_deserializer=job__pb2.JobV1.FromString,
                _registered_method=True)
        self.SubscribeToJobV1 = channel.unary_stream(
                '/iqm.server.Jobs/SubscribeToJobV1',
                request_serializer=job__pb2.JobLookupV1.SerializeToString,
                response_deserializer=job__pb2.JobEventV1.FromString,
                _registered_method=True)
        self.GetJobPayloadV1 = channel.unary_stream(
                '/iqm.server.Jobs/GetJobPayloadV1',
                request_serializer=job__pb2.JobLookupV1.SerializeToString,
                response_deserializer=common__pb2.DataChunk.FromString,
                _registered_method=True)
        self.GetJobResultsV1 = channel.unary_stream(
                '/iqm.server.Jobs/GetJobResultsV1',
                request_serializer=job__pb2.JobLookupV1.SerializeToString,
                response_deserializer=common__pb2.DataChunk.FromString,
                _registered_method=True)
        self.CancelJobV1 = channel.unary_unary(
                '/iqm.server.Jobs/CancelJobV1',
                request_serializer=job__pb2.JobLookupV1.SerializeToString,
                response_deserializer=job__pb2.JobV1.FromString,
                _registered_method=True)


class JobsServicer(object):
    """
    User job management APIs.
    """

    def SubmitJobV1(self, request, context):
        """
        Submits a new job to the quantum computer. If the submit succeeds, returns
        the handle for the submitted job.

        ## Errors
        In case of an error, a GRPC error status is returned with some optional additional
        details. The possible error cases are described below:

        ### Invalid payload
        This error is returned if the given job payload is not accepted by the
        target quantum computer. Note that different quantum computers might
        accept different payloads.
        ```
        Code = "INVALID_ARGUMENT"
        Metadata.error_code = "invalid_payload"
        Details = https://protobuf.dev/reference/protobuf/google.protobuf/#value
        {
        "errors": [<list-of-error-messages>]
        }
        ```

        ### Job type not supported
        This error is returned if the target quantum computer does not support the
        given job type (circuit, pulse).
        ```
        Code = "FAILED_PRECONDITION"
        Metadata.error_code = "job_type_not_supported"
        ```

        ### User job quota exceeded
        This error is returned if the user has already submitted the maximum allowed
        amount of jobs to the queue. Quota can be freed by either waiting for existing
        jobs to finish or manually cancelling them (either via the API or the web).
        ```
        Code = "RESOURCE_EXHAUSTED"
        Metadata.error_code = "quota_exceeded"
        ```

        ### Account does not have any active or upcoming timeslots
        This error is returned if the job is submitted with the `use_timeslot` flag enabled,
        but the user's account does not have active or upcoming timeslots booked.
        ```
        Code = "FAILED_PRECONDITION"
        Metadata.error_code = "no_booked_timeslots"
        ```

        ### Account does not have enough credits to run the job
        This error is returned if the job is submitted with `use_timeslot` set to `false`
        and the user's account does not enough credits to execute the job.
        ```
        Code = "FAILED_PRECONDITION"
        Metadata.error_code = "not_enough_credits"
        ```

        ### Timeslot is required to execute job
        This error is returned if the target quantum computer requires timeslot to execute
        jobs but `use_timeslot` was unset (or set to `false`).
        ```
        Code = "FAILED_PRECONDITION"
        Metadata.error_code = "timeslot_required"
        ```

        ### Quantum computer not found
        This error is returned if the `qc_id` does not match any existing quantum computer.
        ```
        Code = "NOT_FOUND"
        Metadata.error_code = "not_found"
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetJobV1(self, request, context):
        """
        Get job details by JobLookup. Returns the job if the user job exists.
        User needs to be authorised to access the job data, i.e. the job must be created by the user.

        ## Errors
        In case of an error, a GRPC error status is returned with some optional additional
        details. The possible error cases are described below:

        ### Job not found
        This error is returned if the JobLookup does not match any existing job.
        ```
        Code = "NOT_FOUND"
        Metadata.error_code = "not_found"
        ```

        ### Quantum computer not found
        This error is returned if quantum computer associated with the job does not match any existing quantum computer.
        ```
        Code = "NOT_FOUND"
        Metadata.error_code = "not_found"
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SubscribeToJobV1(self, request, context):
        """
        Subscribes to the job changes. Returns a stream that emits the job at subscription
        moment and after that the changed job every time when the job state changes. The stream
        will end automatically when the job is considered as "final" and won't be updated
        anymore in the future (cancelled, interrupted, failed, completed).

        The stream may also emit empty `Keepalive` messages to indicate that job is still being
        processed but hasn't been updated. Clients may ignore these keepalive messages.

        ## Errors

        ### Job not found
        If the job does not exist with the given lookup, the following error is
        returned upon the subscription.
        ```
        Code = "NOT_FOUND"
        Metadata.error_code = "not_found"
        ```

        ### Job deleted during the subscription
        If the job gets deleted during the open subscription, the subscription stream will
        emit the following error and close immediately after that.
        ```
        Code = "ABORTED"
        Metadata.error_code = "job_deleted"
        ```

        ### Server cancellation
        If server wants to cancel the subscription (e.g. due to restarts or maintenance), the
        subscription stream will emit the following error and close immediately after that.
        ```
        Code = "ABORTED"
        Metadata.error_code = "server_cancel"
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetJobPayloadV1(self, request, context):
        """
        Get job payload as GRPC data chunk streams by JobLookup . Returns the job input data if the user job exists.
        User needs to be authorised to access the job.

        ## Errors
        In case of an error, a GRPC error status is returned with some optional additional
        details. The possible error cases are described below:

        ### Job not found
        This error is returned if the JobLookup does not match any existing job.
        ```
        Code = "NOT_FOUND"
        Metadata.error_code = "not_found"
        ```

        ### Job payload not found
        This error is returned if the job payload is not found.
        ```
        Code = "NOT_FOUND"
        Metadata.error_code = "not_found"
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetJobResultsV1(self, request, context):
        """
        Get job result as GRPC data chunk streams by JobLookup. Returns the job measurements data if the user job exists.
        User needs to be authorised to access the job.

        ## Errors
        In case of an error, a GRPC error status is returned with some optional additional
        details. The possible error cases are described below:

        ### Job not found
        This error is returned if the JobLookup does not match any existing job.
        ```
        Code = "NOT_FOUND"
        Metadata.error_code = "not_found"
        ```

        ### Job results not found
        This error is returned if the job results is not found.
        ```
        Code = "NOT_FOUND"
        Metadata.error_code = "not_found"
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def CancelJobV1(self, request, context):
        """
        Cancel a queued job by JobLookup. Returns the updated job when cancelled.
        User needs to be authorised to access the job.

        ## Errors
        In case of an error, a GRPC error status is returned with some optional additional
        details. The possible error cases are described below:

        ### Job not found
        This error is returned if the JobLookup does not match any existing user job.
        ```
        Code = "NOT_FOUND"
        Metadata.error_code = "not_found"
        ```

        ### Can't cancel job from QC because it's already in final state
        This error is returned if the job measurements is not found.
        ```
        Code = "FAILED_PRECONDITION"
        Metadata.error_code = "job_not_submitted_to_qc"
        ```

        ### Quantum computer not found
        This error is returned if quantum computer associated with the job does not match any existing quantum computer.
        ```
        Code = "NOT_FOUND"
        Metadata.error_code = "not_found"
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_JobsServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'SubmitJobV1': grpc.unary_unary_rpc_method_handler(
                    servicer.SubmitJobV1,
                    request_deserializer=job__pb2.SubmitJobRequestV1.FromString,
                    response_serializer=job__pb2.JobV1.SerializeToString,
            ),
            'GetJobV1': grpc.unary_unary_rpc_method_handler(
                    servicer.GetJobV1,
                    request_deserializer=job__pb2.JobLookupV1.FromString,
                    response_serializer=job__pb2.JobV1.SerializeToString,
            ),
            'SubscribeToJobV1': grpc.unary_stream_rpc_method_handler(
                    servicer.SubscribeToJobV1,
                    request_deserializer=job__pb2.JobLookupV1.FromString,
                    response_serializer=job__pb2.JobEventV1.SerializeToString,
            ),
            'GetJobPayloadV1': grpc.unary_stream_rpc_method_handler(
                    servicer.GetJobPayloadV1,
                    request_deserializer=job__pb2.JobLookupV1.FromString,
                    response_serializer=common__pb2.DataChunk.SerializeToString,
            ),
            'GetJobResultsV1': grpc.unary_stream_rpc_method_handler(
                    servicer.GetJobResultsV1,
                    request_deserializer=job__pb2.JobLookupV1.FromString,
                    response_serializer=common__pb2.DataChunk.SerializeToString,
            ),
            'CancelJobV1': grpc.unary_unary_rpc_method_handler(
                    servicer.CancelJobV1,
                    request_deserializer=job__pb2.JobLookupV1.FromString,
                    response_serializer=job__pb2.JobV1.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'iqm.server.Jobs', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('iqm.server.Jobs', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class Jobs(object):
    """
    User job management APIs.
    """

    @staticmethod
    def SubmitJobV1(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/iqm.server.Jobs/SubmitJobV1',
            job__pb2.SubmitJobRequestV1.SerializeToString,
            job__pb2.JobV1.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetJobV1(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/iqm.server.Jobs/GetJobV1',
            job__pb2.JobLookupV1.SerializeToString,
            job__pb2.JobV1.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def SubscribeToJobV1(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/iqm.server.Jobs/SubscribeToJobV1',
            job__pb2.JobLookupV1.SerializeToString,
            job__pb2.JobEventV1.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetJobPayloadV1(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/iqm.server.Jobs/GetJobPayloadV1',
            job__pb2.JobLookupV1.SerializeToString,
            common__pb2.DataChunk.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetJobResultsV1(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/iqm.server.Jobs/GetJobResultsV1',
            job__pb2.JobLookupV1.SerializeToString,
            common__pb2.DataChunk.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def CancelJobV1(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/iqm.server.Jobs/CancelJobV1',
            job__pb2.JobLookupV1.SerializeToString,
            job__pb2.JobV1.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
