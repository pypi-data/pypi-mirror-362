import {
  __commonJS
} from "./chunk-BUSYA2B4.js";

// node_modules/geobuf/encode.js
var require_encode = __commonJS({
  "node_modules/geobuf/encode.js"(exports, module) {
    "use strict";
    module.exports = encode;
    var keys;
    var keysNum;
    var keysArr;
    var dim;
    var e;
    var maxPrecision = 1e6;
    var geometryTypes = {
      "Point": 0,
      "MultiPoint": 1,
      "LineString": 2,
      "MultiLineString": 3,
      "Polygon": 4,
      "MultiPolygon": 5,
      "GeometryCollection": 6
    };
    function encode(obj, pbf) {
      keys = {};
      keysArr = [];
      keysNum = 0;
      dim = 0;
      e = 1;
      analyze(obj);
      e = Math.min(e, maxPrecision);
      var precision = Math.ceil(Math.log(e) / Math.LN10);
      for (var i = 0; i < keysArr.length; i++) pbf.writeStringField(1, keysArr[i]);
      if (dim !== 2) pbf.writeVarintField(2, dim);
      if (precision !== 6) pbf.writeVarintField(3, precision);
      if (obj.type === "FeatureCollection") pbf.writeMessage(4, writeFeatureCollection, obj);
      else if (obj.type === "Feature") pbf.writeMessage(5, writeFeature, obj);
      else pbf.writeMessage(6, writeGeometry, obj);
      keys = null;
      return pbf.finish();
    }
    function analyze(obj) {
      var i, key;
      if (obj.type === "FeatureCollection") {
        for (i = 0; i < obj.features.length; i++) analyze(obj.features[i]);
      } else if (obj.type === "Feature") {
        if (obj.geometry !== null) analyze(obj.geometry);
        for (key in obj.properties) saveKey(key);
      } else if (obj.type === "Point") analyzePoint(obj.coordinates);
      else if (obj.type === "MultiPoint") analyzePoints(obj.coordinates);
      else if (obj.type === "GeometryCollection") {
        for (i = 0; i < obj.geometries.length; i++) analyze(obj.geometries[i]);
      } else if (obj.type === "LineString") analyzePoints(obj.coordinates);
      else if (obj.type === "Polygon" || obj.type === "MultiLineString") analyzeMultiLine(obj.coordinates);
      else if (obj.type === "MultiPolygon") {
        for (i = 0; i < obj.coordinates.length; i++) analyzeMultiLine(obj.coordinates[i]);
      }
      for (key in obj) {
        if (!isSpecialKey(key, obj.type)) saveKey(key);
      }
    }
    function analyzeMultiLine(coords) {
      for (var i = 0; i < coords.length; i++) analyzePoints(coords[i]);
    }
    function analyzePoints(coords) {
      for (var i = 0; i < coords.length; i++) analyzePoint(coords[i]);
    }
    function analyzePoint(point) {
      dim = Math.max(dim, point.length);
      for (var i = 0; i < point.length; i++) {
        while (Math.round(point[i] * e) / e !== point[i] && e < maxPrecision) e *= 10;
      }
    }
    function saveKey(key) {
      if (keys[key] === void 0) {
        keysArr.push(key);
        keys[key] = keysNum++;
      }
    }
    function writeFeatureCollection(obj, pbf) {
      for (var i = 0; i < obj.features.length; i++) {
        pbf.writeMessage(1, writeFeature, obj.features[i]);
      }
      writeProps(obj, pbf, true);
    }
    function writeFeature(feature, pbf) {
      if (feature.geometry !== null) pbf.writeMessage(1, writeGeometry, feature.geometry);
      if (feature.id !== void 0) {
        if (typeof feature.id === "number" && feature.id % 1 === 0) pbf.writeSVarintField(12, feature.id);
        else pbf.writeStringField(11, feature.id);
      }
      if (feature.properties) writeProps(feature.properties, pbf);
      writeProps(feature, pbf, true);
    }
    function writeGeometry(geom, pbf) {
      pbf.writeVarintField(1, geometryTypes[geom.type]);
      var coords = geom.coordinates;
      if (geom.type === "Point") writePoint(coords, pbf);
      else if (geom.type === "MultiPoint") writeLine(coords, pbf, true);
      else if (geom.type === "LineString") writeLine(coords, pbf);
      else if (geom.type === "MultiLineString") writeMultiLine(coords, pbf);
      else if (geom.type === "Polygon") writeMultiLine(coords, pbf, true);
      else if (geom.type === "MultiPolygon") writeMultiPolygon(coords, pbf);
      else if (geom.type === "GeometryCollection") {
        for (var i = 0; i < geom.geometries.length; i++) pbf.writeMessage(4, writeGeometry, geom.geometries[i]);
      }
      writeProps(geom, pbf, true);
    }
    function writeProps(props, pbf, isCustom) {
      var indexes = [], valueIndex = 0;
      for (var key in props) {
        if (isCustom && isSpecialKey(key, props.type)) {
          continue;
        }
        pbf.writeMessage(13, writeValue, props[key]);
        indexes.push(keys[key]);
        indexes.push(valueIndex++);
      }
      pbf.writePackedVarint(isCustom ? 15 : 14, indexes);
    }
    function writeValue(value, pbf) {
      if (value === null) return;
      var type = typeof value;
      if (type === "string") pbf.writeStringField(1, value);
      else if (type === "boolean") pbf.writeBooleanField(5, value);
      else if (type === "object") pbf.writeStringField(6, JSON.stringify(value));
      else if (type === "number") {
        if (value % 1 !== 0) pbf.writeDoubleField(2, value);
        else if (value >= 0) pbf.writeVarintField(3, value);
        else pbf.writeVarintField(4, -value);
      }
    }
    function writePoint(point, pbf) {
      var coords = [];
      for (var i = 0; i < dim; i++) coords.push(Math.round(point[i] * e));
      pbf.writePackedSVarint(3, coords);
    }
    function writeLine(line, pbf) {
      var coords = [];
      populateLine(coords, line);
      pbf.writePackedSVarint(3, coords);
    }
    function writeMultiLine(lines, pbf, closed) {
      var len = lines.length, i;
      if (len !== 1) {
        var lengths = [];
        for (i = 0; i < len; i++) lengths.push(lines[i].length - (closed ? 1 : 0));
        pbf.writePackedVarint(2, lengths);
      }
      var coords = [];
      for (i = 0; i < len; i++) populateLine(coords, lines[i], closed);
      pbf.writePackedSVarint(3, coords);
    }
    function writeMultiPolygon(polygons, pbf) {
      var len = polygons.length, i, j;
      if (len !== 1 || polygons[0].length !== 1) {
        var lengths = [len];
        for (i = 0; i < len; i++) {
          lengths.push(polygons[i].length);
          for (j = 0; j < polygons[i].length; j++) lengths.push(polygons[i][j].length - 1);
        }
        pbf.writePackedVarint(2, lengths);
      }
      var coords = [];
      for (i = 0; i < len; i++) {
        for (j = 0; j < polygons[i].length; j++) populateLine(coords, polygons[i][j], true);
      }
      pbf.writePackedSVarint(3, coords);
    }
    function populateLine(coords, line, closed) {
      var i, j, len = line.length - (closed ? 1 : 0), sum = new Array(dim);
      for (j = 0; j < dim; j++) sum[j] = 0;
      for (i = 0; i < len; i++) {
        for (j = 0; j < dim; j++) {
          var n = Math.round(line[i][j] * e) - sum[j];
          coords.push(n);
          sum[j] += n;
        }
      }
    }
    function isSpecialKey(key, type) {
      if (key === "type") return true;
      else if (type === "FeatureCollection") {
        if (key === "features") return true;
      } else if (type === "Feature") {
        if (key === "id" || key === "properties" || key === "geometry") return true;
      } else if (type === "GeometryCollection") {
        if (key === "geometries") return true;
      } else if (key === "coordinates") return true;
      return false;
    }
  }
});

// node_modules/geobuf/decode.js
var require_decode = __commonJS({
  "node_modules/geobuf/decode.js"(exports, module) {
    "use strict";
    module.exports = decode;
    var keys;
    var values;
    var lengths;
    var dim;
    var e;
    var geometryTypes = [
      "Point",
      "MultiPoint",
      "LineString",
      "MultiLineString",
      "Polygon",
      "MultiPolygon",
      "GeometryCollection"
    ];
    function decode(pbf) {
      dim = 2;
      e = Math.pow(10, 6);
      lengths = null;
      keys = [];
      values = [];
      var obj = pbf.readFields(readDataField, {});
      keys = null;
      return obj;
    }
    function readDataField(tag, obj, pbf) {
      if (tag === 1) keys.push(pbf.readString());
      else if (tag === 2) dim = pbf.readVarint();
      else if (tag === 3) e = Math.pow(10, pbf.readVarint());
      else if (tag === 4) readFeatureCollection(pbf, obj);
      else if (tag === 5) readFeature(pbf, obj);
      else if (tag === 6) readGeometry(pbf, obj);
    }
    function readFeatureCollection(pbf, obj) {
      obj.type = "FeatureCollection";
      obj.features = [];
      return pbf.readMessage(readFeatureCollectionField, obj);
    }
    function readFeature(pbf, feature) {
      feature.type = "Feature";
      var f = pbf.readMessage(readFeatureField, feature);
      if (!("geometry" in f)) f.geometry = null;
      return f;
    }
    function readGeometry(pbf, geom) {
      geom.type = "Point";
      return pbf.readMessage(readGeometryField, geom);
    }
    function readFeatureCollectionField(tag, obj, pbf) {
      if (tag === 1) obj.features.push(readFeature(pbf, {}));
      else if (tag === 13) values.push(readValue(pbf));
      else if (tag === 15) readProps(pbf, obj);
    }
    function readFeatureField(tag, feature, pbf) {
      if (tag === 1) feature.geometry = readGeometry(pbf, {});
      else if (tag === 11) feature.id = pbf.readString();
      else if (tag === 12) feature.id = pbf.readSVarint();
      else if (tag === 13) values.push(readValue(pbf));
      else if (tag === 14) feature.properties = readProps(pbf, {});
      else if (tag === 15) readProps(pbf, feature);
    }
    function readGeometryField(tag, geom, pbf) {
      if (tag === 1) geom.type = geometryTypes[pbf.readVarint()];
      else if (tag === 2) lengths = pbf.readPackedVarint();
      else if (tag === 3) readCoords(geom, pbf, geom.type);
      else if (tag === 4) {
        geom.geometries = geom.geometries || [];
        geom.geometries.push(readGeometry(pbf, {}));
      } else if (tag === 13) values.push(readValue(pbf));
      else if (tag === 15) readProps(pbf, geom);
    }
    function readCoords(geom, pbf, type) {
      if (type === "Point") geom.coordinates = readPoint(pbf);
      else if (type === "MultiPoint") geom.coordinates = readLine(pbf, true);
      else if (type === "LineString") geom.coordinates = readLine(pbf);
      else if (type === "MultiLineString") geom.coordinates = readMultiLine(pbf);
      else if (type === "Polygon") geom.coordinates = readMultiLine(pbf, true);
      else if (type === "MultiPolygon") geom.coordinates = readMultiPolygon(pbf);
    }
    function readValue(pbf) {
      var end = pbf.readVarint() + pbf.pos, value = null;
      while (pbf.pos < end) {
        var val = pbf.readVarint(), tag = val >> 3;
        if (tag === 1) value = pbf.readString();
        else if (tag === 2) value = pbf.readDouble();
        else if (tag === 3) value = pbf.readVarint();
        else if (tag === 4) value = -pbf.readVarint();
        else if (tag === 5) value = pbf.readBoolean();
        else if (tag === 6) value = JSON.parse(pbf.readString());
      }
      return value;
    }
    function readProps(pbf, props) {
      var end = pbf.readVarint() + pbf.pos;
      while (pbf.pos < end) props[keys[pbf.readVarint()]] = values[pbf.readVarint()];
      values = [];
      return props;
    }
    function readPoint(pbf) {
      var end = pbf.readVarint() + pbf.pos, coords = [];
      while (pbf.pos < end) coords.push(pbf.readSVarint() / e);
      return coords;
    }
    function readLinePart(pbf, end, len, closed) {
      var i = 0, coords = [], p, d;
      var prevP = [];
      for (d = 0; d < dim; d++) prevP[d] = 0;
      while (len ? i < len : pbf.pos < end) {
        p = [];
        for (d = 0; d < dim; d++) {
          prevP[d] += pbf.readSVarint();
          p[d] = prevP[d] / e;
        }
        coords.push(p);
        i++;
      }
      if (closed) coords.push(coords[0]);
      return coords;
    }
    function readLine(pbf) {
      return readLinePart(pbf, pbf.readVarint() + pbf.pos);
    }
    function readMultiLine(pbf, closed) {
      var end = pbf.readVarint() + pbf.pos;
      if (!lengths) return [readLinePart(pbf, end, null, closed)];
      var coords = [];
      for (var i = 0; i < lengths.length; i++) coords.push(readLinePart(pbf, end, lengths[i], closed));
      lengths = null;
      return coords;
    }
    function readMultiPolygon(pbf) {
      var end = pbf.readVarint() + pbf.pos;
      if (!lengths) return [[readLinePart(pbf, end, null, true)]];
      var coords = [];
      var j = 1;
      for (var i = 0; i < lengths[0]; i++) {
        var rings = [];
        for (var k = 0; k < lengths[j]; k++) rings.push(readLinePart(pbf, end, lengths[j + 1 + k], true));
        j += lengths[j] + 1;
        coords.push(rings);
      }
      lengths = null;
      return coords;
    }
  }
});

// node_modules/geobuf/index.js
var require_geobuf = __commonJS({
  "node_modules/geobuf/index.js"(exports) {
    exports.encode = require_encode();
    exports.decode = require_decode();
  }
});
export default require_geobuf();
//# sourceMappingURL=geobuf.js.map
